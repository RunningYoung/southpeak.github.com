<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="南峰子的技术博客">
<meta property="og:url" content="http://southpeak.github.io/page/6/index.html">
<meta property="og:site_name" content="南峰子的技术博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="南峰子的技术博客">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://southpeak.github.io/page/6/"/>

  <title> 南峰子的技术博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-68856508-1', 'auto');
  ga('send', 'pageview');
</script>







  <div style="display: none;">
    <script src="http://s95.cnzz.com/z_stat.php?id=1000523916&web_id=1000523916" language="JavaScript"></script>
  </div>





  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">南峰子的技术博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">攀登，一步一个脚印，方能知其乐</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-techset">
          <a href="/categories/techset" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-fighter-jet"></i> <br />
            
            知识小集
          </a>
        </li>
      
        
        <li class="menu-item menu-item-swift">
          <a href="/categories/swift" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-space-shuttle"></i> <br />
            
            Swift
          </a>
        </li>
      
        
        <li class="menu-item menu-item-objectivec">
          <a href="/categories/objectivec" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-taxi"></i> <br />
            
            Objective-C
          </a>
        </li>
      
        
        <li class="menu-item menu-item-cocoa">
          <a href="/categories/cocoa" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-subway"></i> <br />
            
            Cocoa
          </a>
        </li>
      
        
        <li class="menu-item menu-item-translate">
          <a href="/categories/translate" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-rocket"></i> <br />
            
            翻译
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sourcecode">
          <a href="/categories/sourcecode" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-train"></i> <br />
            
            源码分析
          </a>
        </li>
      
        
        <li class="menu-item menu-item-something">
          <a href="/categories/something" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-bicycle"></i> <br />
            
            杂项
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/10/19/instancetype/" itemprop="url">
                  instancetype
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-10-19T00:26:03+08:00" content="2014-10-19">
              2014-10-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>注：原文由Mattt <code>Thompson</code>发表于<code>nshipster</code>：<a href="http://nshipster.com/instancetype/" target="_blank" rel="external">instancetype</a>。<strong>文章是2012年写的，所以有些内容现在已不适用。</strong></p>
<p>在<code>Objective-C</code>中，约定(<code>conventions</code>)不仅仅是编码最佳实践的问题，同时对编译器来说，也是一种隐式说明。</p>
<p>例如，<code>alloc</code>和<code>init</code>两个方法都返回<code>id</code>类型，而在<code>Xcode</code>中，编译器会对它们进行类型检查。这是怎么做到的呢？</p>
<p>在<code>Cocoa</code>中，有一个这样的约定，命名为<code>alloc/init</code>的方法总是返回接收者类的实例。这些方法有一个相关的返回类型。</p>
<p>而类的构造方法(类方法)，虽然他们都是返回<code>id</code>类型，但没有从类型检查中获得好处，因为他们不遵循命名约定。</p>
<p>我们可以试试以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[[[<span class="built_in">NSArray</span> alloc] init] mediaPlaybackAllowsAirPlay]; <span class="comment">// 报错： "No visible @interface for `NSArray` declares the selector `mediaPlaybackAllowsAirPlay`"</span></div><div class="line"></div><div class="line">[[<span class="built_in">NSArray</span> array] mediaPlaybackAllowsAirPlay]; <span class="comment">// (No error) 注：这个方法调用只在老的编译器上成立，新的编译器会报相同的错误。</span></div></pre></td></tr></table></figure>
<p>由于<code>alloc</code>和<code>init</code>遵循返回相关结果类型的约定，所以会对<code>NSArray</code>执行类型检查。然而等价的类构造方法<code>array</code>则不遵循这一约定，只解释为<code>id</code>类型。</p>
<p><code>id</code>类型在不需要确保类型安全时非常有用，但一旦需要时，就无法处理了。</p>
<p>而另一种方法，即显示声明返回类型(如前面例子中的(<code>NSArray *</code>))稍微改善了一些，但写起来有点麻烦，而且在继承体系中表现得不是很好。</p>
<p>这时编译器就需要去解决这种针对<code>Objective-C</code>类型系统的边界情况了:</p>
<p><code>instancetype</code>是一个上下文关键字，可用在返回类型中以表示方法返回一个相关的结果类型，如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span></span></div><div class="line">+ (<span class="keyword">instancetype</span>)personWithName:(<span class="built_in">NSString</span> *)name;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>使用<code>instancetype</code>，编译器可以正确地知道<code>personWithName:</code>的返回结果是一个<code>Person</code>实例。</p>
<p>我们现在看<code>Foundation</code>中的类构造器，可以发现大部分已经开始使用了<code>instancetype</code>了。新的<code>API</code>，如<code>UICollectionViewLayoutAttributes</code>，都是使用<code>instancetype</code>了。</p>
<p><em>注：<code>instancetype</code>与<code>id</code>不同的是，它只能用在方法声明的返回值中。</em></p>
<h4 id="更进一步的启示"><a href="#更进一步的启示" class="headerlink" title="更进一步的启示"></a>更进一步的启示</h4><p>语言特性是特别有趣的，因为它不清楚在软件设计的更高层次方面会带来什么样的影响。</p>
<p>虽然<code>instancetype</code>看上去非常一般，只是对编译器有用，但也可能被用于一些更聪明的目的。</p>
<p><code>Jonathan Sterling</code>的文章<a href="http://www.jonmsterling.com/posts/2012-02-05-typed-collections-with-self-types-in-objective-c.html" target="_blank" rel="external">this quite interesting article</a>，详细描述了<code>instancetype</code>如何被用于编码静态类型集合，而不需要使用泛型：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURL</span> &lt;MapCollection&gt; *sites = (<span class="keyword">id</span>)[<span class="built_in">NSURL</span> mapCollection];</div><div class="line">[sites put:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.jonmsterling.com/"</span>]</div><div class="line">        at:<span class="string">@"jon"</span>];</div><div class="line">[sites put:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.nshipster.com/"</span>]</div><div class="line">        at:<span class="string">@"nshipster"</span>];</div><div class="line"></div><div class="line"><span class="built_in">NSURL</span> *jonsSite = [sites at:<span class="string">@"jon"</span>]; <span class="comment">// =&gt; http://www.jonmsterling.com/</span></div></pre></td></tr></table></figure>
<p>静态类型集合使得API更有表现力，这样开发者将不再需要去确定集合中的参数可以使用使用类型的对象了。</p>
<p>不管这会不会成为<code>Objective-C</code>公认的约定，诸如<code>instancetype</code>这样一个低层特性可用于改变语言的形态已是非常棒的一件事了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/10/17/osatomic-operation/" itemprop="url">
                  OSAtomic原子操作
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-10-17T10:56:00+08:00" content="2014-10-17">
              2014-10-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/something/" itemprop="url" rel="index">
                    <span itemprop="name">杂项</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>并发编程一个主要问题就是如何同步数据。同步数据的方式有很多种，这里我们介绍一下<code>libkern/OSAtomic.h</code>。这个头文件包含是大量关于原子操作和同步操作的函数，如果要对数据进行同步操作，这里面的函数可以作为我们的首选项。不同平台这些函数的实现是自定义的。另外，它们是线程安全的。</p>
<p>需要注意的是，传递给这些函数的所有地址都必须是“自然对齐”的，例如<code>int32_t *</code>指针必须是32位对齐的(地址的低位2个bit为0)，<code>int64_t *</code>指针必须是64位对齐的(低3位为0)。</p>
<p>这些原子函数的一些版本整合了内存屏障(memory barriers)，而另一些则没有。在诸如PPC这样的弱有序(weakly-ordered)架构中，Barriers严格限制了内存访问顺序。所有出现在barriers之前的加载和存储操作完成后，才会运行barriers之后的加载和存储操作。</p>
<p>在单处理器系统中，barriers操作通常是一个空操作。在多处理器系统中，barriers在某些平台上可能是相当昂贵的操作，如PPC。</p>
<p>大多数代码都应该使用barrier函数来确保在线程间共享的内存是正确同步的。例如，如果我们想要初始化一个共享的数据结构，然后自动增加某个变量值来标识初始化操作完成，则我们必须使用<code>OSAtomicIncrement32Barrier</code>来确保数据结构的存储操作在变量自动增加前完成。</p>
<p>同样的，该数据结构的消费者也必须使用<code>OSAtomicIncrement32Barrier</code>，以确保在自动递增变量值之后再去加载这些数据。另一方面，如果我们只是简单地递增一个全局计数器，那么使用<code>OSAtomicIncrement32</code>会更安全且可能更快。</p>
<p>如果不能确保我们使用的是哪个版本，则使用barrier变量以保证是安全的。</p>
<p>另外，自旋锁和队列操作总是包含一个barrier。</p>
<p>这个头文件中的函数主要可以分为以下几类</p>
<h2 id="内存屏障-Memory-barriers"><a href="#内存屏障-Memory-barriers" class="headerlink" title="内存屏障(Memory barriers)"></a>内存屏障(Memory barriers)</h2><p>内存屏障的概念如上所述，它是一种屏障和指令类，可以让CPU或编译器强制将barrier之前和之后的内存操作分开。CPU采用了一些可能导致乱序执行的性能优化。在单个线程的执行中，内存操作的顺序一般是悄无声息的，但是在并发编程和设备驱动程序中就可能出现一些不可预知的行为，除非我们小心地去控制。排序约束的特性是依赖于硬件的，并由架构的内存顺序模型来定义。一些架构定义了多种barrier来执行不同的顺序约束。</p>
<p><code>OSMemoryBarrier()</code>函数就是用来设置内存屏障，它即可以用于读操作，也可以用于写操作。</p>
<p>示例代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 代码来自ReactiveCocoa:RACDisposable类</span></div><div class="line">	</div><div class="line">- (<span class="keyword">id</span>)initWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(block != <span class="literal">nil</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> == <span class="literal">nil</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    _disposeBlock = (<span class="keyword">void</span> *)<span class="built_in">CFBridgingRetain</span>([block <span class="keyword">copy</span>]);</div><div class="line">    OSMemoryBarrier();</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="自旋锁-Spinlocks"><a href="#自旋锁-Spinlocks" class="headerlink" title="自旋锁(Spinlocks)"></a>自旋锁(Spinlocks)</h2><p>自旋锁是在多处理器系统(SMP)上为保护一段关键代码的执行或者关键数据的一种保护机制，是实现synchronization的一种手段。</p>
<p><code>libkern/OSAtomic.h</code>中包含了三个关于自旋锁的函数：<code>OSSpinLockLock</code>, <code>OSSpinLockTry</code>, <code>OSSpinLockUnlock</code>。</p>
<p>示例代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 代码来自ReactiveCocoa:RACCompoundDisposable类</span></div><div class="line">	</div><div class="line">- (<span class="keyword">void</span>)dispose &#123;</div><div class="line"><span class="meta">#if RACCompoundDisposableInlineCount</span></div><div class="line">    RACDisposable *inlineCopy[RACCompoundDisposableInlineCount];</div><div class="line"><span class="meta">#endif</span></div><div class="line">    </div><div class="line">    <span class="built_in">CFArrayRef</span> remainingDisposables = <span class="literal">NULL</span>;</div><div class="line">    </div><div class="line">    OSSpinLockLock(&amp;_spinLock);</div><div class="line">    &#123;</div><div class="line">        _disposed = <span class="literal">YES</span>;</div><div class="line">        </div><div class="line"><span class="meta">#if RACCompoundDisposableInlineCount</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; RACCompoundDisposableInlineCount; i++) &#123;</div><div class="line">            inlineCopy[i] = _inlineDisposables[i];</div><div class="line">            _inlineDisposables[i] = <span class="literal">nil</span>;</div><div class="line">        &#125;</div><div class="line"><span class="meta">#endif</span></div><div class="line">        </div><div class="line">        remainingDisposables = _disposables;</div><div class="line">        _disposables = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    OSSpinLockUnlock(&amp;_spinLock);</div><div class="line">    </div><div class="line"><span class="meta">#if RACCompoundDisposableInlineCount</span></div><div class="line">    <span class="comment">// Dispose outside of the lock in case the compound disposable is used</span></div><div class="line">    <span class="comment">// recursively.</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; RACCompoundDisposableInlineCount; i++) &#123;</div><div class="line">        [inlineCopy[i] dispose];</div><div class="line">    &#125;</div><div class="line"><span class="meta">#endif</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (remainingDisposables == <span class="literal">NULL</span>) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="built_in">CFIndex</span> count = <span class="built_in">CFArrayGetCount</span>(remainingDisposables);</div><div class="line">    <span class="built_in">CFArrayApplyFunction</span>(remainingDisposables, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, count), &amp;disposeEach, <span class="literal">NULL</span>);</div><div class="line">    <span class="built_in">CFRelease</span>(remainingDisposables);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="原子队列操作"><a href="#原子队列操作" class="headerlink" title="原子队列操作"></a>原子队列操作</h2><p>队列操作主要包含两类：</p>
<ol>
<li>不加锁的FIFO入队和出队原子操作，包含<code>OSAtomicFifoDequeue</code>和<code>OSAtomicFifoEnqueue</code>两个函数</li>
<li>不加锁的LIFO入队和出队原子操作，包含<code>OSAtomicDequeue</code>和<code>OSAtomicEnqueue</code>两个函数。这两个函数是线程安全的，对有潜在精确要求的代码来说，这会是强大的构建方式。</li>
</ol>
<h2 id="比较和交换"><a href="#比较和交换" class="headerlink" title="比较和交换"></a>比较和交换</h2><p>这组函数可以细分为三组函数：</p>
<ol>
<li><code>OSAtomicCompareAndSwap**[Barrier](type __oldValue, type __newValue, volatile type *__theValue)</code>：这组函数用于比较<code>__oldValue</code>是否与<code>__theValue</code>指针指向的内存位置的值匹配，如果匹配，则将<code>__newValue</code>的值存储到<code>__theValue</code>指向的内存位置。可以根据需要使用barrier版本。</li>
<li><code>OSAtomicTestAndClear/OSAtomicTestAndClearBarrier(uint32_t __n, volatile void * __theAddress)</code>：这组函数用于测试<code>__theAddress</code>指向的值中由<code>__n</code>指定的bit位，如果该位未被清除，则清除它。需要注意的是最低bit位应该是1，而不是0。对于一个64-bit的值来说，如果要清除最高位的值，则<code>__n</code>应该是64。</li>
<li><code>OSAtomicTestAndSet/OSAtomicTestAndSetBarrier(uint32_t __n, volatile void * __theAddress)</code>：与<code>OSAtomicTestAndClear</code>相反，这组函数测试值后，如果指定位没有设置，则设置它。</li>
</ol>
<p>示例代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> * sharedBuffer(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">void</span> * buffer;</div><div class="line">    <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">void</span> * newBuffer = calloc(<span class="number">1</span>, <span class="number">1024</span>);</div><div class="line">        <span class="keyword">if</span> (!OSAtomicCompareAndSwapPtrBarrier(<span class="literal">NULL</span>, newBuffer, &amp;buffer)) &#123;</div><div class="line">            free(newBuffer);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> buffer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码的作用是如果没有缓冲区，我们将创建一个newBuffer，然后将其写到buffer中。</p>
<h2 id="布尔操作-AND-OR-XOR"><a href="#布尔操作-AND-OR-XOR" class="headerlink" title="布尔操作(AND, OR, XOR)"></a>布尔操作(AND, OR, XOR)</h2><p>这组函数可根据以下两个规则来分类：</p>
<ol>
<li>是否使用Barrier</li>
<li>返回值是原始值还是操作完成后的值</li>
</ol>
<p>以And为例，有4个函数：<code>OSAtomicAnd32</code>, <code>OSAtomicAnd32Barrier</code>, <code>OSAtomicAnd32Orig</code>, <code>OSAtomicAnd32OrigBarrier</code>。每个函数均带有两个参数：<code>__theMask(uint32_t)</code>和<code>__theValue(volatile uint32_t *)</code>。函数将<code>__theMask</code>与<code>__theValue</code>指向的值做AND操作。</p>
<p>类似，还有OR操作和XOR操作。</p>
<h2 id="数学操作"><a href="#数学操作" class="headerlink" title="数学操作"></a>数学操作</h2><p>这组函数主要包括：</p>
<ol>
<li>加操作：<code>OSAtomicAdd**</code>, <code>OSAtomicAdd**Barrier</code></li>
<li>递减操作：<code>OSAtomicDecrement**</code>, <code>OSAtomicDecrement**Barrier</code></li>
<li>递增操作：<code>OSAtomicIncrement**</code>, <code>OSAtomicIncrement**Barrier</code></li>
</ol>
<p>示例代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 代码摘自ReactiveCocoa:RACDynamicSequence</span></div><div class="line">	</div><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line">	<span class="keyword">static</span> <span class="keyword">volatile</span> int32_t directDeallocCount = <span class="number">0</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">if</span> (OSAtomicIncrement32(&amp;directDeallocCount) &gt;= DEALLOC_OVERFLOW_GUARD) &#123;</div><div class="line">		OSAtomicAdd32(-DEALLOC_OVERFLOW_GUARD, &amp;directDeallocCount);</div><div class="line">	</div><div class="line">		<span class="comment">// Put this sequence's tail onto the autorelease pool so we stop</span></div><div class="line">		<span class="comment">// recursing.</span></div><div class="line">		__autoreleasing RACSequence *tail __attribute__((unused)) = _tail;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	_tail = <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>相较于<code>@synchronized</code>，OSAtomic原子操作更趋于数据的底层，从更深层次来对单例进行保护。同时，它没有阻断其它线程对函数的访问。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://developer.apple.com/library/mac/documentation/System/Reference/OSAtomic_header_reference/Reference/reference.html" target="_blank" rel="external">OSAtomic.h User-Space Reference</a></li>
<li><a href="http://blog.csdn.net/wzb56_earl/article/details/6634622" target="_blank" rel="external">Memory barrier</a></li>
<li><a href="http://www.cocoachina.com/industry/20130821/6842.html" target="_blank" rel="external">Objc的底层并发API</a></li>
<li><a href="http://blog.csdn.net/tuxiangqi/article/details/8076972" target="_blank" rel="external">OSATOMIC与synchronized加锁的对比</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/09/23/tutorial-performance-and-time/" itemprop="url">
                  Tutorial performance and time
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-09-23T23:55:35+08:00" content="2014-09-23">
              2014-09-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文链接：<a href="http://www.macresearch.org/tutorial_performance_and_time" target="_blank" rel="external">Tutorial performance and time</a></p>
<p>在讨论性能之前，先讨论一个重要的话题：时间。为了理解代码中的变化如何影响性能，我们需要一个排序的指标。有许多方法用于时间例程，一些比另一些合适。在本教程中我们将讨论<code>Mach Absolute Time</code>。</p>
<h2 id="为什么是Mach"><a href="#为什么是Mach" class="headerlink" title="为什么是Mach?"></a>为什么是Mach?</h2><p>时间例程依赖于所需要测量的时间域。某些情况下使用诸如<code>clock()</code>或<code>getrusage()</code>函数来做些简单的数学运算就足够了。如果时间例程将用于实际的开发框架之外，可移植性就很重要了。我不使用这些。为什么？</p>
<p>对于我来说，调试代码的典型问题是：</p>
<ol>
<li>我只需要在即时测试时使用时间例程</li>
<li>我不喜欢依赖于多种函数来包含不同的时间域。它们的行为可能不一致</li>
<li>有时我需要一个高精度定时器</li>
</ol>
<h2 id="欢迎了解mach-absolute-time"><a href="#欢迎了解mach-absolute-time" class="headerlink" title="欢迎了解mach_absolute_time"></a>欢迎了解mach_absolute_time</h2><p><code>mach_absolute_time</code>是一个<code>CPU</code>/总线依赖函数，返回一个基于系统启动后的时钟”嘀嗒”数。它没有很好的文档定义，但这不应该成为使用它的障碍，因为在<code>MAC OS X</code>上可以确保它的行为，并且，它包含系统时钟包含的所有时间区域。那是否应该在产品代码中使用它呢？可能不应该。但是对于测试，它却恰到好处。</p>
<p>使用<code>mach_absolute_time</code>时需要考虑两个因素：</p>
<ol>
<li>如何获取当前的<code>Mach</code>绝对时间</li>
<li>如何将其转换为有意义的数字</li>
</ol>
<h2 id="获取mach-absolute-time"><a href="#获取mach-absolute-time" class="headerlink" title="获取mach_absolute_time"></a>获取mach_absolute_time</h2><p>这非常简单</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span> </span></div><div class="line"><span class="keyword">uint64_t</span> start = mach_absolute_time();</div><div class="line"><span class="keyword">uint64_t</span> stop = mach_absolute_time();</div></pre></td></tr></table></figure>
<p>这样就可以了。我们通常获取两个值，以得到这两个时间的时间差。</p>
<h2 id="将mach-absolute-time时间差转换为秒数"><a href="#将mach-absolute-time时间差转换为秒数" class="headerlink" title="将mach_absolute_time时间差转换为秒数"></a>将mach_absolute_time时间差转换为秒数</h2><p>这稍微有点复杂，因为我们需要获取<code>mach_absolute_time</code>所基于的系统时间基准。如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mach/mach_time.h&gt;</span> </span></div><div class="line"><span class="comment">//Raw mach_absolute_times going in,difference in seconds out</span></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">subtractTimes</span><span class="params">( uint64_tendTime, <span class="keyword">uint64_t</span> startTime )</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">uint64_t</span> difference = endTime - startTime;</div><div class="line">	<span class="keyword">static</span> <span class="keyword">double</span> conversion = <span class="number">0.0</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">if</span>( conversion == <span class="number">0.0</span> )</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">mach_timebase_info_data_t</span> info;</div><div class="line">		<span class="keyword">kern_return_t</span> err =mach_timebase_info( &amp;info );</div><div class="line">		</div><div class="line">		<span class="comment">//Convert the timebase into seconds</span></div><div class="line">		<span class="keyword">if</span>( err == <span class="number">0</span>  )</div><div class="line">			conversion= <span class="number">1e-9</span> * (<span class="keyword">double</span>) info.numer / (<span class="keyword">double</span>) info.denom;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">return</span> conversion * (<span class="keyword">double</span>)difference;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里最重要的是调用<code>mach_timebase_info</code>。我们传递一个结构体以返回时间基准值。最后，一旦我们获取到系统的心跳，我们便能生成一个转换因子。通常，转换是通过分子(<code>info.numer</code>)除以分母(<code>info.denom</code>)。这里我乘了一个<code>1e-9</code>来获取秒数。最后，我们获取两个时间的差值，并乘以转换因子，便得到真实的时间差。</p>
<p>现在我们可能会想，为什么这比用<code>clock</code>好？看起来做了更多的事情。确实是有点，这便是为什么它在一个函数中。我们只需要传递我们的值到函数中并取得答案。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>让我们写个例子。下面是完整的代码清单(包括<code>mach</code>函数)。可以使用<code>gcc mach.c –o mach</code>来编译它：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mach/mach_time.h&gt;</span> </span></div><div class="line"></div><div class="line"><span class="comment">//Raw mach_absolute_times going in,difference in seconds out</span></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">subtractTimes</span><span class="params">( uint64_tendTime, <span class="keyword">uint64_t</span> startTime )</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">uint64_t</span> difference = endTime -startTime;</div><div class="line">	<span class="keyword">static</span> <span class="keyword">double</span> conversion = <span class="number">0.0</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">if</span>( conversion == <span class="number">0.0</span> )</div><div class="line">	&#123;        </div><div class="line">		mach_timebase_info_data_tinfo;        </div><div class="line">		kern_return_terr = mach_timebase_info( &amp;info );                       <span class="comment">//Convert the timebaseinto seconds        </span></div><div class="line">		</div><div class="line">		<span class="keyword">if</span>(err == <span class="number">0</span>  )                       </div><div class="line">			conversion= <span class="number">1e-9</span> * (<span class="keyword">double</span>) info.numer / (<span class="keyword">double</span>) info.denom;    </div><div class="line">	&#125;</div><div class="line">	         </div><div class="line">	<span class="keyword">return</span> conversion * (<span class="keyword">double</span>)difference;</div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	inti, j, count;</div><div class="line">	<span class="keyword">uint64_t</span> start,stop;</div><div class="line">	doublecurrent = <span class="number">0.0</span>;</div><div class="line">	doubleanswer = <span class="number">0.0</span>;</div><div class="line">	doubleelapsed = <span class="number">0.0</span>;</div><div class="line">	intdim1 = <span class="number">256</span>;</div><div class="line">	intdim2 = <span class="number">256</span>;</div><div class="line">	intsize = <span class="number">4</span>*dim1*dim2;</div><div class="line">	</div><div class="line">	<span class="comment">//Allocatesome memory and warm it up</span></div><div class="line">	<span class="keyword">double</span> *<span class="built_in">array</span> =(<span class="keyword">double</span>*)<span class="built_in">malloc</span>(size*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));       </div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;size;i++)<span class="built_in">array</span> = (<span class="keyword">double</span>)i;</div><div class="line">	</div><div class="line">	count= <span class="number">5</span>;     </div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;count;i++)</div><div class="line">	&#123;              </div><div class="line">		start = mach_absolute_time();                                 </div><div class="line">		<span class="comment">//dosome work</span></div><div class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;size;j++)</div><div class="line">		&#123;</div><div class="line">			answer+= <span class="built_in">sqrt</span>(<span class="built_in">array</span>[j]);</div><div class="line">		&#125;</div><div class="line">		stop = mach_absolute_time();</div><div class="line">		current= subtractTimes(stop,start);</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"Timefor iteration: %1.12lf for answer: %1.12lf\n"</span>,current, answer);</div><div class="line">		elapsed+= current;</div><div class="line">	&#125; </div><div class="line">	      </div><div class="line">	<span class="built_in">printf</span>(<span class="string">"\nTotaltime in seconds = %1.12lf for answer: %1.12lf\n"</span>,elapsed/count,answer);</div><div class="line">	<span class="built_in">free</span>(<span class="built_in">array</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们在这里做了什么？在这个例子中，我们有一个适当大小的<code>double</code>数组，当中存放了一些数字，然后获取这些数值的和的开方。为了测试，我们迭代了<code>5</code>次这个计算。每次迭代后我们打印花费的时间，并总结了计算所需的运行时间。在我的<code>PowerMac G5(2.5)</code>机器上，我获得如下结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[bigmac:~/misc] macresearch% gcc mach.c -omach</div><div class="line">[bigmac:~/misc] macresearch%./mach </div><div class="line">Time <span class="keyword">for</span> iteration: <span class="number">0.006717496412f</span>or answer: <span class="number">89478229.125529855490</span></div><div class="line">Time <span class="keyword">for</span> iteration: <span class="number">0.007274204955f</span>or answer: <span class="number">178956458.251062750816</span></div><div class="line">Time <span class="keyword">for</span> iteration: <span class="number">0.006669191332f</span>or answer: <span class="number">268434687.376589745283</span></div><div class="line">Time <span class="keyword">for</span> iteration: <span class="number">0.006953711252f</span>or answer: <span class="number">357912916.502135872841</span></div><div class="line">Time <span class="keyword">for</span> iteration: <span class="number">0.007582157340f</span>or answer: <span class="number">447391145.627681851387</span> </div><div class="line">Average time in seconds =<span class="number">0.007039352258</span> <span class="keyword">for</span> answer: <span class="number">447391145.627681851387</span></div></pre></td></tr></table></figure>
<p>注意，在这里我没有进行优化，因为编译器有方法避开这样的无脑循环。另外，这只是一个例子。如果是真正的代码，我们会进行优化。</p>
<p>好了，这就是这个例子的两个目的。</p>
<p>首先，我使用的数组大小比我的缓存大。我这样做的目的是因为我们需要注意到数据溢出缓存的情况(正如这个例子一样，至少在我的系统中是这样。如果是在<code>MacPro</code>中，不会出现这种情况)。我们将在以后讨论缓存的事宜。当然，这是一个做作的例子，但有一些东西可供思考。其次，你注意到在内存分配之前我写了一句注释，这是什么意思呢？</p>
<p>这在实际情况下是不需要关心的事情，因为内存总是在需要时已准备好使用。但当做一些小测试时来测试函数的性能时，它却可能是会影响到测试结果的实际问题。</p>
<p>当动态分配内存时，第一次访问内存管理时会将其清<code>0</code>(在<code>OS X</code>中不管使用哪种动态分配函数:<code>malloc</code>, <code>calloc</code>…所有内存在用户使用前都会清<code>0</code>)。内存清零是一种安全预防措施(我们不需要递交一些包含安全信息的内容，如解密密钥)</p>
<p>清零过程产生一个副作用(被系统标记为零填充页面故障)。所以为了让我们的计时更精确些，我们在使用内存之前一次性填充数据，以确保我们不会获取到零填充页面故障的处理时间。</p>
<p>让我们来测试一下，注释下面这行代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;size;i++) <span class="built_in">array</span> =(<span class="keyword">double</span>)i;</div></pre></td></tr></table></figure>
<p>为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//for(i=0;i&lt;size;i++) array =(double)i;</span></div></pre></td></tr></table></figure>
<p>再次运行测试</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[bigmac:~/misc] macresearch% ./mach</div><div class="line">Time <span class="keyword">for</span> iteration: <span class="number">0.009478866798f</span>or answer: <span class="number">0.000000000000</span></div><div class="line">Time <span class="keyword">for</span> iteration: <span class="number">0.004756880234f</span>or answer: <span class="number">0.000000000000</span></div><div class="line">Time <span class="keyword">for</span> iteration: <span class="number">0.004927868215f</span>or answer: <span class="number">0.000000000000</span></div><div class="line">Time <span class="keyword">for</span> iteration: <span class="number">0.005227029674f</span>or answer: <span class="number">0.000000000000</span></div><div class="line">Time <span class="keyword">for</span> iteration: <span class="number">0.004891864428f</span>or answer: <span class="number">0.000000000000</span> </div><div class="line">Average time in seconds =<span class="number">0.005856501870</span> <span class="keyword">for</span> answer: <span class="number">0.000000000000</span></div></pre></td></tr></table></figure>
<p>注意第一次迭代的时间比后序的时间多了将近一倍。同时还需要注意所有的<code>answer</code>都是<code>0</code>。再次说明内存被清零了。如果我们从堆上获取了内存，我们获取到的是无意义的数值。</p>
<p>最后，但很重要的一点。不要依赖于内存的清零操作。很有可能获取到的内存是从一个静态分配区而来，那么可能会导致如下这样的问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> <span class="built_in">array</span>[<span class="number">3</span>][<span class="number">3</span>];</div></pre></td></tr></table></figure>
<p>在我的系统上的打印结果是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">-1.99844</span> <span class="number">-1.29321e-231</span> <span class="number">-1.99844</span></div><div class="line"><span class="number">-3.30953e-232</span> <span class="number">-5.31401e+303</span> <span class="number">0</span></div><div class="line"><span class="number">1.79209e-313</span> <span class="number">3.3146e-314</span> <span class="number">0</span></div></pre></td></tr></table></figure>
<p>所以需要特别注意</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/09/21/binding-to-a-uitableview-from-a-reactivecocoa-viewmodel/" itemprop="url">
                  Binding To A UITableView From A ReactiveCocoa ViewModel
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-09-21T14:14:19+08:00" content="2014-09-21">
              2014-09-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>英文作者Colin Eberhardt，原文可查看<a href="http://www.scottlogic.com/blog/2014/05/11/reactivecocoa-tableview-binding.html" target="_blank" rel="external">BINDING TO A UITABLEVIEW FROM A REACTIVECOCOA VIEWMODEL</a></p>
<p>这篇博客介绍了一个工具类，这个类将<code>ReactiveCocoa</code>中的<code>ViewModels</code>绑定到<code>UITableView</code>，而不需要通常的datasource和delegate。下面是这个辅助类的使用方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个cell</span></div><div class="line"><span class="built_in">UINib</span> *nib = [<span class="built_in">UINib</span> nibWithNibName:<span class="string">@"CETweetTableViewCell"</span> bundle:<span class="literal">nil</span>];</div><div class="line">	</div><div class="line"><span class="comment">// 将ViewModels的searchResults属性绑定到table view</span></div><div class="line">[CETableViewBindingHelper bindingHelperForTableView:<span class="keyword">self</span>.searchResultsTable</div><div class="line">                        sourceSignal:RACObserve(<span class="keyword">self</span>.viewModel, searchResults)</div><div class="line">                        templateCell:nib];</div></pre></td></tr></table></figure>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>我总是在不断的编写代码：在工作中，在家里，在火车上…如果我不写代码，我就会觉得不快乐！(注：这才是真正的程序员啊)</p>
<p>在过去的几个月中，我开始在我的工程中越来越多地使用ReactiveCocoa了。这个框架可以用来创建一些非常优雅的解决方案，但同时它非常具有挑战性，因为对于任何一个问题，都有许多可用的解决方案。对于像我这样的编码狂人来说，这再好不过了。</p>
<p>几个月之前，我在Ray Wenderlich的网站上发表了两篇关于ReactiveCocoa的文章(<a href="http://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1" target="_blank" rel="external">第一部分</a>、<a href="http://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2" target="_blank" rel="external">第二部分</a>)，以及一个<a href="http://www.raywenderlich.com/70598/reactivecocoa-tech-talk-video" target="_blank" rel="external">Tech Talk</a>视频。这些覆盖了ReactiveCocoa的基本用法，希望能让广大读者熟悉ReactiveCocoa。不过，我收到不少请求，希望能讨论一些使用ReactiveCocoa实现MVVM模式的高级话题。</p>
<p>正因此，我开始写这篇文章。不过，在我发布之前，我想先分享一个已纠缠我很久的问题…</p>
<p>如果将一个<code>UITableView</code>绑定到一个<code>ReactiveCocoa</code>的<code>ViewModel</code>中？</p>
<h2 id="视图模式"><a href="#视图模式" class="headerlink" title="视图模式"></a>视图模式</h2><p>我以一个简单的例子开头–一个允许我们搜索Twitter的<code>ViewModel</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// A view model which provides a mechanism for searching twitter</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CETwitterSearchViewModel</span> : <span class="title">NSObject</span></span></div><div class="line">	</div><div class="line"><span class="comment">/// The current search text</span></div><div class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *searchText;</div><div class="line">	</div><div class="line"><span class="comment">/// An array of CETweetViewModel instances which indicate</span></div><div class="line"><span class="comment">/// the current search results</span></div><div class="line"><span class="keyword">@property</span> <span class="built_in">NSArray</span> *searchResults;</div><div class="line">	</div><div class="line"><span class="comment">/// A command which when executed searches twitter using the current searchText</span></div><div class="line"><span class="keyword">@property</span> RACCommand *searchCommand;</div><div class="line">	</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这个<code>ViewModel</code>的实现重用了我在<code>ReactiveCocoa</code>指南第二部分所创建的信号，所以我不在此重复。如果想要看详细的代码，可以在github上查找。</p>
<p>将<code>ViewModel</code>绑定到一个带有<code>UITextField</code>和<code>UIButton</code>的UI是使用<code>ReactiveCocoa</code>最普通不过工作了</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bind the UITextField text updates to the view model</span></div><div class="line">RAC(<span class="keyword">self</span>.viewModel, searchText) = <span class="keyword">self</span>.searchTextField.rac_textSignal;</div><div class="line">	</div><div class="line"><span class="comment">// bind a button to the search command</span></div><div class="line"><span class="keyword">self</span>.searchButton.rac_command = <span class="keyword">self</span>.viewModel.searchCommand;</div><div class="line">	</div><div class="line"><span class="comment">// when the search executes hide the keyboard</span></div><div class="line">[<span class="keyword">self</span>.viewModel.searchCommand.executing subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">  [<span class="keyword">self</span>.searchTextField resignFirstResponder];</div><div class="line">&#125;];</div><div class="line">	</div><div class="line"><span class="comment">// show a network activity indicator when the search is being executed</span></div><div class="line">RAC([<span class="built_in">UIApplication</span> sharedApplication], networkActivityIndicatorVisible) =</div><div class="line">  <span class="keyword">self</span>.viewModel.searchCommand.executing;</div></pre></td></tr></table></figure>
<p>在上面的代码中，当点击go按钮时，我们处理了诸如隐藏键盘这样的操作，并将网络连接的<code>activity indicator</code>绑定到了<code>searchCommand.executing</code>信号。</p>
<p><img src="http://www.scottlogic.com/blog/ceberhardt/assets/mvvm/UIBinding.png" alt="image"></p>
<p>这样就将<code>ViewModel</code>三个属性中的两个绑定到了UI，到目前为止，一切都还不错！</p>
<p>最后一个属性是<code>searchResults</code>；这个属性是一个数组，包含了搜索结果。我们可以通过<code>RACObserve</code>来观察这个属性的修改，<code>RACObserve</code>创建了一个信号，该信号会在每次更新时发出一个next事件。但不幸的是，我们不能只给<code>UITableView</code>一个对象的数组，并告诉它去渲染自己。</p>
<p>如果我们在StackOverflow上搜索相关帖子，或者查看别人的<code>ReactiveCocoa</code>实例，可以看到传统的方式似乎是我们需要自己去实现<code>table view</code>的代理和数据源。换句话说，我们之前优雅的只需要几行绑定代码的视图类代码会由于需要实现<code>table view</code>的各种逻辑而显示异常丑陋。</p>
<p>不过，我们有更好的方法。</p>
<h2 id="一个Table-View绑定辅助类"><a href="#一个Table-View绑定辅助类" class="headerlink" title="一个Table View绑定辅助类"></a>一个Table View绑定辅助类</h2><p>在MVVM模式中，每一个View都由一个<code>ViewModel</code>支撑着。一个视图可能占据整个屏幕(此时我们将一个视图控制器绑定到一个<code>ViewModel</code>)，或者只占据屏幕的一部分。</p>
<p>我们的顶层<code>ViewModel</code>的<code>searchResults</code>属性包含了一个对象数组，其中每一个元素都是一个<code>ViewModel</code>。为了解决这个问题，我们需要的是一个通用的机制来为每个视图创建一个<code>ViewModel</code>，并将这两者绑定在一起。</p>
<p>Nib提供了一种便捷的机制来定义可重用的视图。可以方便地使用nib来定义一个table view的单元格。</p>
<p>一个合理的table view绑定辅助类的接口如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// A helper class for binding view models with NSArray properties</span></div><div class="line"><span class="comment">/// to a UITableView.</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CETableViewBindingHelper</span> : <span class="title">NSObject</span></span></div><div class="line">	</div><div class="line">- (<span class="keyword">instancetype</span>) initWithTableView:(<span class="built_in">UITableView</span> *)tableView</div><div class="line">                      sourceSignal:(RACSignal *)source</div><div class="line">                      templateCell:(<span class="built_in">UINib</span> *)templateCellNib;</div><div class="line">	</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这个绑定类使用提供的table view来渲染由源信号所提供的view model，另外templeteCell定义了视图。让我们来看看这个辅助类的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">＠interface CETableViewBindingHelper () &lt;<span class="built_in">UITableViewDataSource</span>&gt;</div><div class="line">	</div><div class="line">＠end</div><div class="line">	</div><div class="line">＠implementation CETableViewBindingHelper &#123;</div><div class="line">  <span class="built_in">UITableView</span> *_tableView;</div><div class="line">  <span class="built_in">NSArray</span> *_data;</div><div class="line">  <span class="built_in">UITableViewCell</span> *_templateCell;</div><div class="line">&#125;</div><div class="line">	</div><div class="line">- (<span class="keyword">instancetype</span>)initWithTableView:(<span class="built_in">UITableView</span> *)tableView</div><div class="line">                     sourceSignal:(RACSignal *)source</div><div class="line">                     templateCell:(<span class="built_in">UINib</span> *)templateCellNib &#123;</div><div class="line">  </div><div class="line">  <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</div><div class="line">    _tableView = tableView;</div><div class="line">    _data = [<span class="built_in">NSArray</span> array];</div><div class="line">    </div><div class="line">    <span class="comment">// each time the view model updates the array property, store the latest</span></div><div class="line">    <span class="comment">// value and reload the table view</span></div><div class="line">    [source subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">      _data = x;</div><div class="line">      [_tableView reloadData];</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    <span class="comment">// create an instance of the template cell and register</span></div><div class="line">    <span class="comment">// with the table view</span></div><div class="line">    _templateCell = [[templateCellNib instantiateWithOwner:<span class="literal">nil</span></div><div class="line">                                          options:<span class="literal">nil</span>] firstObject];</div><div class="line">    [_tableView registerNib:templateCellNib</div><div class="line">              forCellReuseIdentifier:_templateCell.reuseIdentifier];</div><div class="line">    </div><div class="line">    <span class="comment">// use the template cell to set the row height</span></div><div class="line">    _tableView.rowHeight = _templateCell.bounds.size.height;</div><div class="line">    </div><div class="line">    _tableView.dataSource = <span class="keyword">self</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="meta">#pragma mark - UITableViewDataSource implementation</span></div><div class="line">	</div><div class="line">- (<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tableView</div><div class="line">                       numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section &#123;</div><div class="line">  <span class="keyword">return</span> _data.count;</div><div class="line">&#125;</div><div class="line">	</div><div class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView</div><div class="line">                        cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</div><div class="line">  <span class="keyword">id</span>&lt;CEReactiveView&gt; cell = [tableView</div><div class="line">      dequeueReusableCellWithIdentifier:_templateCell.reuseIdentifier];</div><div class="line">  [cell bindViewModel:_data[indexPath.row]];</div><div class="line">  <span class="keyword">return</span> (<span class="built_in">UITableViewCell</span> *)cell;</div><div class="line">&#125;</div><div class="line">	</div><div class="line">＠end</div></pre></td></tr></table></figure>
<p>注意，初始化方法是内在逻辑所在。在这里，<code>sourceSignal</code>添加了一个<code>subscriber</code>，这样每次<code>ViewModel</code>的数组属性变化时，当前属性值的引用都会被保存，而table view也会重新加载。同样，也会创建<code>templeteCell</code>实例，来确定单元格的高度。</p>
<p>最后，这个类实现了table view的数据源方法，并通过信号来获取数据。</p>
<p>其中，单元格Cell必须实现以下协议，该协议提供了一个信号方法来将Cell绑定到相应的<code>ViewModel</code>上。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// A protocol which is adopted by views which are backed by view models.</span></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">CEReactiveView</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line">	</div><div class="line"><span class="comment">/// Binds the given view model to the view</span></div><div class="line">- (<span class="keyword">void</span>)bindViewModel:(<span class="keyword">id</span>)viewModel;</div><div class="line">	</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>将这个用于实际当中，现在只需要几行代码就可以将一个数组属性绑定到一个table view上了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// create a cell template</span></div><div class="line"><span class="built_in">UINib</span> *nib = [<span class="built_in">UINib</span> nibWithNibName:<span class="string">@"CETweetTableViewCell"</span> bundle:<span class="literal">nil</span>];</div><div class="line">	</div><div class="line"><span class="comment">// bind the view models 'searchResults' property to a table view</span></div><div class="line">[[CETableViewBindingHelper alloc]</div><div class="line">      initWithTableView:<span class="keyword">self</span>.searchResultsTable</div><div class="line">           sourceSignal:RACObserve(<span class="keyword">self</span>.viewModel, searchResults)</div><div class="line">           templateCell:nib];</div></pre></td></tr></table></figure>
<p>注意，源信号是通过<code>RACObserver</code>宏来创建的。这个信号在每次属性通过setter来改变都会发出一个next事件。</p>
<p>cell的实现类似于视图控制器；它们的UI控件定义在一个nib文件中并连接到相应的outlet属性。下图是该示例程序中定义cell的nib：</p>
<p><img src="http://www.scottlogic.com/blog/ceberhardt/assets/mvvm/CellNib.png" alt="image"></p>
<p>定义在<code>CEReactiveView</code>协议中的<code>ViewModel</code>绑定方法实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)bindViewModel:(<span class="keyword">id</span>)viewModel &#123;</div><div class="line">  </div><div class="line">  CETweetViewModel *tweet = (CETweetViewModel *)viewModel;</div><div class="line">  </div><div class="line">  <span class="comment">// set the tweet 'status' label, sizing it to fit the text</span></div><div class="line">  <span class="keyword">self</span>.titleTextField.frame =</div><div class="line">                 <span class="built_in">CGRectInset</span>(<span class="keyword">self</span>.titleBackgroundView.frame, <span class="number">5.0</span>f, <span class="number">5.0</span>f) ;</div><div class="line">  <span class="keyword">self</span>.titleTextField.text = tweet.status;</div><div class="line">  [<span class="keyword">self</span>.titleTextField sizeToFit];</div><div class="line">  </div><div class="line">  <span class="comment">// set the username</span></div><div class="line">  <span class="keyword">self</span>.usernameTextField.text = tweet.username;</div><div class="line">  </div><div class="line">  <span class="comment">// use signals to fetch the images for each image view</span></div><div class="line">  <span class="keyword">self</span>.profileImage.image = <span class="literal">nil</span>;</div><div class="line">  [[<span class="keyword">self</span> signalForImage:[<span class="built_in">NSURL</span> URLWithString:tweet.profileBannerUrl]]</div><div class="line">    subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">      <span class="keyword">self</span>.ghostImageView.image = x;</div><div class="line">    &#125;];</div><div class="line">  </div><div class="line">  <span class="keyword">self</span>.ghostImageView.image = <span class="literal">nil</span>;</div><div class="line">  [[<span class="keyword">self</span> signalForImage:[<span class="built_in">NSURL</span> URLWithString:tweet.profileImageUrl]]</div><div class="line">    subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">      <span class="keyword">self</span>.profileImage.image = x;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，由于<code>CETweetViewModel</code>的属性不会发生变化，因此它们的值直接被拷贝到相应的UI控件上。当然，如果它们的值会改变，我们也可以使用<code>ReactiveCocoa</code>来将两者绑定到一起。</p>
<p>cell的实现同样使用了<code>ReactiveCocoa</code>在后台加载图片：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// creates a signal that fetches an image in the background, delivering</span></div><div class="line"><span class="comment">// it on the UI thread. This signal 'cancels' itself if the cell is re-used before the</span></div><div class="line"><span class="comment">// image is downloaded.</span></div><div class="line">-(RACSignal *)signalForImage:(<span class="built_in">NSURL</span> *)imageUrl &#123;</div><div class="line">  </div><div class="line">  RACScheduler *scheduler = [RACScheduler </div><div class="line">                 schedulerWithPriority:RACSchedulerPriorityBackground];</div><div class="line">  </div><div class="line">  RACSignal *imageDownloadSignal = [[RACSignal</div><div class="line">    createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">      <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:imageUrl];</div><div class="line">      <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data];</div><div class="line">      [subscriber sendNext:image];</div><div class="line">      [subscriber sendCompleted];</div><div class="line">      <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;] subscribeOn:scheduler];</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> [[imageDownloadSignal</div><div class="line">          takeUntil:<span class="keyword">self</span>.rac_prepareForReuseSignal]</div><div class="line">          deliverOn:[RACScheduler mainThreadScheduler]]; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过这种方式，我们就可以让我们的视图控制器保持少量的代码。看，是不是很整洁。</p>
<p>下面是完整的程序的实现效果：</p>
<p><img src="http://www.scottlogic.com/blog/ceberhardt/assets/mvvm/CellBinding.png" alt="image"></p>
<h2 id="处理选中事件"><a href="#处理选中事件" class="headerlink" title="处理选中事件"></a>处理选中事件</h2><p>当前的绑定辅助类允许我们在一个table view中渲染<code>ViewModel</code>的数组，但如果我们需要处理选中事件呢？传统的方法是在视图控制器的手动处理，实现table view的代理方法，并执行相关的<code>ViewModel</code>的命令。</p>
<p>不过，这部分逻辑代码也可以放入到绑定辅助类中。</p>
<p>首先，我们在初始化方法中添加一个选择命令：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>) initWithTableView:(<span class="built_in">UITableView</span> *)tableView</div><div class="line">                      sourceSignal:(RACSignal *)source</div><div class="line">                  selectionCommand:(RACCommand *)selection                  </div><div class="line">                      templateCell:(<span class="built_in">UINib</span> *)templateCellNib;</div></pre></td></tr></table></figure>
<p>这个初始化方法的实现现在存储了这个命令的引用。辅助类同样也实现了table view的代理，即<code>tableView:didSelectRowAtIndexPath:</code>方法的实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView</div><div class="line">               didSelectRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</div><div class="line">  [_selection execute:_data[indexPath.row]];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即当命令被调用时，会将选择的<code>ViewModel</code>作为执行参数传入。</p>
<p>在顶层<code>ViewModel</code>中，我已经添加了一个命令，这个操作只是简单地记录一下日志：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// create the tweet selected command, that simply logs</span></div><div class="line"><span class="keyword">self</span>.tweetSelectedCommand = [[RACCommand alloc]</div><div class="line">        initWithSignalBlock:^RACSignal *(CETweetViewModel *selected) &#123;</div><div class="line">	 <span class="built_in">NSLog</span>(selected.status);</div><div class="line">	 <span class="keyword">return</span> [RACSignal empty];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>希望这个table view绑定辅助类能够帮助那些使用<code>MVVM</code>和<code>ReactiveCocoa</code>来开发iOS应用的开发者们。所有的代码都在github上。如果您有任何意见、想法或建议，请让我知道。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/09/18/random-mac-in-ios8/" itemprop="url">
                  iOS8中扫描Wi-Fi时MAC地址的随机化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-09-18T15:51:54+08:00" content="2014-09-18">
              2014-09-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/something/" itemprop="url" rel="index">
                    <span itemprop="name">杂项</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>继在iOS6和iOS7系统中面向开发者关闭IP地址和MAC地址的获取后，苹果在iOS8中又出新招：在扫描Wi-Fi时使用随机的、本地管理的MAC地址。基于苹果保护用户隐私的一贯政策，这一步是必然的，它会封死所以获取用户隐私信息的通道。这对于苹果用户来说，当然是件好事。而对于想通过MAC地址来获取用户信息的商家们或黑客们，可能就得另想办法了。我们在此粗略地总结一下iOS对MAC地址所做的随机化处理。</p>
<h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><p>在当今基于OSI模型的七层网络系统中，所有有网络接口的设备至少都有一个MAC地址(Media Access Control)。MAC地址位于OSI模型的第二层中，用于帮助网络交换机(有机或无线)确定哪个设备正在传输包及哪个设备应该接收这些包。根据设计，MAC地址应该是唯一的，它被写入到设备的物理网络芯片中，两个不同的设备MAC地址是不一样的。由于像智能手机设备中的无线以太网适配器在广播MAC地址时，采用的的类似于“嘿，这里有没有Wi-Fi”这种形式，所以，我们可以很容易地通过记录这个唯一识别来跟踪用户是否到过某个公共区域。</p>
<h2 id="随机MAC地址的技术实现"><a href="#随机MAC地址的技术实现" class="headerlink" title="随机MAC地址的技术实现"></a>随机MAC地址的技术实现</h2><p>在WWDC 2014上，Frederic Jacobs在对iOS8新特性的介绍中，提到了如下一条:</p>
<p><img src="http://cdn.arstechnica.net/wp-content/uploads/2014/06/Screen-Shot-2014-06-09-at-10.15.22-AM-1280x551.png" alt="image"></p>
<p>其大意是在iOS8系统中，Wi-Fi扫描过程中将使用随机的、本地管理的MAC地址，这个MAC地址并不总是设备的真实的MAC地址。</p>
<p>首先需要注意的是MAC地址的随机化。</p>
<p>如果是主动扫描，手机的无线设备会广播一个Probe请求，它包含一个随机的MAC地址。然后手机会等待周围的无线访问接入点(AP)返回Probe响应。一般来说会扫描所有的信道channel1-channel13(或者channel1, 5, 13)，每个信道扫描10ms左右。当然，手机也可以通过点对点的方式将请求(Directed Probe)发送给特定的AP。我们一般隐藏一个无线路由的SSID的方法，就是让这个无线路由不响应广播的Probe，不主动发Beacon，只响应Directed Probe。</p>
<p>而如果是被动扫描，则手机不会广播任何Probe请求，只是周期性地在不同的信道上监听AP发出的beacon包。</p>
<p>另外一个需要注意的是这个随机化是发生在扫描过程中的。而在手机与无线接入点进行关联的过程以及数据传输的过程中，使用MAC地址仍然是设备真实的MAC地址。通常只有在关联阶段才是让AP记录手机MAC地址的阶段，这时候记录的MAC地址，才是将来作为数据传输的MAC地址。</p>
<p>更详细的介绍，可以参看<a href="http://www.zhihu.com/people/qiang-meta" target="_blank" rel="external">@Qiang Meta</a>在知乎上对《<a href="http://www.zhihu.com/question/24094236?sort=created" target="_blank" rel="external">iOS 8 设备随机 MAC 地址躲避 Wi-Fi 热点的记录追踪，技术上是怎么实现，有何影响？</a>》的作答。</p>
<h2 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h2><p>如果我们是在家中或者在办公区域，我们通常会自己去主动关联无线接入点，那么等到下次再进入这一区域时，我们的手机等设备就会自动去连接无线网络。由于这些Wi-Fi是受我们信任的，所以无所谓。但是当我们到达一个陌生区域或公共区域时，我们的设备就会去搜索可用的无线接入点。这时候就涉及到隐私的问题了。</p>
<p>现在，已经有一些公司已经开发了可以记住所扫描到的MAC地址的Wi-Fi集线器。这种设备可以记住我们的MAC地址，无论我们有没有连接它。这些公司已经在许多地方部署了这些设备，以便他们能在用户不知道的情况下了解用户的一些基本行为。</p>
<p>正如WWDC上所指出的一样，“诸如Euclid或其同行Turnstyle Solutions这样的公司，它们会使用MAC地址这样的数据来记录用户进出商店的一些信息，如人们何时走进一个商店，他们在某个区域停留多久，他们来商店的频率是多少”。而MAC地址的随机化正是为了规避这个问题。</p>
<p>这对于广告商和营销商来说无疑是个不小的打击，如果iOS8设备使用不断变化的MAC地址来广播Wi-Fi Probe请求，则不可能通过MAC地址来跟踪进出商店或其它场所的移动设备。这对于保护用户的隐私来说，又是更进了一步。</p>
<h2 id="苹果的替代方案"><a href="#苹果的替代方案" class="headerlink" title="苹果的替代方案"></a>苹果的替代方案</h2><p>不过苹果也没有完全关闭追踪用户并向用户推送广告的通道，它推出了另外一种方案–即基于位置服务的iBeacon。iBeacon已经内置在最近的iOS设备中了。不同于使用设备的MAC地址，iBeacon使用低功耗蓝牙技术来发现那边带有支持iBeacon功能的App的设备，以向这些设备发送广告或通知。iBeacon不同于基于MAC地址跟踪技术(iBeacon发射器不会从设备中获取数据)，它只是在匹配到带有基于iBeacon的应用时，才可以察看设备位置。这样就无法推测出一个用户的习惯，从而保护了用户的隐私了。</p>
<p>当然，苹果在随机化MAC地址时，也综合考虑了用户隐私的泄露与商家基于地理位置来发送广告的需求之间的平衡。那些不愿意使用iBeacon的iOS用户可以通过关闭蓝牙来禁用iBeacon感知功能。在iOS8之前，用户只能通过禁用Wi-Fi来避免自己的设备被通过MAC地址的方式跟踪到。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>苹果这次对MAC地址的随机化处理，又一次展示了它对保护用户隐私的决定。相信以后类似的事情还会出现。而对于开发商或者开发者来说，在iOS设备上获取用户信息的渠道将会越来越少。我们改变不了苹果，或许也就只能另辟蹊径。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://www.zhihu.com/question/24094236" target="_blank" rel="external">iOS 8 设备随机 MAC 地址躲避 Wi-Fi 热点的记录追踪，技术上是怎么实现，有何影响？</a></li>
<li><a href="http://arstechnica.com/apple/2014/06/ios8-to-stymie-trackers-and-marketers-with-mac-address-randomization/" target="_blank" rel="external">iOS 8 to stymie trackers and marketers with MAC address randomization</a></li>
<li><a href="http://www.tuicool.com/articles/rUv6Br" target="_blank" rel="external">Why iOS 8′s MAC address randomizing is a huge win for privacy</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/09/15/thinking-in-terms-of-ios-8-size-classes/" itemprop="url">
                  Thinking In Terms Of iOS 8 Size Classes
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-09-15T17:25:53+08:00" content="2014-09-15">
              2014-09-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文链接：<a href="http://carpeaqua.com/2014/06/14/thinking-in-terms-of-ios-8-size-classes/" target="_blank" rel="external">Thinking In Terms Of iOS 8 Size Classes</a></p>
<p>对于最新的<code>iOS8 SDK</code>来说，最性感也最重要的的特性也许莫过于<code>Size Classes</code>了。</p>
<p>在聊<code>Size Classes</code>之前，我们先来回顾下历史。</p>
<h2 id="一堂历史课"><a href="#一堂历史课" class="headerlink" title="一堂历史课"></a>一堂历史课</h2><p>最初，<code>iOS</code>推出时，我们只有一种设备：<code>iPhone</code>。它的屏幕大小是<code>320\*480</code>。不过即使如此，它也是同时支付横屏和竖屏。设计同时支持两个方向的<code>App</code>不是像<code>Mobile Safari</code>或<code>Messages</code>那样，简单地拉伸和重新设置视图的大小。在大多数情况下，我们需要移动按钮和其它控件来让其适应横屏(<code>480\*320</code>)。</p>
<p>几年后的现在，我们有了高清屏，<code>iPads</code>和大屏的<code>iPhone</code>。当然，所有这些设备都是支持横屏和竖屏的。解决这个适配问题的传统的方法是在视图控制器和自定义视图中监听设备方向的变化，同时使用多个<code>xib</code>或<code>storyboard</code>。</p>
<p>假设我已经构建了一个同时支持<code>iPhone</code>和<code>iPad</code>的的<code>Glassboard</code>工程。在<code>iOS7</code>和老的版本之前，我们需要针对<code>iPad</code>单独创建一个<code>storyboard</code>，这个<code>storyboard</code>包含重建的视图控制器，<code>outlet</code>属性和<code>target/action</code>。这相当于是重复工作了。任何程序员都知道这不是个好主意。需要在两个不同的地方做相同的改变真是件糟糕的事。</p>
<p>如果是使用代码，则我们需要在代码中检测屏幕方向及设备大小，以便我们能手动调整我们的约束或基于<code>frame</code>的布局。我们的代码会像下面这段代码一样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIDevice</span> *device = [<span class="built_in">UIDevice</span> currentDevice];</div><div class="line"><span class="built_in">UIDeviceOrientation</span> currentOrientation = device.orientation;</div><div class="line"><span class="built_in">BOOL</span> isPhone = (device.userInterfaceIdiom == <span class="built_in">UIUserInterfaceIdiomPhone</span>);</div><div class="line"><span class="built_in">BOOL</span> isTallPhone = ([[<span class="built_in">UIScreen</span> mainScreen] bounds].size.height == <span class="number">568.0</span>);</div><div class="line"><span class="keyword">if</span> (<span class="built_in">UIDeviceOrientationIsPortrait</span>(currentOrientation) == <span class="literal">YES</span>)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// Do Portrait Things</span></div><div class="line">    <span class="keyword">if</span> (isPhone == <span class="literal">YES</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// Do Portrait Phone Things</span></div><div class="line">        <span class="comment">// Don't deny you've done this at least once.</span></div><div class="line">        <span class="keyword">if</span> (isTallPhone)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">// iPhone 5+</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="comment">// Old phones</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">// Do Portrait iPad things.</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Do Landscape Things.</span></div><div class="line">    <span class="keyword">if</span> (isPhone == <span class="literal">YES</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// Do Landscape Phone Things</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">// Do Landscape iPad things.</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Size-Classes"><a href="#Size-Classes" class="headerlink" title="Size Classes"></a>Size Classes</h2><p>显然，上面的这些方案都不理想，而且随着苹果新设备的推出，这种情况会变得越来越糟。在今年的<code>WWDC</code>上，苹果除了介绍自动布局的新特性外，我们同样也看到了许多可变<code>iOS</code>模拟器的事例，以及一种处理所有这些问题和屏幕问题的新技术：<code>Size Classes</code>。</p>
<p><code>Size Classes</code>是<code>iOS</code>使用的一种新的技术，允许我们为给定的设备自定义我们的程序，而且是基于设备的方向和屏幕大小的。</p>
<p><code>Size Classes</code>有两个目的：</p>
<ol>
<li>让开发人员和设计人员跳出指定设备的范畴，而是以更广义的范畴来思考问题</li>
<li>为未来做准备</li>
</ol>
<p>第一个目的也引出了第二个目的。我们看到各种传说，说<code>iPhone 6, 7</code>将会是更大的设备。你也看到了苹果已经开发出了可穿戴设备(<code>Apple Watch</code>)。那么有什么方法可以让为这些设备开发变得更容易呢？那就是<code>Size Classes</code>。</p>
<p>目前从<code>XCode 6</code>上可以看到有四种类型的<code>Size Classes</code>：</p>
<p><img src="http://cdn.carpeaqua.com.s3.amazonaws.com/images/size-classes/size_class_chart.jpg" alt="image"></p>
<ol>
<li>宽紧凑(<code>Compact</code>)</li>
<li>长紧凑</li>
<li>宽正常(<code>Regular</code>)</li>
<li>长正常</li>
</ol>
<p>任意时刻，我们的设备都有一个水平方向的<code>Size Class</code>和一个竖直方向的<code>Size Class</code>。这两者都是用来定义布局属性与物征(<code>trait</code>)的集合，以在屏幕上显示内容给用户。</p>
<h2 id="特征-Traits"><a href="#特征-Traits" class="headerlink" title="特征(Traits)"></a>特征(Traits)</h2><p>水平和竖直的Size Class被认为是Traits。结合当前界面术语和显示比例，一起组成了一个特征集合。这不只是包含了指定的控制应该放在屏幕的什么地方。</p>
<p>特征(<code>Trait</code>)也可以用于诸如<code>image assets</code>的东西上(假设你正在使用<code>Asset Catalogs</code>)。在<code>asset</code>中，我们不仅可以包含<code>1x</code>和<code>2x</code>版本，我们还可以为不同的<code>size class</code>指定不同的<code>image asset</code>。在代码中，它看着仍然是相同的<code>UIImage</code>调用。<code>Asset Catalogs</code>负责基于当前的特征集合来渲染合适的图片。</p>
<h2 id="为Size-Classes设计"><a href="#为Size-Classes设计" class="headerlink" title="为Size Classes设计"></a>为Size Classes设计</h2><p><code>Size Classes</code>对于开发人员来讲是一个很好的扩展，因为当我们需要支持多种设备和方向时，它能简化我们的开发。通过简化我们的工作，苹果可以更容易地开发新的设备，并可以让开发者开发能用的应用，而不仅仅是只为<code>iPhone</code>开发程序。</p>
<p>对于开发者来说，最大的改变是我们需要再一次修改我们的关于不同方向的代码。大家已经习惯了吧，谁让我们是开发者呢。</p>
<p>对于设计者来说，特征集合意味着可以少考虑是为哪种设备来做设计，而可以更多的考虑设备的属性。现在，设计者最需要考虑的因素是物理屏幕大小。</p>
<p>由于不能确保每台设备的屏幕尺寸都与<code>Photoshop</code>或测试样机保持一致，所以单独为特定的场景做设计已经站不住脚了。相反，我们的目标是应该为一类设备做通用的设计，主要包括：</p>
<ol>
<li>手机上的肖像模式</li>
<li>平板上的肖像模式</li>
<li>手机上的景观模式</li>
<li>平板上的景观模式</li>
</ol>
<p>现在<code>iPhone 6</code>来了，它的屏幕也变大了，它拥有与<code>iPhone 4s</code>和<code>5</code>一样的特征集合。当然，<code>iPhone 6</code>的尺寸比原来的手机更大了，但是UI应该基于为指定特征集合定义的界面，来做自适应的处理。</p>
<p>这可能意味着设计者需要推翻自己以前的一些设计，但这就是事实。就像软件开发一样，软件设计需要符合这些约束。新的约束就是我们不能再活在只为特定屏幕尺寸做设计的世界里面了。我们不是要像<code>Android</code>一样，但这是苹果希望我们前进的方向。</p>
<h2 id="采用Size-Classes"><a href="#采用Size-Classes" class="headerlink" title="采用Size Classes"></a>采用Size Classes</h2><p>好消息是，<code>Interface Builder</code>可以让我们更好的使用<code>Size Classes</code>。更好的消息是，这些<code>Interface Builder</code>变化是向后兼容的，所以我们可以在合适的地方简化和合并<code>Storyboards</code>和<code>Xibs</code>，而不会落下任何用户。</p>
<p>不太好的消息是，如果需要在代码中使用特征集合，则只支持<code>iOS 8</code>。这是因为苹果很少为老的系统提供新的<code>API</code>接口。这就意味着我们需要在代码中添加一些新的分支来支持不同的系统。例如，为自定义的<code>UIView</code>调整<code>intrinsicContentSize</code>属性。如果系统是<code>iOS8</code>，我们可以使用竖直和水平的<code>size class</code>来确定这个值，但如果设备仍然是<code>iOS 7</code>或老版本，则已存在的代码仍然需要保留。</p>
<p>因为我使用并推荐<code>Interface Builder</code>，所以比起那些仍然活在“将一切写在代码”口号中的人们来说，我的工作明显地减少了。如果你仍然在那个阵营里面，我强烈建议你使用<code>iOS 8</code>, <code>XCode 6</code>和特征集合，并以此为契机加入到<code>Interface Builder</code>阵营中来。这样不仅能减少我们的代码量，同样可以通过提取大量的特征处理到一个视觉<code>UI</code>库来简化代码。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/08/12/mvvm-tutorial-with-reactivecocoa-2/" itemprop="url">
                  MVVM Tutorial with ReactiveCocoa: Part 2/2
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-08-12T21:12:20+08:00" content="2014-08-12">
              2014-08-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文由<code>Colin Eberhardt</code>发表于<code>raywenderlich</code>，原文可查看<a href="http://www.raywenderlich.com/74131/mvvm-tutorial-with-reactivecocoa-part-2" target="_blank" rel="external">MVVM Tutorial with ReactiveCocoa: Part 2/2</a></p>
<p>在第一部分中，我们介绍了<code>MVVM</code>，可以看到<code>ReactiveCocoa</code>如何将<code>ViewModel</code>绑定到各自对应的<code>View</code>上。</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/06/MVVMReactiveCocoa-700x121.png" alt="image"></p>
<p>下图是我们程序实现的<code>Flickr</code>搜索功能</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/06/FinishedApp-671x500.png" alt="image"></p>
<p>在这一部分中，我们来看看如何在程序的<code>ViewModel</code>中驱动视图间的导航操作。</p>
<p>目前我们的程序允许使用简单的搜索字符串来搜索<code>Flickr</code>。我们可以在<a href="http://cdn4.raywenderlich.com/wp-content/uploads/2014/06/FlickrSearchPart1Project1.zip" target="_blank" rel="external">这里</a>下载程序。<code>Model</code>层使用<code>ReactiveCocoa</code>来提供搜索结果，<code>ViewModel</code>只是简单地记录响应。</p>
<p>现在，我们来看看如何在结果页中进行导航。</p>
<h2 id="实现ViewModel导航"><a href="#实现ViewModel导航" class="headerlink" title="实现ViewModel导航"></a>实现ViewModel导航</h2><p>当一个<code>Flickr</code>成功返回需要的结果时，程序导航到一个新的视图控制器来显示搜索结果。当前的程序只有一个<code>ViewModel</code>，即<code>RWTFlickrSearchViewModel</code>类。为了实现需要的功能，我们将添加一个新的<code>ViewModel</code>来返回到搜索结果视图。添加新的继承自<code>NSObject</code>的<code>RWTSearchResultsViewModel</code>类到<code>ViewModel</code>分组中，并更新其头文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@import</span> Foundation;</div><div class="line"><span class="meta">#import <span class="meta-string">"RWTViewModelServices.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"RWTFlickrSearchResults.h"</span></span></div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWTSearchResultsViewModel</span> : <span class="title">NSObject</span></span></div><div class="line"> </div><div class="line">- (<span class="keyword">instancetype</span>)initWithSearchResults:(RWTFlickrSearchResults *)results services:(<span class="keyword">id</span>&lt;RWTViewModelServices&gt;)services;</div><div class="line"> </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *title;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSArray</span> *searchResults;</div><div class="line"> </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>上述代码添加了描述视图的两个属性，及一个初始化方法。打开<code>RWTSearchResultsViewModel.m</code>并实现初始化方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithSearchResults:(RWTFlickrSearchResults *)results services:(<span class="keyword">id</span>&lt;RWTViewModelServices&gt;)services &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</div><div class="line">    _title = results.searchString;</div><div class="line">    _searchResults = results.photos;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>回想一下第一部分，<code>ViewModel</code>在<code>View</code>驱动程序之前就已经生成了。下一步就是将<code>View</code>连接到对应的<code>ViewModel</code>上。</p>
<p>打开<code>RWTSearchResultsViewController.h</code>，导入<code>ViewModel</code>，并添加以下初始化方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"RWTSearchResultsViewModel.h"</span></span></div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWTSearchResultsViewController</span> : <span class="title">UIViewController</span></span></div><div class="line"> </div><div class="line">- (<span class="keyword">instancetype</span>)initWithViewModel:(RWTSearchResultsViewModel *)viewModel;</div><div class="line"> </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>打开<code>RWTSearchResultsViewController.m</code>，在类的扩展中添加以下私有属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) RWTSearchResultsViewModel *viewModel;</div></pre></td></tr></table></figure>
<p>在同一个文件下面，实现初始化方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithViewModel:(RWTSearchResultsViewModel *)viewModel &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</div><div class="line">    _viewModel = viewModel;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这一步中，我们将重点关注导航如何工作，回到视图控制器中将<code>ViewModel</code>绑定到<code>UI</code>中。</p>
<p>现在程序有两个<code>ViewModel</code>，但是现在将面临一个难题。如何从一个<code>ViewModel</code>导航到另一个<code>ViewModel</code>中，也就是在对应的视图控制器中导航。<code>ViewModel</code>不能直接引用视图，所示我们应该怎么做呢？</p>
<p>答案已经在<code>RWTViewModelServices</code>协议中给出来了。它获取了一个<code>Model</code>层的引用，我们将使用这个协议来允许<code>ViewModel</code>来初始化导航。打开<code>RWTViewModelServices.h</code>并添加以下方法来协议中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)pushViewModel:(<span class="keyword">id</span>)viewModel;</div></pre></td></tr></table></figure>
<p>理论上讲，是<code>ViewModel</code>层驱动程序，这一层中的逻辑决定了在<code>View</code>中显示什么，及何时进行导航。这个方法允许<code>ViewModel</code>层<code>push</code>一个<code>ViewModel</code>，该方式与<code>UINavigationController</code>方式类似。在更新协议实现前，我们将在<code>ViewModel</code>层先让这个机制工作。</p>
<p>打开<code>RWTFlickrSearchViewModel.m</code>并导入以下头文件</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"RWTSearchResultsViewModel.h"</span></span></div></pre></td></tr></table></figure>
<p>同时在同一文件中更新<code>executeSearchSignal</code>的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (RACSignal *)executeSearchSignal &#123;</div><div class="line">  <span class="keyword">return</span> [[[<span class="keyword">self</span>.services getFlickrSearchService]</div><div class="line">    flickrSearchSignal:<span class="keyword">self</span>.searchText]</div><div class="line">    doNext:^(<span class="keyword">id</span> result) &#123;</div><div class="line">      RWTSearchResultsViewModel *resultsViewModel =</div><div class="line">        [[RWTSearchResultsViewModel alloc] initWithSearchResults:result services:<span class="keyword">self</span>.services];</div><div class="line">      [<span class="keyword">self</span>.services pushViewModel:resultsViewModel];</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码添加一个<code>addNext</code>操作到搜索命令执行时创建的信号。<code>doNext</code>块创建一个新的<code>ViewModel</code>来显示搜索结果，然后通过<code>ViewModel</code>服务将它<code>push</code>进来。现在是时候更新协议的实现代码了。为了满足这个需求，代码需要一个导航控制器的引用。</p>
<p>打开<code>RWTViewModelServicesImpl.h</code>并添加以下的初始化方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithNavigationController:(<span class="built_in">UINavigationController</span> *)navigationController;</div></pre></td></tr></table></figure>
<p>打开<code>RWTViewModelServicesImpl.m</code>并导入以下头文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"RWTSearchResultsViewController.h"</span></span></div></pre></td></tr></table></figure>
<p>然后添加一个私有属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UINavigationController</span> *navigationController;</div></pre></td></tr></table></figure>
<p>接下来实现初始化方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithNavigationController:(<span class="built_in">UINavigationController</span> *)navigationController &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</div><div class="line">    _searchService = [RWTFlickrSearchImpl new];</div><div class="line">    _navigationController = navigationController;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这简单地更新了初始化方法来存储传入的导航控制器的引用。最后，添加以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)pushViewModel:(<span class="keyword">id</span>)viewModel &#123;</div><div class="line">  <span class="keyword">id</span> viewController;</div><div class="line"> </div><div class="line">  <span class="keyword">if</span> ([viewModel isKindOfClass:RWTSearchResultsViewModel.class]) &#123;</div><div class="line">    viewController = [[RWTSearchResultsViewController alloc] initWithViewModel:viewModel];</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"an unknown ViewModel was pushed!"</span>);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  [<span class="keyword">self</span>.navigationController pushViewController:viewController animated:<span class="literal">YES</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的方法使用提供的<code>ViewModel</code>的类型来确定需要哪个视图。在上面的例子中，只有一个<code>ViewModel-View</code>对，不过我确信你可以看到如何扩展这个模式。导航控制器<code>push</code>了结果视图。</p>
<p>最后，打开<code>RWTAppDelegate.m</code>，定位到<code>createInitialViewController</code>方法的<code>RWTViewModelServicesImpl</code>实例创建的地方，用下面的代码替换创建操作：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.viewModelServices = [[RWTViewModelServicesImpl alloc] initWithNavigationController:<span class="keyword">self</span>.navigationController];</div></pre></td></tr></table></figure>
<p>运行后，点击”<code>GO</code>“可以看到程序切换到新的<code>ViewModel/View</code>:</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/06/BlankView-281x500.png" alt="image"></p>
<p>现在还是空的。别急，我们一步一步来。不过我们的程序现在有多个<code>ViewModel</code>，其中导航控制器通过<code>ViewModel</code>层来进行控制。我们先回来<code>UI</code>绑定上来。</p>
<h2 id="渲染结果页"><a href="#渲染结果页" class="headerlink" title="渲染结果页"></a>渲染结果页</h2><p>搜索结果的视图对应的<code>nib</code>文件中有一个<code>UITableView</code>。接下来，我们需要在这个<code>table</code>中渲染<code>ViewModel</code>的内容。打开<code>RWTSearchResultsViewController.m</code>并定位到类扩展。更新它以实现<code>UITableViewDataSource</code>协议：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWTSearchResultsViewController</span> () &lt;<span class="title">UITableViewDataSource</span>&gt;</span></div></pre></td></tr></table></figure>
<p>重写<code>viewDidLoad</code>的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">  [<span class="keyword">super</span> viewDidLoad];</div><div class="line"> </div><div class="line">  [<span class="keyword">self</span>.searchResultsTable registerClass:<span class="built_in">UITableViewCell</span>.class</div><div class="line">                  forCellReuseIdentifier:<span class="string">@"cell"</span>];</div><div class="line">  <span class="keyword">self</span>.searchResultsTable.dataSource = <span class="keyword">self</span>;</div><div class="line"> </div><div class="line">  [<span class="keyword">self</span> bindViewModel];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码执行<code>table view</code>的初始化并将其绑定到<code>view model</code>。先忘记硬编码的<code>cell</code>标识常量，我们会在后面将其移除。</p>
<p>继续在下面添加<code>bindViewModel</code>代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)bindViewModel &#123;</div><div class="line">  <span class="keyword">self</span>.title = <span class="keyword">self</span>.viewModel.title;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ViewModel</code>有两个属性：上述代码处理的的标题，及渲染到<code>table</code>中的<code>searchResults</code>数组。那么我们该怎么样将数组绑定到<code>table view</code>呢？实际上，我们做不了。<code>ReactiveCocoa</code>可以绑定一些简单的UI控件，但是不能处理这种针对<code>table view</code>的复杂交互。但不需要担心，还有其它方法。卷起袖子开始做吧。</p>
<p>在同一文件中，添加以下两个数据源方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tableView</div><div class="line"> numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">self</span>.viewModel.searchResults.count;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView</div><div class="line">         cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</div><div class="line">  <span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:<span class="string">@"cell"</span>];</div><div class="line">  cell.textLabel.text = [<span class="keyword">self</span>.viewModel.searchResults[indexPath.row] title];</div><div class="line">  <span class="keyword">return</span> cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个就不用说了吧。运行后，效果如下：</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/06/PopulatedTable-281x500.png" alt="image"></p>
<h2 id="更好的TableView绑定方法"><a href="#更好的TableView绑定方法" class="headerlink" title="更好的TableView绑定方法"></a>更好的TableView绑定方法</h2><p><code>table view</code>绑定的缺失会很快导致视图控制器代码的增加。而手动绑定看上去又不太优雅。从概念上讲，在<code>ViewModel</code>的<code>searchResults</code>数组中的每一项是一个<code>ViewMode</code>，每个<code>cell</code>是对应一个<code>ViewModel</code>实例。在<a href="http://www.scottlogic.com/blog/2014/05/11/reactivecocoa-tableview-binding.html" target="_blank" rel="external">这篇博客</a>中我创建了一个绑定帮助类<code>CETableViewBindingHelper</code>，允许我们定义用于子<code>ViewModel</code>的<code>View</code>，帮助类负责实现数据源协议。我们可以在当前工程的<code>Util</code>分组中找到这个帮助类。</p>
<p><code>CETableViewBindingHelper</code>的构造方法如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">instancetype</span>) bindingHelperForTableView:(<span class="built_in">UITableView</span> *)tableView</div><div class="line">                              sourceSignal:(RACSignal *)source</div><div class="line">                          selectionCommand:(RACCommand *)selection</div><div class="line">                              templateCell:(<span class="built_in">UINib</span> *)templateCellNib;</div></pre></td></tr></table></figure>
<p>为了将数组绑定到视图中，我们简单创建一个帮助类的实例。它的参数是：</p>
<ol>
<li>渲染<code>ViewModel</code>数组的<code>table view</code></li>
<li>处理数组变化的信号</li>
<li>可选的当某行被选中时的命令</li>
<li><code>cell</code>视图的<code>nib</code>文件</li>
</ol>
<p><code>nib</code>文件定义的<code>cell</code>必须实现<code>CEReactiveView</code>协议。工程已经包含了一个<code>table view cell</code>，我们可以用它来渲染搜索结果。打开<code>RWTSearchResultsTableViewCell.h</code>并导入协议：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"CEReactiveView.h"</span></span></div></pre></td></tr></table></figure>
<p>采用协议：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWTSearchResultsTableViewCell</span> : <span class="title">UITableViewCell</span> &lt;<span class="title">CEReactiveView</span>&gt;</span></div></pre></td></tr></table></figure>
<p>下一步是实现协议。打开<code>RWTSearchResultsTableViewCell.m</code>并添加头文件</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;SDWebImage/UIImageView+WebCache.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"RWTFlickrPhoto.h"</span></span></div></pre></td></tr></table></figure>
<p>添加以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)bindViewModel:(<span class="keyword">id</span>)viewModel &#123;</div><div class="line">  RWTFlickrPhoto *photo = viewModel;</div><div class="line">  <span class="keyword">self</span>.titleLabel.text = photo.title;</div><div class="line"> </div><div class="line">  <span class="keyword">self</span>.imageThumbnailView.contentMode = <span class="built_in">UIViewContentModeScaleToFill</span>;</div><div class="line"> </div><div class="line">  [<span class="keyword">self</span>.imageThumbnailView setImageWithURL:photo.url];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>RWTSearchResultsViewModel</code>的<code>searchResults</code>属性包含<code>RWTFlickrPhoto</code>实例的数组。它们被直接绑定到<code>View</code>，而不是在<code>ViewModel</code>中包装这些<code>Model</code>对象。</p>
<p><code>bindViewModel</code>方法使用了<code>SDWebImage</code>第三方库，它在后台线程下载并解码图片数据，大大提高了<code>scroll</code>的性能。</p>
<p>最后一步是使用绑定帮助类来渲染<code>table</code>。</p>
<p>打开<code>RWTSearchResultsViewController.m</code>并导入头文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"CETableViewBindingHelper.h"</span></span></div></pre></td></tr></table></figure>
<p>在该文件下面的代码中移除对<code>UITableDataSource</code>协议的实现，同时移除实现的方法。接下来，添加以下私有属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) CETableViewBindingHelper *bindingHelper;</div></pre></td></tr></table></figure>
<p>在<code>viewDidLoad</code>方法中移除<code>table view</code>的配置代码，回归来方法的最初形式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">  [<span class="keyword">super</span> viewDidLoad]; </div><div class="line">  [<span class="keyword">self</span> bindViewModel];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们在<code>[self bindViewModel]</code>后面添加以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UINib</span> *nib = [<span class="built_in">UINib</span> nibWithNibName:<span class="string">@"RWTSearchResultsTableViewCell"</span> bundle:<span class="literal">nil</span>];</div><div class="line"> </div><div class="line"><span class="keyword">self</span>.bindingHelper =</div><div class="line">  [CETableViewBindingHelper bindingHelperForTableView:<span class="keyword">self</span>.searchResultsTable</div><div class="line">                                         sourceSignal:RACObserve(<span class="keyword">self</span>.viewModel, searchResults)</div><div class="line">                                     selectionCommand:<span class="literal">nil</span></div><div class="line">                                         templateCell:nib];</div></pre></td></tr></table></figure>
<p>这从<code>nib</code>文件中创建了一个<code>UINib</code>实例并构建了一个绑定帮助类实例，<code>sourceSignal</code>是通过观察<code>ViewModel</code>的<code>searchResults</code>属性改变而创建的。</p>
<p>运行后，得到新的<code>UI</code>：</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/06/UsingTheBindingHelper-281x500.png" alt="image"></p>
<h2 id="一些UI特效"><a href="#一些UI特效" class="headerlink" title="一些UI特效"></a>一些UI特效</h2><p>到目前为止，本指南主要关注于根据MVVM模式来构建程序。接下来，我们做点别的吧：添加特效。</p>
<p><code>iOS7</code>已经发布一年多了，“运动设计(<code>motion design</code>)”获取了更多的青睐，很多设计者现在都喜欢用这种微妙的对话和流体行为。</p>
<p>在这一步中，我们将添加一个图片滑动的特效，很不错的。</p>
<p>打开<code>RWTSearchResultsTableViewCell.h</code>并添加以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>) setParallax:(<span class="built_in">CGFloat</span>)value;</div></pre></td></tr></table></figure>
<p><code>table view</code>将使用这个方法来为每个<code>cell</code>提供视差补偿。</p>
<p>打开<code>RWTSearchResultsTableViewCell.m</code>并实现这个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setParallax:(<span class="built_in">CGFloat</span>)value &#123;</div><div class="line">  <span class="keyword">self</span>.imageThumbnailView.transform = <span class="built_in">CGAffineTransformMakeTranslation</span>(<span class="number">0</span>, value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很不错，这只是个简单的变换。</p>
<p>打开<code>RWTSearchResultsViewController.m</code>并导入以下头文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"RWTSearchResultsTableViewCell.h"</span></span></div></pre></td></tr></table></figure>
<p>然后在类扩展中采用<code>UITableViewDelegate</code>协议：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWTSearchResultsViewController</span> () &lt;<span class="title">UITableViewDataSource</span>, <span class="title">UITableViewDelegate</span>&gt;</span></div></pre></td></tr></table></figure>
<p>我们只是添加一个绑定辅助类来将将它自己设置为<code>table view</code>的代理，以便其可以响应行的选择。然而，它也转发代理方法调用到它所有的代理属性，这样我们仍然可以添加自定义行为。</p>
<p>在<code>bindViewModel</code>方法中，设置绑定辅助类代理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.bindingHelper.delegate = <span class="keyword">self</span>;</div></pre></td></tr></table></figure>
<p>在同一文件下面，添加<code>scrollViewDidScroll</code>的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView &#123;</div><div class="line">  <span class="built_in">NSArray</span> *cells = [<span class="keyword">self</span>.searchResultsTable visibleCells];</div><div class="line">  <span class="keyword">for</span> (RWTSearchResultsTableViewCell *cell <span class="keyword">in</span> cells) &#123;</div><div class="line">    <span class="built_in">CGFloat</span> value = <span class="number">-40</span> + (cell.frame.origin.y - <span class="keyword">self</span>.searchResultsTable.contentOffset.y) / <span class="number">5</span>;</div><div class="line">    [cell setParallax:value];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>table view</code>每次滚动时，调用这个方法。它迭代所有的可见<code>cell</code>，计算用于视差效果的偏移值。这个偏移值依赖于<code>cell</code>在<code>table view</code>中可见部分的位置。</p>
<p>运行后，可得到以下效果</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/06/ParallaxAnimation.gif" alt="image"></p>
<p>现在我们回到业务的<code>View</code>和<code>ViewModel</code>。</p>
<h2 id="查询评论及收藏计数"><a href="#查询评论及收藏计数" class="headerlink" title="查询评论及收藏计数"></a>查询评论及收藏计数</h2><p>我们应该在列表界面中每幅图片的右下方显示评论的数量和收藏的数量。当前我们只在<code>nib</code>文件中显示一个假数据’<code>123</code>‘。我们在使用真值来替换这些值前，需要在<code>Model</code>层添加这些功能。添加表示查询<code>Flickr</code> <code>API</code>结果的<code>Model</code>对象的步骤跟前面一样。</p>
<p>在<code>Model</code>分组中添加<code>RWTFlickrPhotoMetadata</code>类，打开<code>RWTFlickrPhotoMetadata.h</code>并添加以下属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> favorites;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> comments;</div></pre></td></tr></table></figure>
<p>打开<code>RWTFlickrPhotoMetadata.m</code>并添加<code>description</code>的实现</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span> *)description &#123;</div><div class="line">  <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"metadata: comments=%lU, faves=%lU"</span>,</div><div class="line">          <span class="keyword">self</span>.comments, <span class="keyword">self</span>.favorites];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来打开<code>RWTFlickrSearch.h</code>并添加以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (RACSignal *)flickrImageMetadata:(<span class="built_in">NSString</span> *)photoId;</div></pre></td></tr></table></figure>
<p><code>ViewModel</code>将使用这个方法来请求给定图片的元数据，如评论和收藏。</p>
<p>接下来打开<code>RWTFlickrSearchImpl.m</code>并添加以下头文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"RWTFlickrPhotoMetadata.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;ReactiveCocoa/RACEXTScope.h&gt;</span></span></div></pre></td></tr></table></figure>
<p>接下来实现<code>flickrImageMetadata</code>方法。不幸的是，这里有些小问题：为了获取图片相关的评论数，我们需要调用<code>flickr.photos.getinfo</code>方法；为了获取收藏数，需要调用<code>flickr.photos.getFavorites</code>方法。这让事件变得有点复杂，因为<code>flickrImageMetadata</code>方法需要调用两个接口请求以获取需要的数据。不过，<code>ReactiveCocoa</code>已经为我们解决了这个问题。</p>
<p>添加以下实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (RACSignal *)flickrImageMetadata:(<span class="built_in">NSString</span> *)photoId &#123;</div><div class="line"> </div><div class="line">  RACSignal *favorites = [<span class="keyword">self</span> signalFromAPIMethod:<span class="string">@"flickr.photos.getFavorites"</span></div><div class="line">                                          arguments:@&#123;<span class="string">@"photo_id"</span>: photoId&#125;</div><div class="line">                                          transform:^<span class="keyword">id</span>(<span class="built_in">NSDictionary</span> *response) &#123;</div><div class="line">                                            <span class="built_in">NSString</span> *total = [response valueForKeyPath:<span class="string">@"photo.total"</span>];</div><div class="line">                                            <span class="keyword">return</span> total;</div><div class="line">                                          &#125;];</div><div class="line"> </div><div class="line">  RACSignal *comments = [<span class="keyword">self</span> signalFromAPIMethod:<span class="string">@"flickr.photos.getInfo"</span></div><div class="line">                                        arguments:@&#123;<span class="string">@"photo_id"</span>: photoId&#125;</div><div class="line">                                        transform:^<span class="keyword">id</span>(<span class="built_in">NSDictionary</span> *response) &#123;</div><div class="line">                                          <span class="built_in">NSString</span> *total = [response valueForKeyPath:<span class="string">@"photo.comments._text"</span>];</div><div class="line">                                          <span class="keyword">return</span> total;</div><div class="line">                                        &#125;];</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> [RACSignal combineLatest:@[favorites, comments] reduce:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *favs, <span class="built_in">NSString</span> *coms)&#123;</div><div class="line">    RWTFlickrPhotoMetadata *meta = [RWTFlickrPhotoMetadata new];</div><div class="line">    meta.comments = [coms integerValue];</div><div class="line">    meta.favorites = [favs integerValue];</div><div class="line">    <span class="keyword">return</span>  meta;</div><div class="line">  &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码使用<code>signalFromAPIMethod:arguments:transform:</code>来从底层的基于<code>ObjectiveFLickr</code>的接口创建信号。上面的代码创建了一个信号对，一个用于获取收藏的数量，一个用于获取评论的数量。</p>
<p>一旦创建了两个信号，<code>combineLatest:reduce:</code>方法生成一个新的信号来组合两者。</p>
<p>这个方法等待源信号的一个<code>next</code>事件。<code>reduce</code>块使用它们的内容来调用，其结果变成联合信号的<code>next</code>事件。</p>
<p>简单明了吧！</p>
<p>不过在庆祝前，我们回到<code>signalFromAPIMethod:arguments:transform:</code>方法来修复之前提到的一个错误。你注意到了么？这个方法为每个请求创建一个新的<code>OFFlickrAPIRequest</code>实例。然后，每个请求的结果是通过代理对象来返回的，而这种情况下，其代理是它自己。结果是，在并发请求的情况下，没有办法指明哪个<code>flickrAPIRequest:didCompleteWithResponse:</code>调用用来响应哪个请求。不过，<code>ObjectiveFlickr</code>代理方法签名在第一个参数中包含了相应请求，所以这个问题很好解决。</p>
<p>在<code>signalFromAPIMethod:arguments:transform:</code>中，使用下面的代码来替换处理<code>successSignal</code>的管道：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@weakify(flickrRequest)</div><div class="line">[[[[successSignal</div><div class="line">  filter:^<span class="built_in">BOOL</span>(RACTuple *tuple) &#123;</div><div class="line">    @strongify(flickrRequest)</div><div class="line">    <span class="keyword">return</span> tuple.first == flickrRequest;</div><div class="line">  &#125;]</div><div class="line">  map:^<span class="keyword">id</span>(RACTuple *tuple) &#123;</div><div class="line">    <span class="keyword">return</span> tuple.second;</div><div class="line">  &#125;]</div><div class="line">  map:block]</div><div class="line">  subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    [subscriber sendNext:x];</div><div class="line">    [subscriber sendCompleted];</div><div class="line">  &#125;];</div></pre></td></tr></table></figure>
<p>这只是简单地添加一个<code>filter</code>操作来移除任何与请求相关的代理方法调用，而不是生成当前的信号。</p>
<p>最后一步是在<code>ViewModel</code>层中使用信号。</p>
<p>打开<code>RWTSearchResultsViewModel.m</code>并导入以下头文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"RWTFlickrPhoto.h"</span></span></div></pre></td></tr></table></figure>
<p>在同一文件中的初始化的末尾添加以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">RWTFlickrPhoto *photo = results.photos.firstObject;</div><div class="line">RACSignal *metaDataSignal = [[services getFlickrSearchService]</div><div class="line">                            flickrImageMetadata:photo.identifier];</div><div class="line">    [metaDataSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</div><div class="line">   &#125;];</div></pre></td></tr></table></figure>
<p>这段代码测试了新添加的方法，该方法从返回的结果中的第一幅图片获取图片元数据。运行程序后，会在控制台输出以下信息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-06</span><span class="number">-04</span> <span class="number">07</span>:<span class="number">27</span>:<span class="number">26.813</span> RWTFlickrSearch[<span class="number">76828</span>:<span class="number">70</span>b] metadata: comments=<span class="number">120</span>, faves=<span class="number">434</span></div></pre></td></tr></table></figure>
<h2 id="获取可见cell的元数据"><a href="#获取可见cell的元数据" class="headerlink" title="获取可见cell的元数据"></a>获取可见cell的元数据</h2><p>我们可以扩展当前代码来获取所有搜索结果的元数据。然而，如果我们有<code>100</code>条结果，则需要立即发起<code>200</code>个请求，每幅图片<code>2</code>个请求。大多数<code>API</code>都有些限制，这种调用方式会阻塞我们的请求调用，至少是临时的。</p>
<p>在一个<code>table</code>中，我们只需要获取当前显示的单元格所对象的结果的元数据。所以，如何实现这个行为呢？当然，我们需要一个<code>ViewModel</code>来表示这些数据。当前<code>RWTSearchResultsViewModel</code>暴露了一个绑定到<code>View</code>的<code>RWTFlickrPhoto</code>实例的数组，它们的暴露给<code>View</code>的<code>Model</code>层对象。为了添加这种可见性，我们将给<code>ViewModel</code>中的<code>model</code>对象添加<code>view-centric</code>状态。</p>
<p>在<code>ViewModel</code>分组中添加<code>RWTSearchResultsItemViewModel</code>类，打开头文件并各以下代码更新：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@import</span> Foundation;</div><div class="line"><span class="meta">#import <span class="meta-string">"RWTFlickrPhoto.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"RWTViewModelServices.h"</span></span></div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWTSearchResultsItemViewModel</span> : <span class="title">NSObject</span></span></div><div class="line"> </div><div class="line">- (<span class="keyword">instancetype</span>) initWithPhoto:(RWTFlickrPhoto *)photo services:(<span class="keyword">id</span>&lt;RWTViewModelServices&gt;)services;</div><div class="line"> </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> isVisible;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *title;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSURL</span> *url;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSNumber</span> *favorites;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSNumber</span> *comments;</div><div class="line"> </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>看看初始化方法，这个<code>ViewModel</code>封装了一个<code>RWTFlickrPhoto</code>模型对象的实例。这个<code>ViewModel</code>包含以下几类属性：</p>
<ol>
<li>表示底层<code>Model</code>属性的属性<code>(title, url)</code></li>
<li>当获取到元数据时动态更新的属性<code>(favorites, comments)</code></li>
<li><code>isVisible</code>，用于表示<code>ViewModel</code>是否可见</li>
</ol>
<p>打开<code>RWTSearchResultsItemViewModel.m</code>并导入以下头文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;ReactiveCocoa/ReactiveCocoa.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;ReactiveCocoa/RACEXTScope.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"RWTFlickrPhotoMetadata.h"</span></span></div></pre></td></tr></table></figure>
<p>接下来添加几个私有属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWTSearchResultsItemViewModel</span> ()</span></div><div class="line"> </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">id</span>&lt;RWTViewModelServices&gt; services;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) RWTFlickrPhoto *photo;</div><div class="line"> </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>然后实现初始化方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithPhoto:(RWTFlickrPhoto *)photo services:(<span class="keyword">id</span>&lt;RWTViewModelServices&gt;)services &#123;</div><div class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">    _title = photo.title;</div><div class="line">    _url = photo.url;</div><div class="line">    _services = services;</div><div class="line">    _photo = photo;</div><div class="line"> </div><div class="line">    [<span class="keyword">self</span> initialize];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span>  <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这基于<code>Model</code>对象的<code>title</code>和<code>url</code>属性，然后通过私有属性来存储服务和图片的引用。</p>
<p>接下来添加<code>initialize</code>方法。准备好，这里有些有趣的事情会发生。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)initialize &#123;</div><div class="line">  RACSignal *fetchMetadata =</div><div class="line">    [RACObserve(<span class="keyword">self</span>, isVisible)</div><div class="line">     filter:^<span class="built_in">BOOL</span>(<span class="built_in">NSNumber</span> *visible) &#123;</div><div class="line">       <span class="keyword">return</span> [visible boolValue];</div><div class="line">     &#125;];</div><div class="line"> </div><div class="line">  @weakify(<span class="keyword">self</span>)</div><div class="line">  [fetchMetadata subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    @strongify(<span class="keyword">self</span>)</div><div class="line">    [[[<span class="keyword">self</span>.services getFlickrSearchService] flickrImageMetadata:<span class="keyword">self</span>.photo.identifier]</div><div class="line">     subscribeNext:^(RWTFlickrPhotoMetadata *x) &#123;</div><div class="line">       <span class="keyword">self</span>.favorites = @(x.favorites);</div><div class="line">       <span class="keyword">self</span>.comments = @(x.comments);</div><div class="line">     &#125;];</div><div class="line">  &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法的第一部分通过监听<code>isVisible</code>属性和过滤<code>true</code>值来创建一个名为<code>fetchMetadata</code>的信号。结果，信号在<code>isVisible</code>属性设置为<code>true</code>时发出<code>next</code>事件。第二部分订阅这个信号以初始化到<code>flickrImageMetadata</code>方法的请求。当这个嵌套的信号发送<code>next</code>事件时，<code>favorite</code>和<code>comment</code>属性使用这个结果来更新值。</p>
<p>总的来说，当<code>isVisible</code>设置为<code>true</code>时，发送<code>Flickr API</code>请求，并在将来某个时刻更新<code>comments</code>和<code>favorites</code>属性。</p>
<p>为了使用新的<code>ViewModel</code>，打开<code>RWTSearchResultsViewModel.m</code>并导入头文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;LinqToObjectiveC/NSArray+LinqExtensions.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"RWTSearchResultsItemViewModel.h"</span></span></div></pre></td></tr></table></figure>
<p>在初始化方法中，移除当前设置<code>_searchResults</code>的代码，并使用以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">_searchResults =</div><div class="line">  [results.photos linq_select:^<span class="keyword">id</span>(RWTFlickrPhoto *photo) &#123;</div><div class="line">    <span class="keyword">return</span> [[RWTSearchResultsItemViewModel alloc]</div><div class="line">              initWithPhoto:photo services:services];</div><div class="line">  &#125;];</div></pre></td></tr></table></figure>
<p>这只是简单地使用一个<code>ViewModel</code>来包装每一个<code>Model</code>对象。</p>
<p>最后一步是通过视图来设置<code>isVisible</code>对象，并使用这些新的属性。</p>
<p>打开<code>RWTSearchResultsTableViewCell.m</code>并导入以下头文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"RWTSearchResultsItemViewModel.h"</span></span></div></pre></td></tr></table></figure>
<p>然后在下面的<code>bindViewModel</code>方法的第一行添加以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RWTSearchResultsItemViewModel *photo = viewModel;</div></pre></td></tr></table></figure>
<p>并在访方法中添加以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[RACObserve(photo, favorites) subscribeNext:^(<span class="built_in">NSNumber</span> *x) &#123;</div><div class="line">  <span class="keyword">self</span>.favouritesLabel.text = [x stringValue];</div><div class="line">  <span class="keyword">self</span>.favouritesIcon.hidden = (x == <span class="literal">nil</span>);</div><div class="line">&#125;];</div><div class="line"> </div><div class="line">[RACObserve(photo, comments) subscribeNext:^(<span class="built_in">NSNumber</span> *x) &#123;</div><div class="line">  <span class="keyword">self</span>.commentsLabel.text = [x stringValue];</div><div class="line">  <span class="keyword">self</span>.commentsIcon.hidden = (x == <span class="literal">nil</span>);</div><div class="line">&#125;];</div><div class="line"> </div><div class="line">photo.isVisible = <span class="literal">YES</span>;</div></pre></td></tr></table></figure>
<p>这个代码监听了新的<code>comments</code>和<code>favorites</code>属性，当它们更新<code>lable</code>和<code>image</code>时会更新。最后，<code>ModelView</code>的<code>isVisible</code>属性被设置成<code>YES</code>。<code>table view</code>绑定辅助类只绑定可见的单元格，所以只有少部分<code>ViewModel</code>去请求元数据。</p>
<p>运行后，以看到以下效果：</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/06/WithMetadata-333x500.png" alt="image"></p>
<p>是不是很酷？</p>
<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>慢着，还有一个问题没有解决。当我们快速地滚动滑动栏，如果不做特殊，会同时加载大量的元数据和图片，这将明显地降低我们程序的性能。为了解决这个问题，程序应该只在照片显示在界面上的的时候去初始化元数据请求。现在<code>ViewModel</code>的<code>isVisible</code>属性被设置为<code>YES</code>，但不会被设置成<code>NO</code>。我们现在来处理这个问题。</p>
<p>打开<code>RWTSearchResultsTableViewCell.m</code>，然后修改刚才添加到<code>bindViewModel:</code>的代码，以设置<code>isVisible</code>属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">photo.isVisible = <span class="literal">YES</span>;</div><div class="line">[<span class="keyword">self</span>.rac_prepareForReuseSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">  photo.isVisible = <span class="literal">NO</span>;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>当<code>ViewModel</code>绑定到<code>View</code>时，<code>isVisible</code>属性会被设置成<code>YES</code>。但是当<code>cell</code>被移出<code>table view</code>进行重用时会被设置成<code>NO</code>。我们通过<code>rac_prepareForReuseSignal</code>信号来实现这步操作。</p>
<p>返回到<code>RWTSearchResultsItemViewModel</code>中。<code>ViewModel</code>需要监听<code>isVisible</code>属性的修改，当属性被设置成<code>YES</code>后一秒钟，将发送一个元数据的请求。</p>
<p>在<code>RWTSearchResultsItemViewModel.m</code>中，更新<code>initialize</code>方法，移除<code>fetchMetadata</code>信号的创建。使用以下代码来替换：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 通过监听isVisible属性来创建信号。该信号发出的第一个next事件将包含这个属性的初始状态。</span></div><div class="line"><span class="comment">// 因为我们只关心这个值的改变，所以在第一个事件上调用skip操作。</span></div><div class="line">RACSignal *visibleStateChanged = [RACObserve(<span class="keyword">self</span>, isVisible) skip:<span class="number">1</span>];</div><div class="line"> </div><div class="line"><span class="comment">// 2. 通过过滤visibleStateChanged信号来创建一个信号对，一个标识从可见到隐藏的转换，另一个标识从隐藏到可见的转换</span></div><div class="line">RACSignal *visibleSignal = [visibleStateChanged filter:^<span class="built_in">BOOL</span>(<span class="built_in">NSNumber</span> *value) &#123;</div><div class="line">  <span class="keyword">return</span> [value boolValue];</div><div class="line">&#125;];</div><div class="line"> </div><div class="line">RACSignal *hiddenSignal = [visibleStateChanged filter:^<span class="built_in">BOOL</span>(<span class="built_in">NSNumber</span> *value) &#123;</div><div class="line">  <span class="keyword">return</span> ![value boolValue];</div><div class="line">&#125;];</div><div class="line"> </div><div class="line"><span class="comment">// 3. 这里是最神奇的地方。通过延迟visibleSignal信号1秒钟来创建fetchMetadata信号，在获取元数据之前暂停一会。</span></div><div class="line"><span class="comment">// takeUntil操作确保如果cell在1秒的时间间隔内又一次隐藏时，来自visibleSignal的next事件被挂起且不获取元数据。</span></div><div class="line">RACSignal *fetchMetadata = [[visibleSignal delay:<span class="number">1.0</span>f]</div><div class="line">                           takeUntil:hiddenSignal];</div></pre></td></tr></table></figure>
<p>你可以想像一下如果没有<code>ReactiveCocoa</code>，这会有多复杂。</p>
<p>运行程序，现在我们和滑动显示平滑多了。</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>当前搜索<code>Flickr</code>的代码只处理了<code>OFFlickrAPIRequestDelegate</code>协议中的<code>flickrAPIRequest:didCompleteWithResponse:</code>方法。不过，这样网络请求由于多种原因会出错。一个好的应用程序必须处理这些错误，以给用户一个良好的用户体验。代理同时定义了<code>flickrAPIRequest:didFailWithError:</code>方法，这个方法在请求出错时调用。我们将用这个方法来处理错误并显示一个提示框给用户。</p>
<p>我们之前讲过信号会发出<code>next</code>，<code>completed</code>和错误事件。其结果是，我们并不需要做太多的事情。</p>
<p>打开<code>RWTFlickrSearchImpl.m</code>，并定位到<code>signalFromAPIMethod:arguments:transform:</code>方法。在这个方法中，在创建<code>successSignal</code>变量前添加以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">RACSignal *errorSignal =</div><div class="line">  [<span class="keyword">self</span> rac_signalForSelector:<span class="keyword">@selector</span>(flickrAPIRequest:didFailWithError:)</div><div class="line">                 fromProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">OFFlickrAPIRequestDelegate</span>)];</span></div><div class="line"> </div><div class="line">[errorSignal subscribeNext:^(RACTuple *tuple) &#123;</div><div class="line">  [subscriber sendError:tuple.second];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>上面的代码从代理方法中创建了一个信号，订阅了该信号，如果发生错误则发送一个错误。传递给<code>subscribeNext</code>块的元组包含传递给<code>flickrAPIRequest:didFailWithError:</code>方法的变量。结果是，<code>tuple.second</code>获取源错误并使用它来为错误事件服务。这是一个很好的解决方案，你觉得呢？不是所有的<code>API</code>请求都有内建的错误处理。接下来我们使用它。</p>
<p><code>RWTFlickrSearchViewModel</code>不直接暴露信号给视图。相反它暴露一个状态和一个命令。我们需要扩展接口来提供错误报告。</p>
<p>打开<code>RWTFlickrSearchViewModel.h</code>并添加以下属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) RACSignal *connectionErrors;</div></pre></td></tr></table></figure>
<p>打开<code>RWTFlickrSearchViewModel.m</code>并添加以下代码到<code>initialize</code>实现的最后：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.connectionErrors = <span class="keyword">self</span>.executeSearch.errors;</div></pre></td></tr></table></figure>
<p><code>executeSearch</code>属性是一个<code>ReactiveCococa</code>框架的<code>RACCommand</code>对象。<code>RACCommand</code>类有一个<code>errors</code>属性，用于发送命令执行时产生的任何错误。</p>
<p>为了处理这些错误，打开<code>RWTFlickrSearchViewController.m</code>并添加以下的代码到<code>initWithViewModel:</code>方法中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[_viewModel.connectionErrors subscribeNext:^(<span class="built_in">NSError</span> *error) &#123;</div><div class="line">  <span class="built_in">UIAlertView</span> *alert =</div><div class="line">  [[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="string">@"Connection Error"</span></div><div class="line">                             message:<span class="string">@"There was a problem reaching Flickr."</span></div><div class="line">                            delegate:<span class="literal">nil</span></div><div class="line">                   cancelButtonTitle:<span class="string">@"OK"</span></div><div class="line">                   otherButtonTitles:<span class="literal">nil</span>];</div><div class="line">  [alert show];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>运行后，处理错误的效果如下：</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/06/ErrorMessages-281x500.png" alt="image"></p>
<p>想知道为什么获取收藏和评论的请求不报告错误么？这是由设计决定的，主要是这些不会影响程序的可用性。</p>
<h2 id="添加最近搜索列表"><a href="#添加最近搜索列表" class="headerlink" title="添加最近搜索列表"></a>添加最近搜索列表</h2><p>用户可能会回去查看一些重复的图片。所以，我们可以做些简化操作。回想一下本文的开头，最后的程序在搜索输入框下面有一个显示最近搜索结果的列表。</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/06/FinishedApp-671x500.png" alt="image"></p>
<p>现在我们只需要添加上这个功能，这次我要向你发起一个挑战了。我将这一部分的实现留给读者您来处理，来练习练习<code>MVVM</code>技能吧。</p>
<p>在开始之前，我在这些做些总结：</p>
<ol>
<li>我将创建一个<code>ViewModel</code>来表示每个先前的搜索，它包含一些属性，这些属性包括搜索文本，匹配的数量和第一个匹配的图片</li>
<li>我将修改<code>RWTFlickrSearchViewModel</code>来暴露这些新的<code>ViewModel</code>对象的数组做为一个属性。</li>
<li>使用<code>CETableViewBindingHelper</code>可以非常简单地渲染<code>ViewModel</code>的数组，我已经添加了一个合适的<code>cell(RWTRecentSearchItemTableViewCell</code>)到工程中。</li>
</ol>
<h2 id="接下来何去何从？"><a href="#接下来何去何从？" class="headerlink" title="接下来何去何从？"></a>接下来何去何从？</h2><p>在<a href="https://github.com/ColinEberhardt/ReactiveFlickrSearch" target="_blank" rel="external">这里</a>可以下载最终的程序。这两部分的内容已经包含了很多内容，这里我们可以好好回顾一下主要点：</p>
<ol>
<li><code>MVVM</code>是<code>MVC</code>模式的一个变种，它正逐渐流行起来</li>
<li><code>MVVM</code>模式让<code>View</code>层代码变得更清晰，更易于测试</li>
<li>严格遵守<code>View=&gt;ViewModel=&gt;Model</code>这样一个引用层次，然后通过绑定来将<code>ViewModel</code>的更新反映到<code>View</code>层上。</li>
<li><code>ViewModel</code>层决不应该维护<code>View</code>的引用</li>
<li><code>ViewModel</code>层可以看作是视图的模型(<code>model-of-the-view</code>)，它暴露属性，以直接反映视图的状态，以及执行用户交互相关的命令。</li>
<li><code>Model</code>层暴露服务。</li>
<li>针对<code>MVVM</code>程序的测试可以在没有<code>UI</code>的情况下运行。</li>
<li><code>ReactiveCocoa</code>框架提供强大的机制来将<code>ViewModel</code>绑定到<code>View</code>。它同时也广泛地使用在<code>ViewModel</code>和<code>Model</code>层中。</li>
</ol>
<p>怎么样，下次创建程序的时候，是不是试试<code>MVVM</code>？试试吧。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/08/08/mvvm-tutorial-with-reactivecocoa-1/" itemprop="url">
                  MVVM Tutorial with ReactiveCocoa: Part 1/2
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-08-08T18:54:42+08:00" content="2014-08-08">
              2014-08-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文由<code>Colin Eberhardt</code>发表于<code>raywenderlich</code>，原文可查看<a href="http://www.raywenderlich.com/74106/mvvm-tutorial-with-reactivecocoa-part-1" target="_blank" rel="external">MVVM Tutorial with ReactiveCocoa: Part 1/2</a></p>
<p>你可能已经在<code>Twitter</code>上听过这个这个笑话了：</p>
<blockquote>
<p>“iOS Architecture, where MVC stands for Massive View Controller”</p>
</blockquote>
<p>当然这在<code>iOS</code>开发圈内，这是个轻松的笑话，但我敢确定你大实践中遇到过这个问题：即视图控制器太大且难以管理。</p>
<p>这篇文章将介绍另一种构建应用程序的模式–<code>MVVM(Model-View-ViewModel)</code>。通过结合<code>ReactiveCocoa</code>便利性，这个模式提供了一个很好的代替<code>MVC</code>的方案，它保证了让视图控制器的轻量性。</p>
<p>在本文我，我们将通过构建一个简单的<code>Flickr</code>查询程序来一步步了解<code>MVVM</code>，这个程序的效果图如下所示：</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/06/FinishedApp.png" alt="image"></p>
<p>在开始写代码之前，我们先来了解一些基本的原理。</p>
<p>原文简要介绍了一下<code>ReactiveCocoa</code>，在此不再翻译，可以查看以下两篇译文：</p>
<p><a href="http://southpeak.github.io/blog/2014/08/02/reactivecocoazhi-nan-%5B%3F%5D-:xin-hao/">ReactiveCocoa Tutorial – The Definitive Introduction: Part 1/2</a></p>
<p><a href="http://southpeak.github.io/blog/2014/08/02/reactivecocoazhi-nan-er-:twittersou-suo-shi-li/">ReactiveCocoa Tutorial – The Definitive Introduction: Part 2/2</a></p>
<h2 id="MVVM模式介绍"><a href="#MVVM模式介绍" class="headerlink" title="MVVM模式介绍"></a>MVVM模式介绍</h2><p>正如其名称一下，<code>MVVM</code>是一个<code>UI</code>设计模式。它是<code>MV*</code>模式集合中的一员。<code>MV*</code>模式还包含<code>MVC(Model View Controller)</code>、<code>MVP(Model View Presenter)</code>等。这些模式的目的在于将UI逻辑与业务逻辑分离，以让程序更容易开发和测试。为了更好的理解<code>MVVM</code>模式，我们可以看看其来源。</p>
<p><code>MVC</code>是最初的<code>UI</code>设计模式，最早出现在<code>Smalltalk</code>语言中。下图展示了<code>MVC</code>模式的主要组成：</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/06/MVCPattern-2.png" alt="image"></p>
<p>这个模式将<code>UI</code>分成<code>Model</code>(表示程序状态)、<code>View</code>(由UI控件组成)、<code>Controller</code>(处理用户交互与更新<code>model</code>)。<code>MVC</code>模式的最大问题是其令人相当困惑。它的概念看起来很好，但当我们实现<code>MVC</code>时，就会产生上图这种<code>Model-View-Controller</code>之间的环状关系。这种相互关系将会导致可怕的混乱。</p>
<p>最近<code>Martin Fowler</code>介绍了<code>MVC</code>模式的一个变种，这种模式命名为<code>MVVM</code>，并被微软广泛采用并推广。</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/06/MVVMPattern.png" alt="image"></p>
<p>这个模式的核心是<code>ViewModel</code>，它是一种特殊的<code>model</code>类型，用于表示程序的<code>UI</code>状态。它包含描述每个<code>UI</code>控件的状态的属性。例如，文本输入域的当前文本，或者一个特定按钮是否可用。它同样暴露了视图可以执行哪些行为，如按钮点击或手势。</p>
<p>我们可以将<code>ViewModel</code>看作是视图的模型(<code>model-of-the-view</code>)。<code>MVVM</code>模式中的三部分比<code>MVC</code>更加简洁，下面是一些严格的限制</p>
<ol>
<li><code>View</code>引用了<code>ViewModel</code>，但反过来不行。</li>
<li><code>ViewModel</code>引用了<code>Model</code>，但反过来不行。</li>
</ol>
<p>如果我们破坏了这些规则，便无法正确地使用<code>MVVM</code>。</p>
<p>这个模式有以下一些立竿见影的优势：</p>
<ol>
<li>轻量的视图：所有的UI逻辑都在<code>ViewModel</code>中。</li>
<li>便于测试：我们可以在没有视图的情况下运行整个程序，这样大大地增加了它的可测试性。</li>
</ol>
<p>现在你可能注意到一个问题。如果<code>View</code>引用了<code>ViewModel</code>，但<code>ViewModel</code>没有引用<code>View</code>，那<code>ViewModel</code>如何更新视图呢？哈哈，这就得靠<code>MVVM</code>模式的私密武器了。</p>
<h2 id="MVVM和数据绑定"><a href="#MVVM和数据绑定" class="headerlink" title="MVVM和数据绑定"></a>MVVM和数据绑定</h2><p><code>MVVM</code>模式依赖于数据绑定，它是一个框架级别的特性，用于自动连接对象属性和UI控件。例如，在微软的<code>WPF</code>框架中，下面的标签将一个<code>TextField</code>的<code>Text</code>属性绑定到<code>ViewModel</code>的<code>Username</code>属性中。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">TextField</span> <span class="attr">Text</span>=<span class="string">”&#123;DataBinding</span> <span class="attr">Path</span>=<span class="string">Username,</span> <span class="attr">Mode</span>=<span class="string">TwoWay&#125;”/</span>&gt;</span></div></pre></td></tr></table></figure>
<p>WPF框架将这两个属性绑定到一起。</p>
<p>不过可惜的是，<code>iOS</code>没有数据绑定框架，幸运的是我们可以通过<code>ReactiveCocoa</code>来实现这一功能。我们从<code>iOS</code>开发的角度来看看<code>MVVM</code>模式，<code>ViewController</code>及其相关的<code>UI</code>(<code>nib</code>, <code>stroyboard</code>或纯代码的<code>View</code>)组成了View:</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/06/MVVMReactiveCocoa.png" alt="image"></p>
<p>……而<code>ReactiveCocoa</code>绑定了<code>View</code>和<code>ViewModel</code>。</p>
<p>理论讲得差不多了，我们可以开始新的历程了。</p>
<h2 id="启动项目结构"><a href="#启动项目结构" class="headerlink" title="启动项目结构"></a>启动项目结构</h2><p>可以从<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2014/06/FlickrSearchStarterProject1.zip" target="_blank" rel="external">FlickrSearchStarterProject.zip</a>中下载启动项目。我们使用<code>Cocoapods</code>来管理第三方库，在对应目录下执行<code>pod install</code>命令生成依赖库后，我们就可以打开生成的<code>RWTFlickrSearch.xcworkspace</code>来运行我们的项目了，初始运行效果如下图：</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/06/first-launch.jpg" alt="image"></p>
<p>我们行熟悉下工程的结构：</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/06/EmptyInterface.png" alt="image"></p>
<p><code>Model</code>和<code>ViewModel</code>分组目前是空的，我们会慢慢往里面添加东西。<code>View</code>分组包含以下几个类</p>
<ol>
<li><code>RWTFlickSearchViewController</code>：程序的主屏幕，包含一个搜索输入域和一个<code>GO</code>按钮。</li>
<li><code>RWTRecentSearchItemTableViewCell</code>：用于在主页中显示搜索结果的<code>table cell</code></li>
<li><code>RWTSearchResultsViewController</code>：搜索结果页，显示来自<code>Flickr</code>的<code>tableview</code></li>
<li><code>RWTSearchResultsTableViewCell</code>：渲染来自<code>Flickr</code>的单个图片的<code>table cell</code>。</li>
</ol>
<p>现在来写我们的第一个<code>ViewModel</code>吧。</p>
<h2 id="第一个ViewModel"><a href="#第一个ViewModel" class="headerlink" title="第一个ViewModel"></a>第一个ViewModel</h2><p>在<code>ViewModel</code>分组中添加一个继承自<code>NSObject</code>的新类<code>RWTFlickrSearchViewModel</code>。然后在该类的头文件中，添加以下两行代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *searchText;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *title;</div></pre></td></tr></table></figure>
<p><code>searchText</code>属性表示文本域中显示文本，<code>title</code>属性表示导航条上的标题。</p>
<p>打开<code>RWTFlickrSearchViewModel.m</code>文件添加以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RWTFlickrSearchViewModel</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>)</div><div class="line">    &#123;</div><div class="line">        [<span class="keyword">self</span> initialize];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)initialize</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span>.searchText = <span class="string">@"search text"</span>;</div><div class="line">    <span class="keyword">self</span>.title = <span class="string">@"Flickr Search"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这段代码简单地设置了<code>ViewModel</code>的初始状态。</p>
<p>接下来我们将连接<code>ViewModel</code>到<code>View</code>。记住<code>View</code>保存了一个<code>ViewModel</code>的引用。在这种情况下，添加一个给定<code>ViewModel</code>的初始化方法来构造<code>View</code>是很有必要的。打开<code>RWTFlickrSearchViewController.h</code>，并导入<code>ViewModel</code>头文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"RWTFlickrSearchViewModel.h"</span></span></div></pre></td></tr></table></figure>
<p>并添加以下初始化方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWTFlickrSearchViewController</span> : <span class="title">UIViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)initWithViewModel:(RWTFlickrSearchViewModel *)viewModel;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>在<code>RWTFlickrSearchViewController.m</code>中，在类的扩展中添加以下私有属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) RWTFlickrSearchViewModel *viewModel;</div></pre></td></tr></table></figure>
<p>然后添加以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithViewModel:(RWTFlickrSearchViewModel *)viewModel</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>)</div><div class="line">    &#123;</div><div class="line">        _viewModel = viewModel;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就在<code>view</code>中存储了一个到<code>ViewModel</code>的引用。<em>注意这是一个弱引用，这样<code>View</code>引用了<code>ViewModel</code>，但没有拥有它。</em></p>
<p>接下来在<code>viewDidLoad</code>里面添加下面代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span> bindViewModel];</div></pre></td></tr></table></figure>
<p>该方法的实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)bindViewModel</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span>.title = <span class="keyword">self</span>.viewModel.title;</div><div class="line">    <span class="keyword">self</span>.searchTextField.text = <span class="keyword">self</span>.viewModel.searchText;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后我们需要创建<code>ViewModel</code>，并将其提供给<code>View</code>。在<code>RWTAppDelegate.m</code>中，添加以下头文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"RWTFlickrSearchViewModel.h"</span></span></div></pre></td></tr></table></figure>
<p>同时添加一个私有属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) RWTFlickrSearchViewModel *viewModel;</div></pre></td></tr></table></figure>
<p>我们会发现这个类中已以有一个<code>createInitialViewController</code>方法了，我们用以下代码来更新它：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UIViewController</span> *)createInitialViewController &#123;</div><div class="line">    <span class="keyword">self</span>.viewModel = [RWTFlickrSearchViewModel new];</div><div class="line">    <span class="keyword">return</span> [[RWTFlickrSearchViewController alloc] initWithViewModel:<span class="keyword">self</span>.viewModel];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法创建了一个<code>ViewModel</code>实例，然后构造并返回了<code>View</code>。这个视图作程序导航控制器的初始视图。</p>
<p>运行后的状态如下：</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/06/ViewWithState-333x500.png" alt="image"></p>
<p>这样我们就得到了第一个<code>ViewModel</code>。不过仍然有许多东西要学的。你可能已经发现了我们还没有使用<code>ReactiveCocoa</code>。到目前为止，用户在输入框上的输入操作不会影响到<code>ViewModel</code>。</p>
<h2 id="检测可用的搜索状态"><a href="#检测可用的搜索状态" class="headerlink" title="检测可用的搜索状态"></a>检测可用的搜索状态</h2><p>现在，我们来看看如何用<code>ReactiveCocoa</code>来绑定<code>ViewModel</code>和<code>View</code>，以将搜索输入框和按钮连接到<code>ViewModel</code>。</p>
<p>在<code>RWTFlickrSearchViewController.m</code>中，我们使用如下代码更新<code>bindViewModel</code>方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)bindViewModel</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span>.title = <span class="keyword">self</span>.viewModel.title;</div><div class="line">    RAC(<span class="keyword">self</span>.viewModel, searchText) = <span class="keyword">self</span>.searchTextField.rac_textSignal;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>ReactiveCocoa</code>中，使用了分类将<code>rac_textSignal</code>属性添加到<code>UITextField</code>类中。它是一个信号，在文本域每次更新时会发送一个包含当前文本的<code>next</code>事件。</p>
<p><code>RAC</code>是一个用于做绑定操作的宏，上面的代码会使用<code>rac_textSignal</code>发出的<code>next</code>信号来更新<code>viewModel</code>的<code>searchText</code>属性。</p>
<p>搜索按钮应该只有在用户输入有效时才可点击。为了方便起见，我们以输入字符大于<code>3</code>时输入有效为准。在<code>RWTFlickrSearchViewModel.m</code>中导入以下头文件。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;ReactiveCocoa/ReactiveCocoa.h&gt;</span></span></div></pre></td></tr></table></figure>
<p>然后更新初始化方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)initialize</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span>.title = <span class="string">@"Flickr Search"</span>;</div><div class="line">    </div><div class="line">    RACSignal *validSearchSignal =</div><div class="line">    [[RACObserve(<span class="keyword">self</span>, searchText)</div><div class="line">      map:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">        <span class="keyword">return</span> @(text.length &gt; <span class="number">3</span>);</div><div class="line">    &#125;]</div><div class="line">     distinctUntilChanged];</div><div class="line">    </div><div class="line">    [validSearchSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"search text is valid %@"</span>, x);</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行程序并在输入框中输入一些字符，在控制台中我们可以看到以下输出：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-08</span><span class="number">-07</span> <span class="number">21</span>:<span class="number">50</span>:<span class="number">44.078</span> RWTFlickrSearch[<span class="number">3116</span>:<span class="number">60</span>b] search text is valid <span class="number">0</span></div><div class="line"><span class="number">2014</span><span class="number">-08</span><span class="number">-07</span> <span class="number">21</span>:<span class="number">50</span>:<span class="number">59.493</span> RWTFlickrSearch[<span class="number">3116</span>:<span class="number">60</span>b] search text is valid <span class="number">1</span></div><div class="line"><span class="number">2014</span><span class="number">-08</span><span class="number">-07</span> <span class="number">21</span>:<span class="number">51</span>:<span class="number">02.594</span> RWTFlickrSearch[<span class="number">3116</span>:<span class="number">60</span>b] search text is valid <span class="number">0</span></div></pre></td></tr></table></figure>
<p>上面的代码使用<code>RACObserve</code>宏来从<code>ViewModel</code>的<code>searchText</code>属性创建一个信号。<code>map</code>操作将文本转化为一个<code>true</code>或<code>false</code>值的流。</p>
<p>最后，<code>distinctUntilChanges</code>确保信号只有在状态改变时才发出值。</p>
<p>到目前为止，我们可以看到<code>ReactiveCocoa</code>被用于将绑定<code>View</code>绑定到<code>ViewModel</code>，确保了这两者是同步的。另进一步地，<code>ViewModel</code>内部的<code>ReactiveCocoa</code>代码用于观察自己的状态及执行其它操作。</p>
<p>这就是<code>MVVM</code>模式的基本处理过程。<code>ReactiveCocoa</code>通常用于绑定<code>View</code>和<code>ViewModel</code>，但在程序的其它层也非常有用。</p>
<h2 id="添加搜索命令"><a href="#添加搜索命令" class="headerlink" title="添加搜索命令"></a>添加搜索命令</h2><p>本节将上面创建的<code>validSearchSignal</code>来创建绑定到<code>View</code>的操作。打开<code>RWTFlickrSearchViewModel.h</code>并添加以下头文件</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;ReactiveCocoa/ReactiveCocoa.h&gt;</span></span></div></pre></td></tr></table></figure>
<p>同时添加以下属性</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) RACCommand *executeSearch;</div></pre></td></tr></table></figure>
<p><code>RACCommand</code>是<code>ReactiveCocoa</code>中用于表示<code>UI</code>操作的一个类。它包含一个代表了<code>UI</code>操作的结果的信号以及标识操作当前是否被执行的一个状态。</p>
<p>在<code>RWTFlickrSearchViewModel.m</code>的<code>initialize</code>方法的最后添加以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.executeSearch = [[RACCommand alloc] initWithEnabled:validSearchSignal</div><div class="line">                                             signalBlock:^RACSignal *(<span class="keyword">id</span> input) &#123;</div><div class="line">                                                 <span class="keyword">return</span> [<span class="keyword">self</span> executeSearchSignal];</div><div class="line">                                             &#125;];</div></pre></td></tr></table></figure>
<p>这创建了一个在<code>validSearchSignal</code>发送<code>true</code>时可用的命令。另外，需要在下面实现<code>executeSearchSignal</code>方法，它提供了命令所执行的操作。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (RACSignal *)executeSearchSignal</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [[[[RACSignal empty] logAll] delay:<span class="number">2.0</span>] logAll];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个方法中，我们执行一些业务逻辑操作，以作为命令执行的结果，并通过信号异步返回结果。</p>
<p>到目前为止，上述代码只提供了一个简单的实现：空信号会立即完成。<code>delay</code>操作会将其所接收到的<code>next</code>或<code>complete</code>事件延迟两秒执行。</p>
<p>最后一步是将这个命令连接到<code>View</code>中。打开<code>RWTFlickrSearchViewController.m</code>并在<code>bindViewModel</code>方法的结尾中添加以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.searchButton.rac_command = <span class="keyword">self</span>.viewModel.executeSearch;</div></pre></td></tr></table></figure>
<p><code>rac_command</code>属性是<code>UIButton</code>的<code>ReactiveCocoa</code>分类中添加的属性。上面的代码确保点击按钮执行给定的命令，且按钮的可点击状态反应了命令的可用状态。</p>
<p>运行代码，输入一些字符并点击<code>GO</code>，得到如下结果：</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/06/GoButtonEnabled-333x500.png" alt="image"></p>
<p>可以看到，当输入有效点击按钮时，按钮会置灰<code>2</code>秒钟，当执行的信号完成时又可点击。我们可以看下控制台的输出，可以发现空信号会立即完成，而延迟操作会在<code>2</code>秒后发出事件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-08</span><span class="number">-07</span> <span class="number">22</span>:<span class="number">21</span>:<span class="number">25.128</span> RWTFlickrSearch[<span class="number">3161</span>:<span class="number">60</span>b] &lt;RACDynamicSignal: <span class="number">0x17005ba20</span>&gt; name: +empty completed</div><div class="line"><span class="number">2014</span><span class="number">-08</span><span class="number">-07</span> <span class="number">22</span>:<span class="number">21</span>:<span class="number">27.329</span> RWTFlickrSearch[<span class="number">3161</span>:<span class="number">60</span>b] &lt;RACDynamicSignal: <span class="number">0x17005dd30</span>&gt; name: [+empty] -delay: <span class="number">2.000000</span> completed</div></pre></td></tr></table></figure>
<p>是不是很酷？</p>
<h2 id="绑定、绑定还是绑定"><a href="#绑定、绑定还是绑定" class="headerlink" title="绑定、绑定还是绑定"></a>绑定、绑定还是绑定</h2><p><code>RACCommand</code>监听了搜索按钮状态的更新，但处理<code>activity indicator</code>的可见性则由我们负责。<code>RACCommand</code>暴露了一个<code>executing</code>属性，它是一个信号，发送<code>true</code>或<code>false</code>来标明命令开始和结束执行的时间。我们可以用这个来影响当前命令的状态。</p>
<p>在<code>RWTFlickrSearchViewController.m</code>中的<code>bindViewModel</code>方法结尾处添加以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RAC([<span class="built_in">UIApplication</span> sharedApplication], networkActivityIndicatorVisible) = <span class="keyword">self</span>.viewModel.executeSearch.executing;</div></pre></td></tr></table></figure>
<p>这将<code>UIApplication</code>的<code>networkActivityIndicatorVisible</code>属性绑定到命令的<code>executing</code>信号中。这确保了不管命令什么时候执行，状态栏中的网络<code>activity indicator</code>都会显示。</p>
<p>接下来添加以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RAC(<span class="keyword">self</span>.loadingIndicator, hidden) = [<span class="keyword">self</span>.viewModel.executeSearch.executing not];</div></pre></td></tr></table></figure>
<p>当命令执行时，应该隐藏加载<code>indicator</code>。这可以通过<code>not</code>操作来反转信号。</p>
<p>最后，添加以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.viewModel.executeSearch.executionSignals subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    [<span class="keyword">self</span>.searchTextField resignFirstResponder];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>这段代码确保命令执行时隐藏键盘。<code>executionSignals</code>属性发送由命令每次执行时生成的信号。这个属性是信号的信号(见<a href="http://southpeak.github.io/blog/2014/08/02/reactivecocoazhi-nan-%5B%3F%5D-:xin-hao/">ReactiveCocoa Tutorial – The Definitive Introduction: Part 1/2</a>)。当创建和发出一个新的命令执行信号时，隐藏键盘。</p>
<p>运行程序看看效果如何吧。</p>
<h2 id="Model在哪？"><a href="#Model在哪？" class="headerlink" title="Model在哪？"></a>Model在哪？</h2><p>到目前为止，我们已经有了一个清晰的<code>View(RWTFlickrSearchViewController)</code>和<code>ViewModel(RWTFlickrSearchViewModel</code>)，但是<code>Model</code>在哪呢？</p>
<p>答案很简单：没有！</p>
<p>当前的程序执行一个命令来响应用户点击搜索按钮的操作，但是实现不做任何值的处理。<code>ViewModel</code>真正需要做的是使用当前的<code>searchText</code>来搜索<code>Flickr</code>，并返回一个匹配的列表。</p>
<p>我们应该可以直接在<code>ViewModel</code>添加业务逻辑，但相信我，你不希望这么做。如果这是一个<code>viewcontroller</code>，我打赌你一定会直接这么做。</p>
<p><code>ViewModel</code>暴露属性来表示<code>UI</code>状态，它同样暴露命令来表示<code>UI</code>操作(通常是方法)。<code>ViewModel</code>负责管理基于用户交互的<code>UI</code>状态的改变。然而它不负责实际执行这些交互产生的的业务逻辑，那是<code>Model</code>的工作。</p>
<p>接下来，我们将在程序中添加<code>Model</code>层。</p>
<p>在<code>Model</code>分组中，添加<code>RWTFlickrSearch</code>协议并提供以下实现</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;ReactiveCocoa/ReactiveCocoa.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">RWTFlickrSearch</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"></div><div class="line">- (RACSignal *)flickrSearchSignal:(<span class="built_in">NSString</span> *)searchString;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这个协议定义了<code>Model</code>层的初始接口，并将搜索<code>Flickr</code>的责任移出<code>ViewModel</code>。</p>
<p>接下来在<code>Model</code>分组中添加<code>RWTFlickrSearchImpl</code>类，其继承自<code>NSObject</code>，并实现了<code>RWTFlickrSearch</code>协议，如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"RWTFlickrSearch.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWTFlickrSearchImpl</span> : <span class="title">NSObject</span> &lt;<span class="title">RWTFlickrSearch</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>打开<code>RWTFlickrSearchImpl.m</code>文件，提供以下实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RWTFlickrSearchImpl</span></span></div><div class="line"></div><div class="line">- (RACSignal *)flickrSearchSignal:(<span class="built_in">NSString</span> *)searchString</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [[[[RACSignal empty] logAll] delay:<span class="number">2.0</span>] logAll];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>看着是不是有点眼熟？没错，我们在上面的<code>ViewModel</code>中有相同的实现。</p>
<p>接下来我们需要在<code>ViewModel</code>层中使用<code>Model</code>层。在<code>ViewModel</code>分组中添加<code>RWTViewModelServices</code>协议并如下实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"RWTFlickrSearch.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">RWTViewModelServices</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line">- (<span class="keyword">id</span>&lt;RWTFlickrSearch&gt;)getFlickrSearchService;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这个协议定义了唯一的一个方法，以允许<code>ViewModel</code>获取一个引用，以指向<code>RWTFlickrSearch</code>协议的实现对象。</p>
<p>打开<code>RWTFlickrSearchViewModel.h</code>并导入头文件</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"RWTViewModelServices.h"</span></span></div></pre></td></tr></table></figure>
<p>更新初始化方法并将<code>RWTViewModelServices</code>作为一个参数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithServices:(<span class="keyword">id</span>&lt;RWTViewModelServices&gt;)services;</div></pre></td></tr></table></figure>
<p>在<code>RWTFlickrSearchViewModel.m</code>中，添加类的分类并提供一个私有属性来维护一个到<code>RWTViewModelServices</code>的引用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWTFlickrSearchViewModel</span> ()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span>&lt;RWTViewModelServices&gt; services;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>在该文件下面，添加初始化方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithServices:(<span class="keyword">id</span>&lt;RWTViewModelServices&gt;)services</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>)</div><div class="line">    &#123;</div><div class="line">        _services = services;</div><div class="line">        [<span class="keyword">self</span> initialize];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这只是简单的存储了<code>services</code>的引用。</p>
<p>最后，更新<code>executeSearchSignal</code>方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (RACSignal *)executeSearchSignal</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span>.services getFlickrSearchService] flickrSearchSignal:<span class="keyword">self</span>.searchText];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后是连接<code>Model</code>和<code>ViewModel</code>。</p>
<p>在工程的根分组中，添加一个<code>NSObject</code>的子类<code>RWTViewModelServicesImpl</code>。打开<code>RWTViewModelServicesImpl.h</code>并实现<code>RWTViewModelServices</code>协议：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"RWTViewModelServices.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWTViewModelServicesImpl</span> : <span class="title">NSObject</span> &lt;<span class="title">RWTViewModelServices</span>&gt;</span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>打开<code>RWTViewModelServicesImpl.m</code>，并添加实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"RWTFlickrSearchImpl.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWTViewModelServicesImpl</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) RWTFlickrSearchImpl *searchService;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RWTViewModelServicesImpl</span></span></div><div class="line">  </div><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init])</div><div class="line">    &#123;</div><div class="line">        _searchService = [RWTFlickrSearchImpl new];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>&lt;RWTFlickrSearch&gt;)getFlickrSearchService</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.searchService;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这个类简单创建了一个<code>RWTFlickrSearchImpl</code>实例，用于<code>Model</code>层搜索<code>Flickr</code>服务，并将其提供给<code>ViewModel</code>的请求。</p>
<p>最后，在<code>RWTAppDelegate.m</code>中添加以下头文件</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"RWTViewModelServicesImpl.h"</span></span></div></pre></td></tr></table></figure>
<p>并添加一个新的私有属性</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) RWTViewModelServicesImpl *viewModelServices;</div></pre></td></tr></table></figure>
<p>再更新<code>createInitialViewController</code>方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UIViewController</span> *)createInitialViewController &#123;</div><div class="line">    <span class="keyword">self</span>.viewModelServices = [RWTViewModelServicesImpl new];</div><div class="line">    <span class="keyword">self</span>.viewModel = [[RWTFlickrSearchViewModel alloc] initWithServices:<span class="keyword">self</span>.viewModelServices];</div><div class="line">    <span class="keyword">return</span> [[RWTFlickrSearchViewController alloc] initWithViewModel:<span class="keyword">self</span>.viewModel];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行程序，验证程序有没有按之前的方式来工作。当然，这不是最有趣的变化，不过，可以看看新代码的形状了。</p>
<p><code>Model</code>层暴露了一个<code>ViewModel</code>层使用的’服务’。一个协议定义了这个服务的接口，提供了松散的组合。</p>
<p>我们可以使用这种方式来为单元测试提供一个类似的服务实现。程序现在有了正确的<code>MVVM</code>结构，让我们小结一下：</p>
<ol>
<li>Model层暴露服务并负责提供程序的业务逻辑实现。</li>
<li><code>ViewModel</code>层表示程序的视图状态(<code>view-state</code>)。同时响应用户交互及来自<code>Model</code>层的事件，两者都受<code>view-state</code>变化的影响。</li>
<li><code>View</code>层很薄，只提供<code>ViewModel</code>状态的显示及输出用户交互事件。</li>
</ol>
<h2 id="搜索Flickr"><a href="#搜索Flickr" class="headerlink" title="搜索Flickr"></a>搜索Flickr</h2><p>我们继续来完成Flickr的搜索实现，事情变得越来越有趣了。</p>
<p>首先我们创建表示搜索结果的模型对象。在<code>Model</code>分组中，添加<code>RWTFlickrPhoto</code>类，并为其添加三个属性。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWTFlickrPhoto</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *title;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURL</span> *url;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *identifier;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这个模型对象表示由<code>Flickr</code>搜索<code>API</code>返回一个图片。</p>
<p>打开<code>RWTFlickrPhoto.m</code>，并添加以下描述方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span> *)description</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.title;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来，新建一个新的模型对象类<code>RWTFlickrSearchResults</code>，并添加以下属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWTFlickrSearchResults</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *searchString;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSArray</span> *photos;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> totalResults;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这个类表示由<code>Flickr</code>搜索返回的照片集合。</p>
<p>是时候实现搜索<code>Flickr</code>了。打开<code>RWTFlickrSearchImpl.m</code>并导入以下头文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"RWTFlickrSearchResults.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"RWTFlickrPhoto.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objectiveflickr/ObjectiveFlickr.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;LinqToObjectiveC/NSArray+LinqExtensions.h&gt;</span></span></div></pre></td></tr></table></figure>
<p>然后添加以下类扩展：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWTFlickrSearchImpl</span> () &lt;<span class="title">OFFlickrAPIRequestDelegate</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSMutableSet</span> *requests;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) OFFlickrAPIContext *flickrContext;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这个类实现了<code>OFFlickrAPIRequestDelegate</code>协议，并添加了两个私有属性。我们会很快看到如何使用这些值。</p>
<p>继续添加代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSString</span> *OFSampleAppAPIKey = <span class="string">@"YOUR_API_KEY_GOES_HERE"</span>;</div><div class="line">        <span class="built_in">NSString</span> *OFSampleAppAPISharedSecret = <span class="string">@"YOUR_SECRET_GOES_HERE"</span>;</div><div class="line">        </div><div class="line">        _flickrContext = [[OFFlickrAPIContext alloc] initWithAPIKey:OFSampleAppAPIKey sharedSecret:OFSampleAppAPISharedSecret];</div><div class="line">        </div><div class="line">        _requests = [<span class="built_in">NSMutableSet</span> new];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码创建了一个<code>Flickr</code>的上下文，用于存储<code>ObjectiveFlickr</code>请求的数据。</p>
<p>当前<code>Model</code>层服务类提供的<code>API</code>有一个单独的方法，用于查找基于文本搜索字符的图片。不过我们一会会添加更多的方法。</p>
<p>在<code>RWTFlickrSearchImpl.m</code>中添加以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">- (RACSignal *)signalFromAPIMethod:(<span class="built_in">NSString</span> *)method arguments:(<span class="built_in">NSDictionary</span> *)args transform:(<span class="keyword">id</span> (^)(<span class="built_in">NSDictionary</span> *response))block</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 1. 创建请求信号</span></div><div class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">// 2. 创建一个Flick请求对象</span></div><div class="line">        OFFlickrAPIRequest *flickrRequest = [[OFFlickrAPIRequest alloc] initWithAPIContext:<span class="keyword">self</span>.flickrContext];</div><div class="line">        flickrRequest.delegate = <span class="keyword">self</span>;</div><div class="line">        [<span class="keyword">self</span>.requests addObject:flickrRequest];</div><div class="line">        </div><div class="line">        <span class="comment">// 3. 从代理方法中创建一个信号</span></div><div class="line">        RACSignal *successSignal = [<span class="keyword">self</span> rac_signalForSelector:<span class="keyword">@selector</span>(flickrAPIRequest:didCompleteWithResponse:)</div><div class="line">                                                  fromProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">OFFlickrAPIRequestDelegate</span>)];</span></div><div class="line">        </div><div class="line">        <span class="comment">// 4. 处理响应</span></div><div class="line">        [[[successSignal</div><div class="line">         map:^<span class="keyword">id</span>(RACTuple *tuple) &#123;</div><div class="line">             <span class="keyword">return</span> tuple.second;</div><div class="line">         &#125;]</div><div class="line">         map:block]</div><div class="line">         subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">             [subscriber sendNext:x];</div><div class="line">             [subscriber sendCompleted];</div><div class="line">         &#125;];</div><div class="line">        </div><div class="line">        <span class="comment">// 5. 开始请求</span></div><div class="line">        [flickrRequest callAPIMethodWithGET:method arguments:args];</div><div class="line">        </div><div class="line">        <span class="comment">// 6. 完成后，移除请求的引用</span></div><div class="line">        <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</div><div class="line">            [<span class="keyword">self</span>.requests removeObject:flickrRequest];</div><div class="line">        &#125;];</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法需要传入请求方法及请求参数，然后使用<code>block</code>参数来转换响应对象。我们重点看一下第<code>4</code>步：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[[[successSignal</div><div class="line">  <span class="comment">// 1. 从flickrAPIRequest:didCompleteWithResponse:代理方法中提取第二个参数</span></div><div class="line">  map:^<span class="keyword">id</span>(RACTuple *tuple) &#123;</div><div class="line">    <span class="keyword">return</span> tuple.second;</div><div class="line">  &#125;]</div><div class="line">  <span class="comment">// 2. 转换结果</span></div><div class="line">  map:block]</div><div class="line">  subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="comment">// 3. 将结果发送给订阅者</span></div><div class="line">    [subscriber sendNext:x];</div><div class="line">    [subscriber sendCompleted];</div><div class="line">  &#125;];</div></pre></td></tr></table></figure>
<p><code>rac_signalForSelector:fromProtocol:</code> 方法创建了<code>successSignal</code>，同样也在代理方法的调用中创建了信号。</p>
<p>代理方法每次调用时，发出的<code>next</code>事件会附带包含方法参数的<code>RACTuple</code>。</p>
<p>实现<code>Flickr</code>搜索的最后一步如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (RACSignal *)flickrSearchSignal:(<span class="built_in">NSString</span> *)searchString &#123;</div><div class="line">  <span class="keyword">return</span> [<span class="keyword">self</span> signalFromAPIMethod:<span class="string">@"flickr.photos.search"</span></div><div class="line">                         arguments:@&#123;<span class="string">@"text"</span>: searchString,</div><div class="line">                                     <span class="string">@"sort"</span>: <span class="string">@"interestingness-desc"</span>&#125;</div><div class="line">                         transform:^<span class="keyword">id</span>(<span class="built_in">NSDictionary</span> *response) &#123;</div><div class="line"> </div><div class="line">    RWTFlickrSearchResults *results = [RWTFlickrSearchResults new];</div><div class="line">    results.searchString = searchString;</div><div class="line">    results.totalResults = [[response valueForKeyPath:<span class="string">@"photos.total"</span>] integerValue];</div><div class="line"> </div><div class="line">    <span class="built_in">NSArray</span> *photos = [response valueForKeyPath:<span class="string">@"photos.photo"</span>];</div><div class="line">    results.photos = [photos linq_select:^<span class="keyword">id</span>(<span class="built_in">NSDictionary</span> *jsonPhoto) &#123;</div><div class="line">      RWTFlickrPhoto *photo = [RWTFlickrPhoto new];</div><div class="line">      photo.title = [jsonPhoto objectForKey:<span class="string">@"title"</span>];</div><div class="line">      photo.identifier = [jsonPhoto objectForKey:<span class="string">@"id"</span>];</div><div class="line">      photo.url = [<span class="keyword">self</span>.flickrContext photoSourceURLFromDictionary:jsonPhoto</div><div class="line">                                                              size:OFFlickrSmallSize];</div><div class="line">      <span class="keyword">return</span> photo;</div><div class="line">    &#125;];</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">  &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的方法使用<code>signalFromAPIMethod:arguments:transform:</code>方法。<code>flickr.photos.search</code>方法提供的字典来搜索照片。</p>
<p>传递给<code>transform</code>参数的<code>block</code>简单地将<code>NSDictionary</code>响应转化为一个等价的模型对象，让它在<code>ViewModel</code>中更容易使用。</p>
<p>最后一步是打开<code>RWTFlickrSearchViewModel.m</code>方法，然后更新搜索信号来记录日志：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (RACSignal *)executeSearchSignal &#123;</div><div class="line">  <span class="keyword">return</span> [[[<span class="keyword">self</span>.services getFlickrSearchService]</div><div class="line">           flickrSearchSignal:<span class="keyword">self</span>.searchText]</div><div class="line">           logAll];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译，运行并输入一些字符后可在控制台看到以下日志：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-06</span><span class="number">-03</span> [...] &lt;RACDynamicSignal: <span class="number">0x8c368a0</span>&gt; name: +createSignal: next: searchString=wibble, totalresults=<span class="number">1973</span>, photos=(</div><div class="line">    <span class="string">"Wibble, wobble, wibble, wobble"</span>,</div><div class="line">    <span class="string">"unoa-army"</span>,</div><div class="line">    <span class="string">"Day 277: Cheers to the freakin' weekend!"</span>,</div><div class="line">    [...]</div><div class="line">    <span class="string">"Angry sky"</span>,</div><div class="line">    Nemesis</div><div class="line">)</div></pre></td></tr></table></figure>
<p>这样我们<code>MVVM</code>指南的第一部分就差不多结束了，但在结束之前，让我们先看看内存问题吧。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>正如在<a href="http://southpeak.github.io/blog/2014/08/02/reactivecocoazhi-nan-er-:twittersou-suo-shi-li/">ReactiveCocoa Tutorial – The Definitive Introduction: Part 2/2</a>中所讲的一样，我们在<code>block</code>中使用了<code>self</code>，这可能会导致循环引用的问题。而为了避免此问题，我们需要使用<code>@weakify</code>和<code>@strongify</code>宏来打破这种循环引用。</p>
<p>不过看看<code>signalFromAPIMethod:arguments:transform:</code>方法，你可能会迷惑为什么没有使用这两个宏来引用<code>self</code>？这是因为<code>block</code>是作为<code>createSignal:</code>方法的一个参数，它不会在<code>self</code>和<code>block</code>之间建立一个强引用关系。迷茫了吧？不相信的话只需要测试一样这段代码有没有内存泄露就行。当然这时候就得用<code>Instruments</code>了，自己去看吧。哈哈。</p>
<h2 id="何去何从？"><a href="#何去何从？" class="headerlink" title="何去何从？"></a>何去何从？</h2><p>例子工程的完整代码可以在<a href="http://cdn4.raywenderlich.com/wp-content/uploads/2014/06/FlickrSearchPart1Project1.zip" target="_blank" rel="external">这里</a>下载。在下一部分中，我们将看看如何从<code>ViewModel</code>中初始化一个视图控制器并实现更多的<code>Flickr</code>请求操作。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/08/02/reactivecocoa-tutorial-the-definitive-introduction-2/" itemprop="url">
                  ReactiveCocoa Tutorial – The Definitive Introduction: Part 2/2
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-08-02T23:20:48+08:00" content="2014-08-02">
              2014-08-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文由<code>Colin Eberhardt</code>发表于<code>raywenderlich</code>，<a href="http://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2" target="_blank" rel="external">ReactiveCocoa Tutorial – The Definitive Introduction: Part 2/2</a></p>
<p><a href="http://southpeak.github.io/blog/2014/08/02/reactivecocoazhi-nan-%5B%3F%5D-:xin-hao/">第一部分</a>我们学习了<code>ReactiveCocoa</code>处理信号的基本流程，如何发送流事件，以及分割及组合信号。在这一部分中，我们将继续学习<code>ReactiveCocoa</code>更多的特性，包括：</p>
<ol>
<li><code>error</code>和<code>completed</code>事件类型</li>
<li>节流(<code>Throttling</code>)</li>
<li>线程</li>
<li>扩展</li>
</ol>
<h2 id="Twitter-Instant"><a href="#Twitter-Instant" class="headerlink" title="Twitter Instant"></a>Twitter Instant</h2><p>本部分我们将要开发的是一个称为<code>Twitter Instant</code>的程序，这是一个<code>Twitter</code>搜索应用，用于裡更新搜索结果。可以在<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2014/01/TwitterInstant-Starter2.zip" target="_blank" rel="external">这里</a>下载初始程序，同时我们需要通过<code>Cocoapods</code>来下载依赖库，这个过程与第一部分相同。完成之后，运行程序，将得到下面的界面：</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/TwitterInstantStarter.png" alt="image"></p>
<p>我们花点时间熟悉一下。这个程序很简单。左侧控制面板是<code>RWSearchFormViewController</code>，有一个搜索框。右侧是<code>RWSearchResultsViewController</code>。如果我们打开<code>RWSearchFormViewController.m</code>，我们可以看到<code>viewDidLoad</code>方法中指定了<code>resultsViewController</code>属性，这个程序的主要逻辑是在<code>RWSearchFormViewController</code>中，这个属性将搜索结果提供给<code>RWSearchResultsViewController</code>。</p>
<h2 id="验证搜索框"><a href="#验证搜索框" class="headerlink" title="验证搜索框"></a>验证搜索框</h2><p>首先我们来校验输入框的字符长度是否大于<code>2</code>。我们在<code>RWSearchFormViewController.m</code>的<code>viewDidLoad</code>方法下面添加以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)isValidSearchText:(<span class="built_in">NSString</span> *)text</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> text.length &gt; <span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来，我们在<code>RWSearchFormViewController.m</code>中导入<code>ReactiveCocoa</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;ReactiveCocoa/ReactiveCocoa.h&gt;</span></span></div></pre></td></tr></table></figure>
<p>同时在viewDidLoad方法最后加上以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[<span class="keyword">self</span>.searchText.rac_textSignal map:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> isValidSearchText:text] ? [<span class="built_in">UIColor</span> whiteColor] : [<span class="built_in">UIColor</span> yellowColor];</div><div class="line">&#125;] subscribeNext:^(<span class="built_in">UIColor</span> *color) &#123;</div><div class="line">    <span class="keyword">self</span>.searchText.backgroundColor = color;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>这段代码通过信号来检测输入是否有效，并设置相应的输入框背影颜色值。运行后，可以看到如下效果：</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/ValidatedTextField.png" alt="image"></p>
<p>其管道流程图如下所示：</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/01/TextValidationPipeline.png" alt="image"></p>
<p><code>rac_textSignal</code>在每次输入时发出<code>next</code>事件，并包含当前输入框的文本。然后<code>map</code>操作将其转换为颜色值，最后<code>subscribeNext:</code>获取这个颜色值并用它来设置输入框的背景颜色。</p>
<p>在添加Twitter查找逻辑之前，我们先看看一些有趣的东西。</p>
<h2 id="格式化管道代码"><a href="#格式化管道代码" class="headerlink" title="格式化管道代码"></a>格式化管道代码</h2><p>在调用信号的方法时，我们建议每个操作都新起一行，并排列所有的步骤。如下图所示，一个复杂的管道通过分行，看起来会更加清晰</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/PipelineFormatting.png" alt="image"></p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>考虑下我们添加到<code>TwitterInstant</code>程序中的代码，想知道我们创建的管道是如何被保存的么？当然，因为它没有被指定给变量或属性，所以它没有增加引用计数，因此注定被销毁？<code>ReactiveCocoa</code>设计的目的之一是允许这样一种编程样式，即管道可以匿名创建。到目前为止，我们的管道都是这么处理的。为了支持这种模式，<code>ReactiveCocoa</code>维护了一个全局的信号集合。如果信号有一个或多个订阅者，它就是可用的。如果所有订阅者都被移除了，信号就被释放了。</p>
<p>剩下最后一个问题：如何取消对信号的订阅？在一个<code>completed</code>事件或<code>error</code>事件后，一个订阅者会自动将自己移除。手动移除可能通过<strong>RACDisposable</strong>来完成。<code>RACSignal</code>的所有订阅方法都返回一个<code>RACDisposable</code>实例，我们可以调用它的<code>dispose</code>方法来手动移除订阅者。如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">RACSignal *backgroundColorSignal =</div><div class="line">    [<span class="keyword">self</span>.searchText.rac_textSignal</div><div class="line">     map:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">         <span class="keyword">return</span> [<span class="keyword">self</span> isValidSearchText:text] ? [<span class="built_in">UIColor</span> whiteColor] : [<span class="built_in">UIColor</span> yellowColor];</div><div class="line">     &#125;];</div><div class="line"></div><div class="line">RACDisposable *subscripion =</div><div class="line">    [backgroundColorSignal subscribeNext:^(<span class="built_in">UIColor</span> *color) &#123;</div><div class="line">        <span class="keyword">self</span>.searchText.backgroundColor = color;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line"><span class="comment">// 在某个位置调用</span></div><div class="line">[subscripion dispose];</div></pre></td></tr></table></figure>
<p>当然实际上我们不需要这样来写，只需要知道是这么回事就行。</p>
<p><em>注意：如果我们创建了一个管道，但不去订阅它，则管理永远不会执行，包括任何如doNext:块这样的附加操作。</em></p>
<h2 id="避免循环引用"><a href="#避免循环引用" class="headerlink" title="避免循环引用"></a>避免循环引用</h2><p><code>ReactiveCocoa</code>在幕后做了许多事情，让我们不需要担心信号的内存管理问题，但有一点关于内存管理的问题需要特别注意。我们先来看看下面的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[<span class="keyword">self</span>.searchText.rac_textSignal map:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> isValidSearchText:text] ? [<span class="built_in">UIColor</span> whiteColor] : [<span class="built_in">UIColor</span> yellowColor];</div><div class="line">&#125;] subscribeNext:^(<span class="built_in">UIColor</span> *color) &#123;</div><div class="line">    <span class="keyword">self</span>.searchText.backgroundColor = color;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p><code>subscribeNext:</code>块使用了<code>self</code>，以获取文本输入域。<code>Block</code>会捕获并保留闭包中的值，因此如果在<code>self</code>与信号之间有一个强引用，则会导致循环引用问题。这是不是问题取决于<code>self</code>对象的生命周期。如果<code>self</code>的生命周期是整个程序生存期，则没问题，好好用吧。但在大多数情况下，它确实是一个问题。</p>
<p>为了避循环引用，根据苹果的文档中推荐的捕获<code>self</code>的一个弱引用。如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">__<span class="keyword">typeof</span>(<span class="keyword">self</span>) __<span class="keyword">weak</span> weakSelf = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">[[<span class="keyword">self</span>.searchText.rac_textSignal map:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">    <span class="keyword">return</span> [weakSelf isValidSearchText:text] ? [<span class="built_in">UIColor</span> whiteColor] : [<span class="built_in">UIColor</span> yellowColor];</div><div class="line">&#125;] subscribeNext:^(<span class="built_in">UIColor</span> *color) &#123;</div><div class="line">    weakSelf.searchText.backgroundColor = color;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>在上面的代码中<code>weakSelf</code>是<code>self</code>对象的一个弱引用。现在<code>subscribeNext:</code>中使用了这个变量。不过<code>ReactiveCocoa</code>框架给我们提供了一个更好的选择。首先导入以下头文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;RACEXTScope.h&gt;</span></span></div></pre></td></tr></table></figure>
<p>然后使用以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@weakify(<span class="keyword">self</span>)</div><div class="line"></div><div class="line">[[<span class="keyword">self</span>.searchText.rac_textSignal map:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> isValidSearchText:text] ? [<span class="built_in">UIColor</span> whiteColor] : [<span class="built_in">UIColor</span> yellowColor];</div><div class="line">&#125;] subscribeNext:^(<span class="built_in">UIColor</span> *color) &#123;</div><div class="line">    @strongify(<span class="keyword">self</span>)</div><div class="line">    <span class="keyword">self</span>.searchText.backgroundColor = color;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>宏<code>@weakify</code>与<code>@strongify</code>在<a href="https://github.com/jspahrsummers/libextobjc" target="_blank" rel="external">Extendedobjc</a>库中引用，它们包含在<code>ReactiveCocoa</code>框架中。<code>@weakify</code>允许我们创建一些影子变量，它是都是弱引用(可以同时创建多个)，<code>@strongify</code>允许创建变量的强引用，这些变量是先前传递给<code>@weakify</code>的。</p>
<p>最后需要注意的是，当在<code>block</code>中使用实例变量时，<code>block</code>同样会捕获<code>self</code>的一个强引用。我们可以打开编译器警告，来提示我们这种情况。如下所求来处理</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/AvoidRetainSelf.png" alt="image"></p>
<p>OK，内存问题说得差不多了，现在我们回到正题。</p>
<h2 id="请求访问Twitter"><a href="#请求访问Twitter" class="headerlink" title="请求访问Twitter"></a>请求访问Twitter</h2><p>我们将使用<code>Social Framework</code>以允许<code>TwitterInstant</code>程序搜索<code>Tweets</code>，同时使用<code>Accounts Framework</code>来获取对<code>Twitter</code>的访问。</p>
<p>在添加代码前，我们需要先登录<code>Twitter</code>。可以在系统的设置中登录，如下图所示：</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/TwitterCredentials.png" alt="image"></p>
<p>我们的工程已经添加了所需要的框架，所以只需要在<code>RWSearchFormViewController.m</code>导入头文件。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Accounts/Accounts.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;Social/Social.h&gt;</span></span></div></pre></td></tr></table></figure>
<p>然后在下面添加枚举及常量用于标识错误：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, RWTwitterInstantError) &#123;</div><div class="line">    RWTwitterInstantErrorAccessDenied,</div><div class="line">    RWTwitterInstantErrorNoTwitterAccounts,</div><div class="line">    RWTwitterInstantErrorInvalidResponse</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> RWTwitterInstantDomain = <span class="string">@"TwitterInstant"</span>;</div></pre></td></tr></table></figure>
<p>然后我们<code>RWSearchFormViewController()</code>分类中添加以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) ACAccountStore *accountStore;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) ACAccountType *twitterAccountType;</div></pre></td></tr></table></figure>
<p><code>ACAccountsStore</code>类提供了我们的设备可连接的多种社交账号，<code>ACAccountType</code>类表示账号的指定类型。</p>
<p>我们在<code>viewDidLoad</code>的结尾处添加以下代码，来创建账户存储及<code>Twitter</code>账户标识：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.accountStore = [[ACAccountStore alloc] init];</div><div class="line"><span class="keyword">self</span>.twitterAccountType = [<span class="keyword">self</span>.accountStore accountTypeWithAccountTypeIdentifier:ACAccountTypeIdentifierTwitter];</div></pre></td></tr></table></figure>
<p>当账户请求社账号时，用户可以看到一个弹出框。这是一个异步操作，所以将其包装到一个信号中是很好的选择。</p>
<p>仍然在这个文件中，添加以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (RACSignal *)requestAccessToTwitterSignal</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 定义一个错误，如果用户拒绝访问则发送</span></div><div class="line">    <span class="built_in">NSError</span> *accessError = [<span class="built_in">NSError</span> errorWithDomain:RWTwitterInstantDomain code:RWTwitterInstantErrorAccessDenied userInfo:<span class="literal">nil</span>];</div><div class="line">    </div><div class="line">    <span class="comment">// 创建并返回信号</span></div><div class="line">    @weakify(<span class="keyword">self</span>)</div><div class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">// 请求访问twitter</span></div><div class="line">        @strongify(<span class="keyword">self</span>)</div><div class="line">        [<span class="keyword">self</span>.accountStore requestAccessToAccountsWithType:<span class="keyword">self</span>.twitterAccountType</div><div class="line">                                                   options:<span class="literal">nil</span></div><div class="line">                                                completion:^(<span class="built_in">BOOL</span> granted, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">                                                    <span class="comment">// 处理响应</span></div><div class="line">                                                    <span class="keyword">if</span> (!granted)</div><div class="line">                                                    &#123;</div><div class="line">                                                        [subscriber sendError:accessError];</div><div class="line">                                                    &#125;</div><div class="line">                                                    <span class="keyword">else</span></div><div class="line">                                                    &#123;</div><div class="line">                                                        [subscriber sendNext:<span class="literal">nil</span>];</div><div class="line">                                                        [subscriber sendCompleted];</div><div class="line">                                                    &#125;</div><div class="line">                                                &#125;];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个信号可以发送三种事件类型：<code>next</code>, <code>completed</code>, <code>error</code>。</p>
<p>在信号的整个生命周期中，都可能不会发送事件，或者发送一个或多个<code>next</code>事件，其后跟着<code>completed</code>或<code>error</code>事件。</p>
<p>最后，为了使用这个信号，在<code>viewDidLoad</code>中添加以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[[<span class="keyword">self</span> requestAccessToTwitterSignal]</div><div class="line"> subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"Access granted"</span>);</div><div class="line"> &#125; error:^(<span class="built_in">NSError</span> *error) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"An error occurred: %@"</span>, error);</div><div class="line"> &#125;];</div></pre></td></tr></table></figure>
<p>运行程序，可以看到下面的提示</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/01/RequestAccessToTwitter.png" alt="image"></p>
<p>如果点击OK，<code>subscribeNext:</code>块中的日志会打印出来。如果点击<code>Don&#39;t allow</code>，则会执行错误块并打印期望的信息。</p>
<h2 id="链接信号"><a href="#链接信号" class="headerlink" title="链接信号"></a>链接信号</h2><p>一旦用户获取了<code>Twitter</code>账户的访问权限，程序需要继续监听搜索框的输入，以查询<code>twitter</code>。程序需要等待请求访问<code>Twitter</code>的信号来发出完成事件，然后订阅广西输入框的信号。不同信号的顺序链接是一个问题，但<code>ReactiveCocoa</code>已经做了很好的处理。</p>
<p>在<code>viewDidLoad</code>中用下面代码来替换当前的管道：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[[[<span class="keyword">self</span> requestAccessToTwitterSignal]</div><div class="line"> then:^RACSignal *&#123;</div><div class="line">     @strongify(<span class="keyword">self</span>)</div><div class="line">     <span class="keyword">return</span> <span class="keyword">self</span>.searchText.rac_textSignal;</div><div class="line"> &#125;]</div><div class="line"> subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</div><div class="line"> &#125; error:^(<span class="built_in">NSError</span> *error) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"An error occurred: %@"</span>, error);</div><div class="line"> &#125;];</div></pre></td></tr></table></figure>
<p><code>then</code>方法会等到<code>completed</code>事件发出后调用，然后订阅由<code>block</code>参数返回的信号。这有效地将控制从一个信号传递给下一个信号。运行程序，获取访问，然后在输入框输入，会在控制台看到以下输出：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-01</span><span class="number">-04</span> <span class="number">08</span>:<span class="number">16</span>:<span class="number">11.444</span> TwitterInstant[<span class="number">39118</span>:a0b] m</div><div class="line"><span class="number">2014</span><span class="number">-01</span><span class="number">-04</span> <span class="number">08</span>:<span class="number">16</span>:<span class="number">12.276</span> TwitterInstant[<span class="number">39118</span>:a0b] ma</div><div class="line"><span class="number">2014</span><span class="number">-01</span><span class="number">-04</span> <span class="number">08</span>:<span class="number">16</span>:<span class="number">12.413</span> TwitterInstant[<span class="number">39118</span>:a0b] mag</div><div class="line"><span class="number">2014</span><span class="number">-01</span><span class="number">-04</span> <span class="number">08</span>:<span class="number">16</span>:<span class="number">12.548</span> TwitterInstant[<span class="number">39118</span>:a0b] magi</div><div class="line"><span class="number">2014</span><span class="number">-01</span><span class="number">-04</span> <span class="number">08</span>:<span class="number">16</span>:<span class="number">12.628</span> TwitterInstant[<span class="number">39118</span>:a0b] magic</div><div class="line"><span class="number">2014</span><span class="number">-01</span><span class="number">-04</span> <span class="number">08</span>:<span class="number">16</span>:<span class="number">13.172</span> TwitterInstant[<span class="number">39118</span>:a0b] magic!</div></pre></td></tr></table></figure>
<p>下一步，我们添加一个<code>filter</code>操作到管道，以移除无效的搜索字符串。在这个实例中，是要求输入长度不小于<code>3</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[[[[<span class="keyword">self</span> requestAccessToTwitterSignal]</div><div class="line"> then:^RACSignal *&#123;</div><div class="line">     @strongify(<span class="keyword">self</span>)</div><div class="line">     <span class="keyword">return</span> <span class="keyword">self</span>.searchText.rac_textSignal;</div><div class="line"> &#125;]</div><div class="line"> filter:^<span class="built_in">BOOL</span>(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">     @strongify(<span class="keyword">self</span>)</div><div class="line">     <span class="keyword">return</span> [<span class="keyword">self</span> isValidSearchText:text];</div><div class="line"> &#125;]</div><div class="line"> subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</div><div class="line"> &#125; error:^(<span class="built_in">NSError</span> *error) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"An error occurred: %@"</span>, error);</div><div class="line"> &#125;];</div></pre></td></tr></table></figure>
<p>运行后的输出是</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-01</span><span class="number">-04</span> <span class="number">08</span>:<span class="number">16</span>:<span class="number">12.548</span> TwitterInstant[<span class="number">39118</span>:a0b] magi</div><div class="line"><span class="number">2014</span><span class="number">-01</span><span class="number">-04</span> <span class="number">08</span>:<span class="number">16</span>:<span class="number">12.628</span> TwitterInstant[<span class="number">39118</span>:a0b] magic</div><div class="line"><span class="number">2014</span><span class="number">-01</span><span class="number">-04</span> <span class="number">08</span>:<span class="number">16</span>:<span class="number">13.172</span> TwitterInstant[<span class="number">39118</span>:a0b] magic!</div></pre></td></tr></table></figure>
<p>当前管道如下图所示：</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/PipelineWithThen.png" alt="image"></p>
<p>现在我们有一个发送搜索文本的信号了，是时候用它来搜索<code>Twitter</code>了。接下来才是正题。</p>
<h2 id="搜索Twitter"><a href="#搜索Twitter" class="headerlink" title="搜索Twitter"></a>搜索Twitter</h2><p><code>Social Framework</code>是访问<code>Twitter</code>搜索<code>API</code>的一个选择。但是<code>Social Framework</code>不是响应式的。接下来是封装所需要的<code>API</code>方法到信号中。现在，我们需要挂起这个过程。</p>
<p>在<code>RWSearchFormViewController.m</code>中，添加以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (SLRequest *)requestforTwitterSearchWithText:(<span class="built_in">NSString</span> *)text</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://api.twitter.com/1.1/search/tweets.json"</span>];</div><div class="line">    <span class="built_in">NSDictionary</span> *params = @&#123;<span class="string">@"q"</span>: text&#125;;</div><div class="line">    </div><div class="line">    SLRequest *request = [SLRequest requestForServiceType:SLServiceTypeTwitter</div><div class="line">                                            requestMethod:SLRequestMethodGET</div><div class="line">                                                      URL:url</div><div class="line">                                               parameters:params];</div><div class="line">    <span class="keyword">return</span> request;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法通过<a href="https://dev.twitter.com/docs/api/1.1" target="_blank" rel="external">v1.1 REST API</a>创建了一个搜索<code>Twitter</code>的请求。关于这个<code>API</code>，可以在<a href="https://dev.twitter.com/docs/api/1.1/get/search/tweets" target="_blank" rel="external">Twitter API docs</a>中查看更多信息。</p>
<p>接下来创建一个基于请求的信号。在同一文件中，添加以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">- (RACSignal *)signalForSearchWithText:(<span class="built_in">NSString</span> *)text &#123;</div><div class="line">    <span class="comment">// 定义错误</span></div><div class="line">    <span class="built_in">NSError</span> *noAccountError = [<span class="built_in">NSError</span> errorWithDomain:RWTwitterInstantDomain code:RWTwitterInstantErrorNoTwitterAccounts userInfo:<span class="literal">nil</span>];</div><div class="line">    </div><div class="line">    <span class="built_in">NSError</span> *invalidResponseError = [<span class="built_in">NSError</span> errorWithDomain:RWTwitterInstantDomain code:RWTwitterInstantErrorInvalidResponse userInfo:<span class="literal">nil</span>];</div><div class="line">    </div><div class="line">    <span class="comment">// 创建信号block</span></div><div class="line">    @weakify(<span class="keyword">self</span>)</div><div class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        @strongify(<span class="keyword">self</span>)</div><div class="line">        </div><div class="line">        <span class="comment">// 创建请求</span></div><div class="line">        SLRequest *request = [<span class="keyword">self</span> requestforTwitterSearchWithText:text];</div><div class="line">        </div><div class="line">        <span class="comment">// 提供Twitter账户</span></div><div class="line">        <span class="built_in">NSArray</span> *twitterAccounts = [<span class="keyword">self</span>.accountStore accountsWithAccountType:<span class="keyword">self</span>.twitterAccountType];</div><div class="line">        <span class="keyword">if</span> (twitterAccounts.count == <span class="number">0</span>) &#123;</div><div class="line">            [subscriber sendError:noAccountError];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            [request setAccount:[twitterAccounts lastObject]];</div><div class="line">            </div><div class="line">            <span class="comment">// 执行请求</span></div><div class="line">            [request performRequestWithHandler:^(<span class="built_in">NSData</span> *responseData, <span class="built_in">NSHTTPURLResponse</span> *urlResponse, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">                <span class="keyword">if</span> (urlResponse.statusCode == <span class="number">200</span>) &#123;</div><div class="line">                    <span class="comment">// 成功，解析响应</span></div><div class="line">                    <span class="built_in">NSDictionary</span> *timelineData = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:responseData options:<span class="built_in">NSJSONReadingAllowFragments</span> error:<span class="literal">nil</span>];</div><div class="line">                    [subscriber sendNext:timelineData];</div><div class="line">                    [subscriber sendCompleted];</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// 失败，发送一个错误</span></div><div class="line">                    [subscriber sendError:invalidResponseError];</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们来使用这个新信号。</p>
<p>在第一部分中我们学习了如何使用<code>flattenMap</code>来将每个<code>next</code>事件映射到一个新的被订阅的信号。这里我们再次使用它们。在<code>viewDidLoad</code>的最后用如下代码更新：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[[[[[<span class="keyword">self</span> requestAccessToTwitterSignal]</div><div class="line"> then:^RACSignal *&#123;</div><div class="line">     @strongify(<span class="keyword">self</span>)</div><div class="line">     <span class="keyword">return</span> <span class="keyword">self</span>.searchText.rac_textSignal;</div><div class="line"> &#125;]</div><div class="line"> filter:^<span class="built_in">BOOL</span>(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">     @strongify(<span class="keyword">self</span>)</div><div class="line">     <span class="keyword">return</span> [<span class="keyword">self</span> isValidSearchText:text];</div><div class="line"> &#125;]</div><div class="line"> flattenMap:^RACStream *(<span class="built_in">NSString</span> *text ) &#123;</div><div class="line">     @strongify(<span class="keyword">self</span>)</div><div class="line">     <span class="keyword">return</span> [<span class="keyword">self</span> signalForSearchWithText:text];</div><div class="line"> &#125;]</div><div class="line"> subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</div><div class="line"> &#125; error:^(<span class="built_in">NSError</span> *error) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"An error occurred: %@"</span>, error);</div><div class="line"> &#125;];</div></pre></td></tr></table></figure>
<p>运行并在搜索框中输入一些文本。一旦文本字符串长度大于<code>3</code>后，我们可以在控制台查看搜索的结果。如下显示了返回数据的一个片断：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-01</span><span class="number">-05</span> <span class="number">07</span>:<span class="number">42</span>:<span class="number">27.697</span> TwitterInstant[<span class="number">40308</span>:<span class="number">5403</span>] &#123;</div><div class="line">    <span class="string">"search_metadata"</span> =     &#123;</div><div class="line">        <span class="string">"completed_in"</span> = <span class="string">"0.019"</span>;</div><div class="line">        count = <span class="number">15</span>;</div><div class="line">        <span class="string">"max_id"</span> = <span class="number">419735546840117248</span>;</div><div class="line">        <span class="string">"max_id_str"</span> = <span class="number">419735546840117248</span>;</div><div class="line">        <span class="string">"next_results"</span> = <span class="string">"?max_id=419734921599787007&amp;q=asd&amp;include_entities=1"</span>;</div><div class="line">        query = asd;</div><div class="line">        <span class="string">"refresh_url"</span> = <span class="string">"?since_id=419735546840117248&amp;q=asd&amp;include_entities=1"</span>;</div><div class="line">        <span class="string">"since_id"</span> = <span class="number">0</span>;</div><div class="line">        <span class="string">"since_id_str"</span> = <span class="number">0</span>;</div><div class="line">    &#125;;</div><div class="line">    statuses =     (</div><div class="line">                &#123;</div><div class="line">            contributors = <span class="string">"&lt;null&gt;"</span>;</div><div class="line">            coordinates = <span class="string">"&lt;null&gt;"</span>;</div><div class="line">            <span class="string">"created_at"</span> = <span class="string">"Sun Jan 05 07:42:07 +0000 2014"</span>;</div><div class="line">            entities =             &#123;</div><div class="line">                hashtags = ...</div></pre></td></tr></table></figure>
<p><code>signalForSearchText:</code>方法同样发出了一个<code>error</code>事件，其由<code>subscribeNext:error:</code>块来处理。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>现在一定想把返回的<code>JSON</code>数据显示到<code>UI</code>上了吧，不过，在此之前我们还有一件事情需要处理。要了解这是什么，我们还需要探索一下。</p>
<p>在下图的<code>subscribeNext:error:</code>中打个断点：</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/BreakpointLocation.png" alt="image"></p>
<p>重新运行程序，如果需要则再次输入<code>Twitter</code>账号密码，在搜索框中输入一些文本。当程序运行到断点位置时可以看到类似于下图的场景：</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/01/BreakpointResult.png" alt="image"></p>
<p>注意，从左侧的线程列表中我们可以看到<code>debugger</code>到的代码并没有运行在主线程，即线程<code>Thread 1</code>。记住，更新<code>UI</code>的操作一定得在主线程中操作；因此，如果要在<code>UI</code>上显示<code>tweet</code>列表，则必须切换线程。</p>
<p>这说明了<code>ReactiveCocoa</code>框架的一个重要点。上面显示的操作是在信号初始发出事件时的那个线程执行。尝试在管道的其它步骤添加断点，我们会很惊奇的发现它们会运行在多个不同的线程上。</p>
<p>因此，我们应该如何来更新UI呢？当然<code>ReactiveCocoa</code>也为我们解决了这个问题。我们只需要在<code>flattenMap:</code>后面添加<code>deliverOn:</code>操作：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[[[[[[<span class="keyword">self</span> requestAccessToTwitterSignal]</div><div class="line"> then:^RACSignal *&#123;</div><div class="line">     @strongify(<span class="keyword">self</span>)</div><div class="line">     <span class="keyword">return</span> <span class="keyword">self</span>.searchText.rac_textSignal;</div><div class="line"> &#125;]</div><div class="line"> filter:^<span class="built_in">BOOL</span>(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">     @strongify(<span class="keyword">self</span>)</div><div class="line">     <span class="keyword">return</span> [<span class="keyword">self</span> isValidSearchText:text];</div><div class="line"> &#125;] flattenMap:^RACStream *(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">     @strongify(<span class="keyword">self</span>)</div><div class="line">     <span class="keyword">return</span> [<span class="keyword">self</span> signalForSearchWithText:text];</div><div class="line"> &#125;]</div><div class="line"> deliverOn:[RACScheduler mainThreadScheduler]]</div><div class="line"> subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</div><div class="line"> &#125; error:^(<span class="built_in">NSError</span> *error) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"An error occurred: %@"</span>, error);</div><div class="line"> &#125;];</div></pre></td></tr></table></figure>
<p>现在重新运行，此时我们可以看到<code>subscribeNext:error:</code>是运行在主线程了。</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/BreakpointNowOnUIThread.png" alt="image"></p>
<p>这样我们就可以安全地更新我们的UI了。</p>
<h2 id="更新UI"><a href="#更新UI" class="headerlink" title="更新UI"></a>更新UI</h2><p>打开<code>RWSearchResultsViewController.h</code>文件，我们可以看到<code>displayTweets:</code>方法，这个方法会让右侧的<code>ViewController</code>来渲染<code>tweet</code>数组。实现非常简单，它只是一个标准<code>UITableView</code>数据源。<code>displayTweets:</code>只需要一个包含<code>RWTweet</code>实例的数组作为参数。我们同样发现<code>RWTweet</code>实例是作为初始工程的一部分提供的。</p>
<p>在<code>subscibeNext:error:</code>步骤中获取到的数据现在是一个<code>NSDictionary</code>，它是在<code>signalForSearchWithText:</code>解析<code>JSON</code>数据时构造的。那么，我们如何处理这个字典的内容呢？</p>
<p>如果看一看<a href="https://dev.twitter.com/docs/api/1.1/get/search/tweets" target="_blank" rel="external">Twitter API documentation</a>，我们可以发现一个示例响应。在<code>NSDictionary</code>反映了这种结构，所以我们需要找到一个键名为<code>statues</code>的字典，其值为一个<code>tweets</code>数组。具体如何解析我们就不在此说明。这里给个更好的实现方式。</p>
<p>我们现在讲的是<code>ReactiveCocoa</code>及函数式编程。当我们使用函数式<code>API</code>时，数据从一种格式转换到另一种格式会变得更优雅。我们可以使用<a href="https://github.com/ColinEberhardt/LinqToObjectiveC" target="_blank" rel="external">LinqToObjectiveC</a>来执行这个任务。</p>
<p>我们需要使用<code>Cocoapods</code>来导入<code>LinqToObjectiveC</code>。在配置文件中加入以下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod 'LinqToObjectiveC', '2.0.0'</div></pre></td></tr></table></figure>
<p>关闭工程，在终端执行<code>pod update</code>命令，完成后在我们的<code>Pods</code>工程中就可以看到<code>LinqToObjectiveC</code>了。</p>
<p>打开<code>RWSearchFormViewController.m</code>并导入以下文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"RWTweet.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"NSArray+LinqExtensions.h"</span></span></div></pre></td></tr></table></figure>
<p><code>NSArray+LinqExtensions.h</code>头文件来自于<code>LinqToObjectiveC</code>，并为<code>NSArray</code>添加了许多方法以允许我们使用一个流畅的<code>API</code>来转换、排序、分组及过滤数组的数据。</p>
<p>现在我们使用这些<code>API</code>来更新当前管道操作，在<code>viewDidLoad</code>代码中做如下修改：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">[[[[[[<span class="keyword">self</span> requestAccessToTwitterSignal]</div><div class="line">     then:^RACSignal *&#123;</div><div class="line">         @strongify(<span class="keyword">self</span>)</div><div class="line">         <span class="keyword">return</span> <span class="keyword">self</span>.searchText.rac_textSignal;</div><div class="line">     &#125;]</div><div class="line">    filter:^<span class="built_in">BOOL</span>(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">        @strongify(<span class="keyword">self</span>)</div><div class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> isValidSearchText:text];</div><div class="line">    &#125;]</div><div class="line">   flattenMap:^RACStream *(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">       @strongify(<span class="keyword">self</span>)</div><div class="line">       <span class="keyword">return</span> [<span class="keyword">self</span> signalForSearchWithText:text];</div><div class="line">   &#125;]</div><div class="line">  deliverOn:[RACScheduler mainThreadScheduler]]</div><div class="line"> subscribeNext:^(<span class="built_in">NSDictionary</span> *jsonSearchResult) &#123;</div><div class="line">     <span class="built_in">NSArray</span> *statuses = jsonSearchResult[<span class="string">@"statuses"</span>];</div><div class="line">     <span class="built_in">NSArray</span> *tweets = [statuses linq_select:^<span class="keyword">id</span>(<span class="keyword">id</span> tweet) &#123;</div><div class="line">         <span class="keyword">return</span> [RWTweet tweetWithStatus:tweet];</div><div class="line">     &#125;];</div><div class="line">     [<span class="keyword">self</span>.resultsViewController displayTweets:tweets];</div><div class="line"> &#125; error:^(<span class="built_in">NSError</span> *error) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"An error occurred: %@"</span>, error);</div><div class="line"> &#125;];</div></pre></td></tr></table></figure>
<p>如上所看到的，<code>subscribeNext:</code>块首先获取<code>tweets</code>的<code>NSArray</code>对象。<code>linq_select</code>方法通过执行应用于每个数组元素的<code>block</code>来转换<code>NSDictionary</code>字典的数组，并生成一个<code>RWTweet</code>实例的数组。</p>
<p>一旦转换完成，<code>tweets</code>将结果发送给<code>ViewController</code>。</p>
<p>运行程序后我们可以看到以下<code>UI</code>：</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/FinallyWeSeeTweets.png" alt="image"></p>
<h2 id="异步加载图片"><a href="#异步加载图片" class="headerlink" title="异步加载图片"></a>异步加载图片</h2><p>在上图中，我们可以看到每行数据前面有一片空白，这是用来显示用户头像的。<code>RWTweet</code>类已经有一个<code>profileImageUrl</code>属性，它是一个图片的<code>URL</code>地址。为了让<code>UITableTable</code>滑动得更平滑，我们需要让获取指定<code>URL</code>的图片的操作不运行在主线程中。这可以使用<code>GCD</code>或者是<code>NSOperationQueue</code>。不过，<code>ReactiveCocoa</code>同样为我们提供了解决方案。</p>
<p>打开<code>RWSearchResultsViewController.m</code>，添加以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">-(RACSignal *)signalForLoadingImage:(<span class="built_in">NSString</span> *)imageUrl &#123;</div><div class="line">    </div><div class="line">    RACScheduler *scheduler = [RACScheduler</div><div class="line">                               schedulerWithPriority:RACSchedulerPriorityBackground];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> [[RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:[<span class="built_in">NSURL</span> URLWithString:imageUrl]];</div><div class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data];</div><div class="line">        [subscriber sendNext:image];</div><div class="line">        [subscriber sendCompleted];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;] subscribeOn:scheduler];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们应该熟悉这种模式了。以上的方法首先获取一个后台<code>scheduler</code>作为信号执行的线程，而不是主线程。接下来，创建一个下载图片数据的信号并在其有订阅者时创建一个<code>UIImage</code>。最后我们调用<code>subscribeOn:</code>，以确保信号在给定的<code>scheduler</code>上执行。</p>
<p>现在，我们可以更新<code>tableView:cellForRowAtIndex:</code>，在<code>return</code>之前添加以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cell.twitterAvatarView.image = <span class="literal">nil</span>;</div><div class="line"> </div><div class="line">[[[<span class="keyword">self</span> signalForLoadingImage:tweet.profileImageUrl]</div><div class="line">  deliverOn:[RACScheduler mainThreadScheduler]]</div><div class="line">  subscribeNext:^(<span class="built_in">UIImage</span> *image) &#123;</div><div class="line">   cell.twitterAvatarView.image = image;</div><div class="line">  &#125;];</div></pre></td></tr></table></figure>
<p>上面的代码首先重新设置图片，因为重用的单元格可能包含之前的数据。然后创建一个请求信号去获取数据，在<code>deliverOn:</code>中我们将后面的<code>next</code>事件运行在主线程，这样<code>subscribeNext:</code>可以安全运行。</p>
<p>运行后得到如下结果：</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/01/AvatarsAtAlast.png" alt="image"></p>
<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>你可能已经发现每次我们输入一个新的字符时，搜索操作都会立即执行。如果我们快速输入，可能会导致程序在一秒钟内执行了多次搜索操作。这当然是不好的，因为：</p>
<ol>
<li>我们多次调用了<code>Twitter</code>搜索<code>API</code>，同时扔掉了大部分结果。</li>
<li>我们不断更新结果会分散用户的注意力。</li>
</ol>
<p>一个更好的方案是如果搜索文本在一个较短时间内没有改变时我们再去执行搜索操作，如<code>500</code>毫秒。<code>ReactiveCocoa</code>框架让这一任务变得相当简单。</p>
<p>打开<code>RWSearchFormViewController.m</code>并更新管道操作：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">[[[[[[[<span class="keyword">self</span> requestAccessToTwitterSignal]</div><div class="line">      then:^RACSignal *&#123;</div><div class="line">          @strongify(<span class="keyword">self</span>)</div><div class="line">          <span class="keyword">return</span> <span class="keyword">self</span>.searchText.rac_textSignal;</div><div class="line">      &#125;]</div><div class="line">     filter:^<span class="built_in">BOOL</span>(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">         @strongify(<span class="keyword">self</span>)</div><div class="line">         <span class="keyword">return</span> [<span class="keyword">self</span> isValidSearchText:text];</div><div class="line">     &#125;]</div><div class="line">    throttle:<span class="number">0.5</span>]</div><div class="line">   flattenMap:^RACStream *(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">       @strongify(<span class="keyword">self</span>)</div><div class="line">       <span class="keyword">return</span> [<span class="keyword">self</span> signalForSearchWithText:text];</div><div class="line">   &#125;]</div><div class="line">  deliverOn:[RACScheduler mainThreadScheduler]]</div><div class="line"> subscribeNext:^(<span class="built_in">NSDictionary</span> *jsonSearchResult) &#123;</div><div class="line">     <span class="built_in">NSArray</span> *statuses = jsonSearchResult[<span class="string">@"statuses"</span>];</div><div class="line">     <span class="built_in">NSArray</span> *tweets = [statuses linq_select:^<span class="keyword">id</span>(<span class="keyword">id</span> tweet) &#123;</div><div class="line">         <span class="keyword">return</span> [RWTweet tweetWithStatus:tweet];</div><div class="line">     &#125;];</div><div class="line">     [<span class="keyword">self</span>.resultsViewController displayTweets:tweets];</div><div class="line"> &#125; error:^(<span class="built_in">NSError</span> *error) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"An error occurred: %@"</span>, error);</div><div class="line"> &#125;];</div></pre></td></tr></table></figure>
<p><code>throttle</code>操作只有在两次<code>next</code>事件间隔指定的时间时才会发送第二个<code>next</code>事件。相当简单吧。运行程序看看效果吧。    </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在庆祝胜利前，看看程序最终的管道是值得的。</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/01/CompletePipeline.png" alt="image"></p>
<p>这是一个相当复杂的数据流，但可以作为一个响应管道简洁地表示出来。看起来不错吧。如果使用非响应式技术，你会觉得这会有多复杂呢？在这样一个程序中，数据流的流动又会是多难以理解呢？听起来很麻烦吧。但有了<code>ReactiveCocoa</code>，我们不必再考虑这些了。现在我们知道<code>ReactiveCocoa</code>有多棒了吧。</p>
<p>最后，<code>ReactiveCocoa</code>让使用<code>Model View ViewModel(MVVM)</code>设计模式变成可能。如果有兴趣研究<code>MVVM</code>，可以去网上搜索相关的文章。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/08/02/reactivecocoa-tutorial-the-definitive-introduction-1/" itemprop="url">
                  ReactiveCocoa Tutorial – The Definitive Introduction: Part 1/2
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-08-02T23:03:12+08:00" content="2014-08-02">
              2014-08-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文由<code>Colin Eberhardt</code>发表于<code>raywenderlich</code>，<a href="http://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1" target="_blank" rel="external">ReactiveCocoa Tutorial – The Definitive Introduction: Part 1/2</a></p>
<p>在编写<code>iOS</code>代码时，我们的大部分代码都是在响应一些事件：按钮点击、接收网络消息、属性变化等等。但是这些事件在代码中的表现形式却不一样：如<code>target-action</code>、代理方法、<code>KVO</code>、回调或其它。<code>ReactiveCocoa</code>的目的就是定义一个统一的事件处理接口，这样它们可以非常简单地进行链接、过滤和组合。</p>
<p><code>ReactiveCocoa</code>结合了一些编程模式：</p>
<ol>
<li>函数式编程：利用高阶函数，即将函数作为其它函数的参数。</li>
<li>响应式编程：关注于数据流及变化的传播。</li>
</ol>
<p>基于以上两点，<code>ReactiveCocoa</code>被当成是函数响应编程(<code>Functional Reactive Programming, FRP</code>)框架。我们将在下面以实例来看看<code>ReactiveCocoa</code>的实用价值。</p>
<h2 id="Reactive-Playground实例"><a href="#Reactive-Playground实例" class="headerlink" title="Reactive Playground实例"></a>Reactive Playground实例</h2><p>虽然这是一篇指南性质的文章，但我们将以一个简单的实例来介绍<code>ReactiveCocoa</code>。可以在<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/01/ReactivePlayground-Starter.zip" target="_blank" rel="external">这里</a>下载源代码，然后编译并运行以确保程序可以运行。</p>
<p><code>ReactivePlayground</code>是个非常简单的应用，只有一个用户登录界面。只需要提供正确的用户名及密码，就可以显示一幅可爱的小猫的图片。如下图所示：</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/ReactivePlaygroundStarter.jpg" alt="image"></p>
<p>这个工程很简单，所以花几分钟来熟悉一下这个工程。打开<code>RWViewController.m</code>，可以快速查找一下如何设置<code>Sign in</code>按钮可用的代码，以及显示/隐藏<code>signInFailure Label</code>的规则。在简单的实现中，我们能快速定位这些问题，但如果实现很复杂，那可能需要花一些时间来分析代码。</p>
<p>现在，我们有了<code>ReactiveCocoa</code>，它能让代码变得更清晰。来看看它是怎么做到的吧。</p>
<h2 id="添加ReactiveCocoa框架"><a href="#添加ReactiveCocoa框架" class="headerlink" title="添加ReactiveCocoa框架"></a>添加ReactiveCocoa框架</h2><p>添加<code>ReactiveCocoa</code>框架到我们工程的最简单的方法是使用<code>Cocoapods</code>。我们先关闭<code>ReactivePlayground</code>工程。<code>Cocoapods</code>会创建一个<code>Xcode workspace</code>，它会替代我们的原始工程文件。</p>
<p>首先创建一个名为<code>Podfile</code>的空文件，打开并添加如下信息：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">platform :ios, '6.0'</div><div class="line">inhibit_all_warnings!</div><div class="line">xcodeproj 'RWReactivePlayground'</div><div class="line"></div><div class="line">target :RWReactivePlayground do</div><div class="line">    pod 'ReactiveCocoa', '~&gt; 2.3.1'</div><div class="line">end</div><div class="line"></div><div class="line">post_install do |installer|</div><div class="line">installer.project.targets.each do |target|</div><div class="line">puts "#&#123;target.name&#125;"</div><div class="line">end</div><div class="line">end</div></pre></td></tr></table></figure>
<p>配置完成后保存文件，打开终端并转到工程所在目录，然后输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod install</div></pre></td></tr></table></figure>
<p>然后终端会有如下输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Analyzing dependencies</div><div class="line">Downloading dependencies</div><div class="line">Installing ReactiveCocoa (2.3.1)</div><div class="line">Generating Pods project</div><div class="line">Pods-RWReactivePlayground-ReactiveCocoa</div><div class="line">Pods-RWReactivePlayground</div><div class="line">Integrating client project</div><div class="line"></div><div class="line">[!] From now on use `RWReactivePlayground.xcworkspace`.</div></pre></td></tr></table></figure>
<p>这表示已经下载了<code>ReactiveCocoa</code>框架，同时<code>Cocoapods</code>创建了一个<code>Xcode workspace</code>，同时将框架整合到了我们的工程中。打开新生成的<code>workspace</code>文件(<code>RWReactivePlayground.xcworkspace</code>)，将看到如下的工程结构：</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/AddedCocoaPods.png" alt="image"></p>
<p>我们看到有一个命名为<code>ReactivePlayground</code>的工程，这实际上是我们的初始工程，它依赖于<code>Pods</code>工程。做完这一切后，我们就可以开始玩了，哈哈。</p>
<h2 id="Time-to-Play"><a href="#Time-to-Play" class="headerlink" title="Time to Play"></a>Time to Play</h2><p>如上所述，<code>ReactiveCocoa</code>提供了一个标准的接口来处理不同的事件流。在<code>ReactiveCocoa</code>中，这些被统一称为信号，由<code>RACSignal</code>类表示。</p>
<p>打开程序的初始视图控制器<code>RWViewController.m</code>文件，在文件头部导入以下头文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;ReactiveCocoa/ReactiveCocoa.h&gt;</span></span></div></pre></td></tr></table></figure>
<p>我们暂时先不替换原来的代码，先看看如何使用<code>ReactiveCocoa</code>。在<code>viewDidLoad</code>方法中加入如下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.usernameTextField.rac_textSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>运行程序并在用户名输入框中键入”<code>reactive cocoa</code>“，我们可以看到控制台会有如下输出：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">30.890</span> RWReactivePlayground[<span class="number">9191</span>:<span class="number">60</span>b] r</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">32.007</span> RWReactivePlayground[<span class="number">9191</span>:<span class="number">60</span>b] re</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">32.289</span> RWReactivePlayground[<span class="number">9191</span>:<span class="number">60</span>b] rea</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">33.990</span> RWReactivePlayground[<span class="number">9191</span>:<span class="number">60</span>b] reac</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">34.889</span> RWReactivePlayground[<span class="number">9191</span>:<span class="number">60</span>b] react</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">35.557</span> RWReactivePlayground[<span class="number">9191</span>:<span class="number">60</span>b] reacti</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">36.022</span> RWReactivePlayground[<span class="number">9191</span>:<span class="number">60</span>b] reactiv</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">36.505</span> RWReactivePlayground[<span class="number">9191</span>:<span class="number">60</span>b] reactive</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">42.328</span> RWReactivePlayground[<span class="number">9191</span>:<span class="number">60</span>b] reactive </div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">47.223</span> RWReactivePlayground[<span class="number">9191</span>:<span class="number">60</span>b] reactive c</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">47.794</span> RWReactivePlayground[<span class="number">9191</span>:<span class="number">60</span>b] reactive co</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">48.191</span> RWReactivePlayground[<span class="number">9191</span>:<span class="number">60</span>b] reactive coc</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">48.657</span> RWReactivePlayground[<span class="number">9191</span>:<span class="number">60</span>b] reactive coco</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">49.141</span> RWReactivePlayground[<span class="number">9191</span>:<span class="number">60</span>b] reactive cocoa</div></pre></td></tr></table></figure>
<p>我们可以看到，每次在<code>text field</code>中输入时，都会执行<code>block</code>中的代码。没有<code>target-action</code>，没有代理，只有信号与<code>block</code>。是不是很棒？</p>
<p><code>ReactiveCocoa</code>信号发送一个事件流到它们的订阅者中。我们需要知道三种类型的事件：<code>next</code>, <code>error</code>和<code>completed</code>。一个信号可能由于<code>error</code>事件或<code>completed</code>事件而终止，在此之前它会发送很多个<code>next</code>事件。在这一部分中，我们将重点关注<code>next</code>事件。在学习关于<code>error</code>和<code>completed</code>事件前，请仔细阅读第二部分。</p>
<p><code>RACSignal</code>有许多方法用于订阅这些不同的事件类型。每个方法会有一个或多个<code>block</code>，每个<code>block</code>执行不同的逻辑处理。在上面这个例子中，我们看到<code>subscribeNext:</code>方法提供了一个响应<code>next</code>事件的<code>block</code>。</p>
<p><code>ReactiveCocoa</code>框架通过类别来为大部分标准<code>UIKit</code>控件添加信号，以便这些控件可以添加其相应事件的订阅，如上面的<code>UITextField</code>包含了<code>rac_textSignal</code>属性。</p>
<p>理论讲得差不多了，我们继续吧！！！</p>
<p><code>ReactiveCocoa</code>有大量的操作右用于处理事件流。例如，如果我们只对长度大于<code>3</code>的用户名感兴趣，则我们可以使用<code>filter</code>操作。在<code>viewDidLoad</code>中更新我们的代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[[<span class="keyword">self</span>.usernameTextField.rac_textSignal filter:^<span class="built_in">BOOL</span>(<span class="keyword">id</span> value) &#123;</div><div class="line">    <span class="built_in">NSString</span> *text = value;</div><div class="line">    <span class="keyword">return</span> text.length &gt; <span class="number">3</span>;</div><div class="line">&#125;] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>运行并在用户名输入框中输入<code>&quot;reactive cocoa&quot;</code>，我们可以看到控制台会有如下输出：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">52</span>:<span class="number">13.558</span> RWReactivePlayground[<span class="number">9249</span>:<span class="number">60</span>b] reac</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">52</span>:<span class="number">15.960</span> RWReactivePlayground[<span class="number">9249</span>:<span class="number">60</span>b] react</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">52</span>:<span class="number">16.589</span> RWReactivePlayground[<span class="number">9249</span>:<span class="number">60</span>b] reacti</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">52</span>:<span class="number">17.158</span> RWReactivePlayground[<span class="number">9249</span>:<span class="number">60</span>b] reactiv</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">52</span>:<span class="number">17.807</span> RWReactivePlayground[<span class="number">9249</span>:<span class="number">60</span>b] reactive</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">52</span>:<span class="number">18.674</span> RWReactivePlayground[<span class="number">9249</span>:<span class="number">60</span>b] reactive </div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">52</span>:<span class="number">19.176</span> RWReactivePlayground[<span class="number">9249</span>:<span class="number">60</span>b] reactive c</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">52</span>:<span class="number">19.710</span> RWReactivePlayground[<span class="number">9249</span>:<span class="number">60</span>b] reactive co</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">52</span>:<span class="number">20.057</span> RWReactivePlayground[<span class="number">9249</span>:<span class="number">60</span>b] reactive coc</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">52</span>:<span class="number">20.530</span> RWReactivePlayground[<span class="number">9249</span>:<span class="number">60</span>b] reactive coco</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">52</span>:<span class="number">20.978</span> RWReactivePlayground[<span class="number">9249</span>:<span class="number">60</span>b] reactive cocoa</div></pre></td></tr></table></figure>
<p>可以看到当长度小于<code>3</code>时，并不执行后续的操作。通过这种方式，我们创建了一个简单的管道。这就是响应式编程的实质，我们将我们程序的功能表示为数据流的形式。我们可以将上述调用表示为以下图例：</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/FilterPipeline.png" alt="image"></p>
<p>从上图中我们可以看到<code>rac_textSignal</code>是事件的初始源头。通过<code>filter</code>的数据流只有在其长度大于3时，才会被传递到下一处理流程中。管道的最后一步是<code>subscribeNext:</code>，在这个<code>block</code>中，我们记录日志。</p>
<p>在这里需要注意的是<code>filter</code>操作的输出仍然是一个<code>RACSignal</code>对象。我们可以将上面这段管道处理拆分成如下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">RACSignal *usernameSourceSignal = <span class="keyword">self</span>.usernameTextField.rac_textSignal;</div><div class="line"></div><div class="line">RACSignal *filteredUsername = [usernameSourceSignal filter:^<span class="built_in">BOOL</span>(<span class="keyword">id</span> value) &#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSString</span> *text = value;</div><div class="line">    <span class="keyword">return</span> text.length &gt; <span class="number">3</span>;</div><div class="line">&#125;];</div><div class="line"></div><div class="line">[filteredUsername subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>因为<code>RACSignal</code>对象的每个操作都返回一个<code>RACSignal</code>对象，所以我们不需要使用变量就可以构建一个管道。</p>
<h2 id="事件是什么"><a href="#事件是什么" class="headerlink" title="事件是什么"></a>事件是什么</h2><p>目前为止，我们已经描述了<code>3</code>种不同的事件类型，但还没有深入这些事件的结构。有趣的是，事件可以包含任何东西。为了证明这一点，我们在上面的管道中加入另一个操作。更新我们的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[[[<span class="keyword">self</span>.usernameTextField.rac_textSignal map:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">    <span class="keyword">return</span> @(text.length);</div><div class="line"> &#125;]</div><div class="line"> filter:^<span class="built_in">BOOL</span>(<span class="built_in">NSNumber</span> *length) &#123;</div><div class="line">     <span class="keyword">return</span> [length intValue] &gt; <span class="number">3</span>;</div><div class="line"> &#125;]</div><div class="line"> subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</div><div class="line"> &#125;];</div></pre></td></tr></table></figure>
<p>编译并运行，我们会发现控制台输出如下信息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">16</span>:<span class="number">13</span>:<span class="number">47.652</span> RWReactivePlayground[<span class="number">9321</span>:<span class="number">60</span>b] <span class="number">4</span></div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">16</span>:<span class="number">13</span>:<span class="number">47.819</span> RWReactivePlayground[<span class="number">9321</span>:<span class="number">60</span>b] <span class="number">5</span></div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">16</span>:<span class="number">13</span>:<span class="number">47.985</span> RWReactivePlayground[<span class="number">9321</span>:<span class="number">60</span>b] <span class="number">6</span></div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">16</span>:<span class="number">13</span>:<span class="number">48.134</span> RWReactivePlayground[<span class="number">9321</span>:<span class="number">60</span>b] <span class="number">7</span></div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">16</span>:<span class="number">13</span>:<span class="number">48.284</span> RWReactivePlayground[<span class="number">9321</span>:<span class="number">60</span>b] <span class="number">8</span></div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">16</span>:<span class="number">13</span>:<span class="number">48.417</span> RWReactivePlayground[<span class="number">9321</span>:<span class="number">60</span>b] <span class="number">9</span></div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">16</span>:<span class="number">13</span>:<span class="number">48.583</span> RWReactivePlayground[<span class="number">9321</span>:<span class="number">60</span>b] <span class="number">10</span></div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">16</span>:<span class="number">13</span>:<span class="number">48.734</span> RWReactivePlayground[<span class="number">9321</span>:<span class="number">60</span>b] <span class="number">11</span></div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">16</span>:<span class="number">13</span>:<span class="number">48.883</span> RWReactivePlayground[<span class="number">9321</span>:<span class="number">60</span>b] <span class="number">12</span></div></pre></td></tr></table></figure>
<p>新添加的<code>map</code>操作使用提供的<code>block</code>来转换事件数据。对于收到的每一个<code>next</code>事件，都会运行给定的<code>block</code>，并将返回值作为<code>next</code>事件发送。在上面的代码中，<code>map</code>操作获取一个<code>NSString</code>输入，并将其映射为一个<code>NSNumber</code>对象，并返回。下图演示了这个管道处理：</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/01/FilterAndMapPipeline.png" alt="image"></p>
<p>我们可以看到，<code>map</code>操作后的每一步接收的都是一个<code>NSNumber</code>对象。我们可以使用<code>map</code>操作来转换我们想要的数据，只需要它是一个对象。</p>
<p>OK，是时候修改<code>ReactivePlayground</code>应用的代码了。</p>
<h2 id="创建有效的状态信号"><a href="#创建有效的状态信号" class="headerlink" title="创建有效的状态信号"></a>创建有效的状态信号</h2><p>我们要做的第一件事就是创建一对信号来校验用户名与密码的输入是否有效。添加如下代码到<code>RWViewController.m</code>的<code>viewDidLoad</code>中。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">RACSignal *validUsernameSignal = [<span class="keyword">self</span>.usernameTextField.rac_textSignal map:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">    <span class="keyword">return</span> @([<span class="keyword">self</span> isValidUsername:text]);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">RACSignal *validPasswordSignal = [<span class="keyword">self</span>.passwordTextField.rac_textSignal map:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">    <span class="keyword">return</span> @([<span class="keyword">self</span> isValidPassword:text]);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>我们使用将<code>map</code>操作应用于文本输入框的<code>rac_textSignal</code>，输出是一个<code>NSNumber</code>对象。接着将转换这些信号，以便其可以为文本输入框提供一个合适的背影颜色。我们可以订阅这个信号并使用其结果来更新文本输入框的颜色。可以如下操作：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[validPasswordSignal map:^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> *passwordValid) &#123;</div><div class="line">    <span class="keyword">return</span> [passwordValid boolValue] ? [<span class="built_in">UIColor</span> clearColor] : [<span class="built_in">UIColor</span> yellowColor];</div><div class="line">&#125;] subscribeNext:^(<span class="built_in">UIColor</span> *color) &#123;</div><div class="line">    <span class="keyword">self</span>.passwordTextField.backgroundColor = color;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>从概念上讲，我们将信号的输出值赋值给文本输入框的<code>backgroundColor</code>属性。但是这段代码有点糟糕。我们可以以另外一种方式来做相同的处理。这得益于<code>ReactiveCocoa</code>定义的一些宏。如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">RAC(<span class="keyword">self</span>.passwordTextField, backgroundColor) = [validPasswordSignal map:^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> *passwordValid) &#123;</div><div class="line">    <span class="keyword">return</span> [passwordValid boolValue] ? [<span class="built_in">UIColor</span> clearColor] : [<span class="built_in">UIColor</span> yellowColor];</div><div class="line">&#125;];</div><div class="line"></div><div class="line">RAC(<span class="keyword">self</span>.usernameTextField, backgroundColor) = [validUsernameSignal map:^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> *passwordValid) &#123;</div><div class="line">    <span class="keyword">return</span> [passwordValid boolValue] ? [<span class="built_in">UIColor</span> clearColor] : [<span class="built_in">UIColor</span> yellowColor];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p><code>RAC</code>宏我们将信号的输入值指派给对象的属性。它带有两个参数，第一个参数是对象，第二个参数是对象的属性名。每次信号发送下一个事件时，其输出值都会指派给给定的属性。这是个非常优雅的解决方案，对吧？</p>
<p>在运行前，我们先找到<code>updateUIState</code>方法，并注释掉下面两行代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.usernameTextField.backgroundColor = <span class="keyword">self</span>.usernameIsValid ? [<span class="built_in">UIColor</span> clearColor] : [<span class="built_in">UIColor</span> yellowColor];</div><div class="line"><span class="keyword">self</span>.passwordTextField.backgroundColor = <span class="keyword">self</span>.passwordIsValid ? [<span class="built_in">UIColor</span> clearColor] : [<span class="built_in">UIColor</span> yellowColor];</div></pre></td></tr></table></figure>
<p>运行程序，我们可以看到当输入无效时文本输入框是高亮的，有效时则清除高亮。在这里，我们可以看到两条带有文本信号的简单的管道，都是将它们映射到标明是否有效的布尔对象，然后再映射到<code>UIColor</code>对象。如下图所示：</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/01/TextFieldValidPipeline.png" alt="image"></p>
<h2 id="组合信号"><a href="#组合信号" class="headerlink" title="组合信号"></a>组合信号</h2><p>在当前的程序中，<code>Sign in</code>按钮只有在两个输入框都有效时才可点击。是时候处理这个响应了。</p>
<p>当前代码有两个信号来标识用户名和密码是否有效：<code>validUsernameSignal</code>和<code>validPasswordSignal</code>。我们的任务是要组合这两个信号，来确定按钮是否可用。</p>
<p>在<code>viewDidLoad</code>中添加下面的代码</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">RACSignal *signUpActiveSignal = [RACSignal combineLatest:@[validUsernameSignal, validPasswordSignal]</div><div class="line">                                                  reduce:^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> *usernameValid, <span class="built_in">NSNumber</span> *passwordValid)&#123;</div><div class="line"></div><div class="line">                                                      <span class="keyword">return</span> @([usernameValid boolValue] &amp;&amp; [passwordValid boolValue]);</div><div class="line">                                                  &#125;];</div></pre></td></tr></table></figure>
<p>上面的代码使用了<code>combineLatest:reduce:</code>方法来组合<code>validUsernameSignal</code>与<code>validPasswordSignal</code>最后输出的值，并生成一个新的信号。每次两个源信号中的一个输出新值时，<code>reduce</code>块都会被执行，而返回的值会作为组合信号的下一个值。</p>
<p><em>注意：<code>RACSignal</code>组合方法可以组合任何数量的信号，而<code>reduce</code>块的参数会对应每一个信号。</em></p>
<p>现在我们已以有了一个合适的信号，接着在<code>viewDidLoad</code>结尾中添加以下代码，这将信号连接到按钮的<code>enabled</code>属性。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[signUpActiveSignal subscribeNext:^(<span class="built_in">NSNumber</span> *signupActive) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">self</span>.signInButton.enabled = [signupActive boolValue];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>同样，在运行前移除以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> passwordIsValid;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> usernameIsValid;</div></pre></td></tr></table></figure>
<p>同时移除<code>viewDidLoad</code>中以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.usernameTextField addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(usernameTextFieldChanged) forControlEvents:<span class="built_in">UIControlEventEditingChanged</span>];</div><div class="line">[<span class="keyword">self</span>.passwordTextField addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(passwordTextFieldChanged) forControlEvents:<span class="built_in">UIControlEventEditingChanged</span>];</div></pre></td></tr></table></figure>
<p>当然我们还需要移除<code>updateUIState</code>, <code>usernameTextFieldChanged</code>和<code>passwordTextFieldChanged</code>方法及相关的调用。瞧，我们已经删除了不少代码了。感谢自己吧！</p>
<p>运行，并检查<code>Sign in</code>按钮。如同之前一下，如果用户名和密码都有效，则按钮是可用的。</p>
<p>更新后程序的逻辑如下图所示：</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/CombinePipeline.png" alt="image"></p>
<p>上面我们已经用<code>ReactiveCocoa</code>实现了一些非常棒的功能，它包含了两个重要的概念：</p>
<ol>
<li><code>Spliting</code>: 信号可以有多个订阅者，且作为资源服务于序列化管道的多个步骤。</li>
<li><code>Combining</code>: 多个信号可以组合起来创建新的信号。</li>
</ol>
<p>在上面的程序中，这些改变让程序不再需要私有属性，来标明两个输入域的有效状态。这是使用响应式编程的关键区别–我们不需要使用实例变量来跟踪短暂的状态。</p>
<h2 id="响应Sign-in"><a href="#响应Sign-in" class="headerlink" title="响应Sign-in"></a>响应Sign-in</h2><p>程序目前使用了响应式管道来管理输入框与按钮的状态。按钮的点击操作仍然使用<code>target-action</code>。所以，这是我们下一步的目标。</p>
<p>Sign-in按钮的<code>Touch Up Inside</code>事件通过<code>storyboard action</code>连接到<code>RWViewController.m</code>的<code>signInButtonTouched</code>方法中。我们现在使用响应式方法来替换它，所以第一步我们需要解除当前<code>storyboard action</code>的连接。这个自己处理吧。</p>
<p>为了处理按钮事件，我们需要使用<code>ReactiveCocoa</code>添加到<code>UIKit</code>的另一个方法：<code>rac_signalForControlEvents</code>。我们在<code>viewDidLoad</code>结尾加入以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[[<span class="keyword">self</span>.signInButton rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Button clicked"</span>);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>上面的代码从按钮的<code>UIControlEventTouchUpInside</code>事件中创建一个信号，并添加订阅以在每次事件发生时添加日志。</p>
<p>运行程序，当按钮可点时点击按钮，会记录以下日志：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">17</span>:<span class="number">45</span>:<span class="number">43.660</span> RWReactivePlayground[<span class="number">9617</span>:<span class="number">60</span>b] Button clicked</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">17</span>:<span class="number">45</span>:<span class="number">44.493</span> RWReactivePlayground[<span class="number">9617</span>:<span class="number">60</span>b] Button clicked</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">17</span>:<span class="number">45</span>:<span class="number">44.660</span> RWReactivePlayground[<span class="number">9617</span>:<span class="number">60</span>b] Button clicked</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">17</span>:<span class="number">45</span>:<span class="number">44.810</span> RWReactivePlayground[<span class="number">9617</span>:<span class="number">60</span>b] Button clicked</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">17</span>:<span class="number">45</span>:<span class="number">44.944</span> RWReactivePlayground[<span class="number">9617</span>:<span class="number">60</span>b] Button clicked</div></pre></td></tr></table></figure>
<p>现在点击事件有一个信号了，接下来将信号与登录处理连接起来。打开<code>RWDummySignInService.h</code>文件，我们会看到下面的接口：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^RWSignInResponse)(<span class="built_in">BOOL</span>);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWDummySignInService</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)signInWithUsername:(<span class="built_in">NSString</span> *)username password:(<span class="built_in">NSString</span> *)password complete:(RWSignInResponse)completeBlock;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这个方法带有一个用户名、密码和一个完成<code>block</code>。<code>block</code>会在登录成功或失败时调用。我们可以在<code>subscribeNext:</code>块中直接调用这个方法，但为什么不呢？因为这是一个异步操作，小心了。</p>
<h2 id="创建信号"><a href="#创建信号" class="headerlink" title="创建信号"></a>创建信号</h2><p>幸运的是，将一个已存在的异步<code>API</code>表示为一个信号相当简单。我们来看看。</p>
<p>首先，从<code>RWViewController.m</code>移除当前的<code>signInButtonTouched:</code>方法。我们通过响应式编程来取代它。</p>
<p>在<code>RWViewController.m</code>中添加以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (RACSignal *)signInSignal</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line">        [<span class="keyword">self</span>.signInService signInWithUsername:<span class="keyword">self</span>.usernameTextField.text</div><div class="line">                                      password:<span class="keyword">self</span>.passwordTextField.text</div><div class="line">                                      complete:^(<span class="built_in">BOOL</span> success) &#123;</div><div class="line">                                          [subscriber sendNext:@(success)];</div><div class="line">                                          [subscriber sendCompleted];</div><div class="line">                                      &#125;];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码创建了一个使用当前用户名与密码登录的信号。现在我们来分解一下这个方法。<code>createSignal:</code>方法用于创建一个信号。描述信号的<code>block</code>是一个信号参数，当信号有一个订阅者时，<code>block</code>中的代码会被执行。</p>
<p><code>block</code>传递一个实现<code>RACSubscriber</code>协议的<code>subscriber</code>(订阅者)，这个订阅者包含我们调用的用于发送事件的方法；我们也可以发送多个<code>next</code>事件，这些事件由一个<code>error</code>事件或<code>complete</code>事件结束。在上面这种情况下，它发送一个<code>next</code>事件来表示登录是否成功，后续是一个<code>complete</code>事件。</p>
<p>这个<code>block</code>的返回类型是一个<code>RACDisposable</code>对象，它允许我们执行一些清理任务，这些操作可能发生在订阅取消或丢弃时。上面这个这个信号没有任何清理需求，所以返回<code>nil</code>。</p>
<p>可以看到，我们就这样在信号中封装了一个异步<code>API</code>。现在，我们可以使用这个新的信号了，更新<code>viewDidLoad</code>中我们的代码吧：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[[<span class="keyword">self</span>.signInButton rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>] map:^<span class="keyword">id</span>(<span class="keyword">id</span> value) &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> signInButton];</div><div class="line">&#125;] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Sign in result: %@"</span>, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>上面的代码使用<code>map</code>方法将按钮点击信号转换为登录信号。订阅者简单输出了结果。</p>
<p>运行程序，点击按钮，可以看到以下输出：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">18</span>:<span class="number">29</span>:<span class="number">27.134</span> RWReactivePlayground[<span class="number">9749</span>:<span class="number">60</span>b] Sign <span class="keyword">in</span> result: &lt;<span class="built_in">UIButton</span>: <span class="number">0x13651ed40</span>; frame = (<span class="number">192</span> <span class="number">201</span>; <span class="number">76</span> <span class="number">30</span>); opaque = <span class="literal">NO</span>; autoresize = RM+BM; layer = &lt;<span class="built_in">CALayer</span>: <span class="number">0x178224c00</span>&gt;&gt;</div></pre></td></tr></table></figure>
<p>可以看到<code>subscribeNext:</code>块传递了一个正确的信号，但结果不是登录信号。我们用图来展示这个管道操作：</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/SignalOfSignals.png" alt="image"></p>
<p>当点击按钮时<code>rac_signalForControlEvents</code>发出了一个<code>next</code>事件。<code>map</code>这一步创建并返回一个登录信号，意味着接下来的管理接收一个<code>RACSignal</code>。这是我们在<code>subscribeNext:</code>中观察到的对象。</p>
<p>上面这个方案有时候称为信号的信号(<code>signal of signals</code>)，换句话说，就是一个外部信号包含一个内部信号。可以在输出信号的<code>subscribeNext:</code>块中订阅内部信号。但这会引起嵌套的麻烦。幸运的是，这是个普遍的问题，而<code>ReactiveCocoa</code>已经提供了解决方案。</p>
<h2 id="Signal-of-Signals"><a href="#Signal-of-Signals" class="headerlink" title="Signal of Signals"></a>Signal of Signals</h2><p>这个问题有解决方案是直观的，只需要使用<code>flattenMap</code>来替换<code>map</code>。如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[[<span class="keyword">self</span>.signInButton rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>] flattenMap:^RACStream *(<span class="keyword">id</span> value) &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> signInSignal];</div><div class="line">&#125;] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Sign in result: %@"</span>, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>这将按钮点击事件映射到一个登录信号，但同时通过将事件从内部信号发送到外部信号，使这个过程变得扁平化。再次运行程序，我们将得到以下的输出</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">18</span>:<span class="number">46</span>:<span class="number">19.535</span> RWReactivePlayground[<span class="number">9785</span>:<span class="number">60</span>b] Sign <span class="keyword">in</span> result: <span class="number">1</span></div></pre></td></tr></table></figure>
<p>这回对了。</p>
<p>现在管道处理得到了我们想要的结果，最后我们在<code>subscriptNext</code>中添加登录处理逻辑。使用以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[[[<span class="keyword">self</span>.signInButton rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>] flattenMap:^RACStream *(<span class="keyword">id</span> value) &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> signInSignal];</div><div class="line">&#125;] subscribeNext:^(<span class="built_in">NSNumber</span> *signedIn) &#123;</div><div class="line"></div><div class="line">    <span class="built_in">BOOL</span> success = [signedIn boolValue];</div><div class="line">    <span class="keyword">self</span>.signInFailureText.hidden = success;</div><div class="line">    <span class="keyword">if</span> (success)</div><div class="line">    &#123;</div><div class="line">        [<span class="keyword">self</span> performSegueWithIdentifier:<span class="string">@"signInSuccess"</span> sender:<span class="keyword">self</span>];</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>运行程序，我们就可以得到下面的结果了：</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/ReactivePlaygroundStarter.jpg" alt="image"></p>
<p>不知道你是否注意到一个细节问题。当点击登录进行验证时，我们应该置灰登录按钮。这样可以阻止用户在验证的过程中再次去点击登录。那么这个逻辑添加在哪呢？改变按钮的可用状态不是个转换、过滤或其它的信号。这就是下一步要讲的。</p>
<h2 id="添加附加操作-side-effects"><a href="#添加附加操作-side-effects" class="headerlink" title="添加附加操作(side-effects)"></a>添加附加操作(side-effects)</h2><p>使用下面的代码替换当前管道：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[[[[<span class="keyword">self</span>.signInButton rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>]</div><div class="line"> doNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">     <span class="keyword">self</span>.signInButton.enabled = <span class="literal">NO</span>;</div><div class="line">     <span class="keyword">self</span>.signInFailureText.hidden = <span class="literal">YES</span>;</div><div class="line"> &#125;]</div><div class="line"> flattenMap:^RACStream *(<span class="keyword">id</span> value) &#123;</div><div class="line">     <span class="keyword">return</span> [<span class="keyword">self</span> signInSignal];</div><div class="line"> &#125;]</div><div class="line"> subscribeNext:^(<span class="built_in">NSNumber</span> *signedIn) &#123;</div><div class="line">     <span class="keyword">self</span>.signInButton.enabled = <span class="literal">YES</span>;</div><div class="line">     <span class="built_in">BOOL</span> success = [signedIn boolValue];</div><div class="line">     <span class="keyword">self</span>.signInFailureText.hidden = success;</div><div class="line">     <span class="keyword">if</span> (success) &#123;</div><div class="line">         [<span class="keyword">self</span> performSegueWithIdentifier:<span class="string">@"signInSuccess"</span> sender:<span class="keyword">self</span>];</div><div class="line">     &#125;</div><div class="line"> &#125;];</div></pre></td></tr></table></figure>
<p>我们可以看到在按钮点击事件后添加了<code>doNext:</code>步骤。注意<code>doNext:</code>并不返回一个值，因为它是附加操作。它完成时不改变事件。下图展示了这个过程：</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/SideEffects.png" alt="image"></p>
<p>运行程序看看效果。如何？</p>
<p>注意：在执行异步方法时禁用按钮是个普遍的问题，<code>ReactiveCocoa</code>同样解决了这个问题。<strong>RACCommand</strong>类封装了这个概念，同时有一个<code>enabled</code>信号以允许我们将一个按钮的<code>enabled</code>属性连接到信号。可以试试。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>ReactiveCocoa</code>的核心是信号，它是一个事件流。使用<code>ReactiveCocoa</code>时，对于同一个问题，可能会有多种不同的方法来解决。<code>ReactiveCocoa</code>的目的就是为了简化我们的代码并更容易理解。如果使用一个清晰的管道，我们可以很容易理解问题的处理过程。在下一部分，我们将会讨论错误事件的处理及完成事件的处理。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="南峰子" />
          <p class="site-author-name" itemprop="name">南峰子</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">83</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">南峰子</span>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1000523916'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1000523916%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
  </script>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  
  

  <div style="display: none;">
    <script src="http://s95.cnzz.com/z_stat.php?id=1000523916&web_id=1000523916" language="JavaScript"></script>
  </div>




</body>
</html>

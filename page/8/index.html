<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="南峰子的技术博客">
<meta property="og:url" content="http://southpeak.github.io/page/8/index.html">
<meta property="og:site_name" content="南峰子的技术博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="南峰子的技术博客">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://southpeak.github.io/page/8/"/>

  <title> 南峰子的技术博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-68856508-1', 'auto');
  ga('send', 'pageview');
</script>







  <div style="display: none;">
    <script src="http://s95.cnzz.com/z_stat.php?id=1000523916&web_id=1000523916" language="JavaScript"></script>
  </div>





  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">南峰子的技术博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">攀登，一步一个脚印，方能知其乐</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-techset">
          <a href="/categories/techset" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-fighter-jet"></i> <br />
            
            知识小集
          </a>
        </li>
      
        
        <li class="menu-item menu-item-swift">
          <a href="/categories/swift" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-space-shuttle"></i> <br />
            
            Swift
          </a>
        </li>
      
        
        <li class="menu-item menu-item-objectivec">
          <a href="/categories/objectivec" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-taxi"></i> <br />
            
            Objective-C
          </a>
        </li>
      
        
        <li class="menu-item menu-item-cocoa">
          <a href="/categories/cocoa" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-subway"></i> <br />
            
            Cocoa
          </a>
        </li>
      
        
        <li class="menu-item menu-item-translate">
          <a href="/categories/translate" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-rocket"></i> <br />
            
            翻译
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sourcecode">
          <a href="/categories/sourcecode" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-train"></i> <br />
            
            源码分析
          </a>
        </li>
      
        
        <li class="menu-item menu-item-something">
          <a href="/categories/something" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-bicycle"></i> <br />
            
            杂项
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/07/15/url-load-system-3/" itemprop="url">
                  URL加载系统之三：NSURLConnection
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-07-15T18:37:44+08:00" content="2014-07-15">
              2014-07-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>NSURLConnection提供了简单的接口来创建和取消一个连接，并支持一个代理方法的集合来提供连接的响应，并对连接进行多方面的控制。这个类的方法可以分为5大类：URL加载、缓存管理、认证与证书、cookie存储、协议支持。</p>
<h2 id="创建一个连接"><a href="#创建一个连接" class="headerlink" title="创建一个连接"></a>创建一个连接</h2><p>NSURLConnection提供了三种方式来获取URL的内容：同步、异步使用完成处理器block、异步使用自定义的代理对象。</p>
<ol>
<li>使用同步请求时，一般是在后台线程中独占线程运行，我们可以调用sendSynchronousRequest:returningResponse:error: 方法来执行HTTP请求。当请求完成或返回错误时，该方法会返回。</li>
<li>如果我们不需要监听请求的状态，而只是在数据完成返回时执行一些操作，则可以调用sendAsynchronousRequest:queue:completionHandler:方法来执行一个异步操作，其中需要传递一个block来处理结果。</li>
<li>我们也可以创建一个代理对象来处理异步请求，此时我们需要实现以下方法：connection:didReceiveResponse:、connection:didReceiveData:、connection:didFailWithError:和connectionDidFinishLoading: 。这些方法在NSURLConnectionDelegate、NSURLConnectionDownloadDelegate和 NSURLConnectionDataDelegate协议中定义。</li>
</ol>
<p>代码清单1以代理对象异步请求为例，初始化了一个URL连接并实现代理方法来处理连接响应</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Conn</span> : <span class="title">NSObject</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSURLConnection</span> *theConnection;</div><div class="line">    <span class="built_in">NSMutableData</span> *receivedData;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Conn</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)createConnection</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 创建一个请求</span></div><div class="line">    <span class="built_in">NSURLRequest</span> *theRequest=[<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.apple.com/"</span>]</div><div class="line">                                              cachePolicy:<span class="built_in">NSURLRequestUseProtocolCachePolicy</span></div><div class="line">                                          timeoutInterval:<span class="number">60.0</span>];</div><div class="line">    </div><div class="line">    <span class="comment">// 创建NSMutableData来保存接收到的数据</span></div><div class="line">    receivedData = [<span class="built_in">NSMutableData</span> dataWithCapacity: <span class="number">0</span>];</div><div class="line">    </div><div class="line">    <span class="comment">// 使用theRequest创建一个连接并开始加载数据</span></div><div class="line">    <span class="comment">// 调用initWithRequest:delegate后会立即开始传输</span></div><div class="line">    <span class="comment">// 请求可以在connectionDidFinishLoading:或connection:didFailWithError:消息被发送前通过调用cancel来取消</span></div><div class="line">    theConnection = [[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:theRequest delegate:<span class="keyword">self</span>];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!theConnection) &#123;</div><div class="line">        <span class="comment">// 释放receivedData对象</span></div><div class="line">        receivedData = <span class="literal">nil</span>;</div><div class="line">        <span class="comment">// 通知用户连接失败</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 当服务端提供了有效的数据来创建NSURLResponse对象时，代理会收到connection:didReceiveResponse:消息。</span></div><div class="line"><span class="comment">// 这个代理方法会检查NSURLResponse对象并确认数据的content-type，MIME类型，文件 名和其它元数据。</span></div><div class="line"><span class="comment">// 需要注意的是，对于单个连接，我们可能会接多次收到connection:didReceiveResponse:消息；这咱情况发生在</span></div><div class="line"><span class="comment">// 响应是多重MIME编码的情况下。每次代理接收到connection:didReceiveResponse:时，应该重设进度标识</span></div><div class="line"><span class="comment">// 并丢弃之前接收到的数据。</span></div><div class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</div><div class="line">&#123;</div><div class="line">    [receivedData setLength:<span class="number">0</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 代理会定期接收到connection:didReceiveData:消息，该消息用于接收服务端返回的数据实体。该方法负责存储数据。</span></div><div class="line"><span class="comment">// 我们也可以用这个方法提供进度信息，这种情况下，我们需要在connection:didReceiveResponse:方法中</span></div><div class="line"><span class="comment">// 调用响应对象的expectedContentLength方法来获取数据的总长度。</span></div><div class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data</div><div class="line">&#123;</div><div class="line">    [receivedData appendData:data];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 如果数据传输的过程中出现了错误，代理会接收到connection:didFailWithError:消息。其中error参数给出了错误信息。</span></div><div class="line"><span class="comment">// 在代理收到connection:didFailWithError:消息后，它不会再接收指定连接的代理消息。</span></div><div class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didFailWithError:(<span class="built_in">NSError</span> *)error</div><div class="line">&#123;</div><div class="line">    theConnection = <span class="literal">nil</span>;</div><div class="line">    receivedData = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Connection failed! Error - %@ %@"</span>, [error localizedDescription], [[error userInfo] objectForKey:<span class="built_in">NSURLErrorFailingURLStringErrorKey</span>]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 如果成功获取服务端返回的所有数据，则代理会收到connectionDidFinishLoading:消息。</span></div><div class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Succeeded! Receive %lu bytes of data(unsigned long)"</span>,[receivedData length]);</div><div class="line"></div><div class="line">    theConnection = <span class="literal">nil</span>;</div><div class="line">    receivedData = <span class="literal">nil</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h2 id="发起一个POST请求"><a href="#发起一个POST请求" class="headerlink" title="发起一个POST请求"></a>发起一个POST请求</h2><p>我们可以像发起其它URL请求一样，发起一个HTTP或HTTPS POST请求。主要的区别在于我们必须先配置好NSMutableURLRequest对象，并将其作为参数传递给initWithRequest:delegate:方法。</p>
<p>另外，我们还需要构造请求的body数据。可以以下面三种方式来处理</p>
<ol>
<li>对于上传短小的内存数据，我们需要对已存在的数据块进行URL编码</li>
<li>如果是从磁盘中上传文件，则调用setHTTPBodyStream:方法来告诉NSMutableURLRequest从一个NSInputStream中读取并使用结果数据作为body的内容</li>
<li>对于大块的数据，调用CFStreamCreateBoundPair来创建流对象对，然后调用setHTTPBodyStream:方法来告诉NSMutableURLRequest使用这些流对象中的一个作为body内容的源。通过将数据写入其它流，可以一次发送一小块数据。</li>
</ol>
<p>如果要上传数据到一个兼容的服务器中，URL加载系统同样支持100（继续）状态码，这样允许一个上传操作在发生认证错误或其它失败时仍能继续。为了开启这个操作，可以设置请求对象的expect头为100-continue。</p>
<p>代码清单2展示了如何配置一个POST请求的NSMutableURLRequest对象</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setRequestForPost</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 对于application/x-www-form-urlencoded类型的body数据，form域的参数由&amp;号分开，</span></div><div class="line">    <span class="built_in">NSString</span> *bodyData = <span class="string">@"name=Jane+Doe&amp;address=123+Main+St"</span>;</div><div class="line">    <span class="built_in">NSMutableURLRequest</span> *postRequest = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://www.apple.com"</span>]];</div><div class="line">    </div><div class="line">    <span class="comment">// 设置content-type为application/x-www-form-urlencoded</span></div><div class="line">    [postRequest setValue:<span class="string">@"application/x-www-form-urlencoded"</span> forHTTPHeaderField:<span class="string">@"Content-Type"</span>];</div><div class="line">    </div><div class="line">    <span class="comment">// 指定请求方法为POST</span></div><div class="line">    [postRequest setHTTPMethod:<span class="string">@"POST"</span>];</div><div class="line">    [postRequest setHTTPBody:[<span class="built_in">NSData</span> dataWithBytes:[bodyData UTF8String] length:strlen([bodyData UTF8String])]];</div><div class="line">    </div><div class="line">    <span class="comment">// Initialize the NSURLConnection and proceed as described in</span></div><div class="line">    <span class="comment">// Retrieving the Contents of a URL</span></div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="使用Block来接收数据"><a href="#使用Block来接收数据" class="headerlink" title="使用Block来接收数据"></a>使用Block来接收数据</h2><p>NSURLConnection类提供了类方法sendAsynchronousRequest:queue:completionHandler:，该方法可以以异常的方式向服务端发起请求，并在数据返回或发生错误/超时时调用block来处理。该方法需要一个请求对象，一个完成处理block，及block运行的队列。当请求完成或错误发生时，URL加载系统调用该block来处理结果数据或错误信息。</p>
<p>如果请求成功，则会传递一个NSData对象和一个NSURLResponse对象给block。如果失败，则传递一个NSError对象。</p>
<p>这个方法有两个限制</p>
<ol>
<li>对于需要认证的请求，只提供最小的支持。</li>
<li>没有办法来修改响应缓存和服务端重定向的默认行为。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html" target="_blank" rel="external">URL Loading System Programming Guide</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/07/11/url-load-system-2/" itemprop="url">
                  URL加载系统之二：NSURLSession
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-07-11T22:48:27+08:00" content="2014-07-11">
              2014-07-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>NSURLSession及相关的类提供通过HTTP协议下载数据的API。该类提供了大量代理方法来支持认证和后台下载(程序未运行或挂起时)功能。</p>
<p>为了使用NSURLSession，我们的应用会创建一系列的会话，每个会话负责协调一组相关数据的传输任务。在每个会话中，我们的应用添加一系列的任务，每个任务都表示一个对指定URL的请求。与大多数网络API一样，NSURLSession  API是异步的。如果我们使用系统提供的代理，我们必须提供一个请求完成处理block，以便在请求成功或失败时返回数据给我们的应用。如果我们提供自定义的代理对象，则任务对象调用这些代理方法，并回传从服务端获取的数据（如果是文件下载，则当传输完成时调用）。</p>
<p>NSURLSession提供了status和progress属性，并作为额外的信息传递给代理。同时它支持取消、恢复、挂起操作，并支持断点续传功能。</p>
<p>要掌握NSURLSession的使用，我们需要了解下URL会话的一些内容</p>
<h2 id="URL会话"><a href="#URL会话" class="headerlink" title="URL会话"></a>URL会话</h2><p>在一个会话中的任务的行为取决于三个方面：</p>
<ol>
<li>session的类型（由创建会话时的配置对象确定）</li>
<li>任务的类型</li>
<li>当任务创建时应用是否在前台</li>
</ol>
<p>NSURLSession支持以下三种会话类型：</p>
<ol>
<li>默认会话：行为与其它下载URL的Foundation方法类似。使用基于磁盘的缓存策略，并在用户keychain中存储证书。</li>
<li>短暂会话(Ephemeral sessions)：不存储任何数据在磁盘中；所有的缓存，证书存储等都保存在RAM中并与会话绑定。这样，当应用结束会话时，它们被自动释放。</li>
<li>后台会话(Background sessions)：类似于默认会话，除了有一个独立的进程来处理所有的数据传输。</li>
</ol>
<p>在一个会话中，NSURLSession支持三种任务类型</p>
<ol>
<li>数据任务：使用NSData对象来发送和接收数据。数据任务可以分片返回数据，也可以通过完成处理器一次性返回数据。由于数据任务不存储数据到文件，所以不支持后台会话.</li>
<li>下载任务：以文件的形式接收数据，当程序不运行时支持后台下载</li>
<li>上传任务：通常以文件的形式发送数据，支持后台上传。</li>
</ol>
<p>NSURLSession支持在程序挂起时在后台传输数据。后台传输只由使用后台会话配置对象创建的会话提供。使用后台会话时，由于实际传输是在一个独立的进程中传输，且重启应用进程相当损耗资源，只有少量特性可以使用，所以有以下限制：</p>
<ol>
<li>会话必须提供事件分发的代理。</li>
<li>只支持HTTP和HTTPS协议</li>
<li>只支持上传和下载任务</li>
<li>总是伴随着重定义操作</li>
<li>如果当应用在后台时初始化的后台传输，则配置对象的discretionary属性为true</li>
</ol>
<p>在iOS中，当我们的应用不再运行时，如果后台下载任务完成或者需要证书，则系统会在后台自动重启我们的应用，同时调用UIApplicationDelegate对象的application:handlerEventsForBackgroundURLSession:completionHandler:方法。这个调用会提供启动的应用的session的标识。我们的应用应该存储完成处理器，使用相同的标识来创建后台配置对象，然后使用配置对象来创建会话。新的会话会与运行的后台activity关联。当会话完成后台下载任务时，会给会话代理发送一个URLSessioinDidFinishEventsForBackgroundURLSession:消息。我们的代理对象然后调用存储的完成处理器。</p>
<p>如果在程序挂起时有任何任务完成，则会调用URLSession:downloadTask:didFinishDownloadingToURL:方法。同样的，如果任务需要证书，则NSURLSession对象会在适当的时候调用URLSession:task:didReceiveChallenge:completionHandler: 和URLSession:didReceiveChallenge:completionHandler:方法。</p>
<p>这里需要注意的是必须为每个标识创建一个会话，共享相同标识的多个会话的行为是未定义的。</p>
<p>会话和任务对象实现了NSCopying协议：</p>
<ol>
<li>当应用拷贝一个会话或任务对象时，会获取相同对象的指针</li>
<li>当应用拷贝一个配置对象时，会获取一个可单独修改的新的对象</li>
</ol>
<h2 id="创建并配置NSURLSession"><a href="#创建并配置NSURLSession" class="headerlink" title="创建并配置NSURLSession"></a>创建并配置NSURLSession</h2><p>我们下面举个简单的实例来说明一个NSURLSession与服务端的数据交互。</p>
<p><strong>代码清单1：声明三种类型会话对象</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">URLSession</span> : <span class="title">NSObject</span> &lt;<span class="title">NSURLSessionDelegate</span>, <span class="title">NSURLSessionTaskDelegate</span>, <span class="title">NSURLSessionDataDelegate</span>, <span class="title">NSURLSessionDownloadDelegate</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLSession</span> *backgroundSession;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLSession</span> *defaultSession;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLSession</span> *ephemeralSession;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *completionHandlerDictionary;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)addCompletionHandler:(CompletionHandlerType)handler forSession:(<span class="built_in">NSString</span> *)identifier;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)callCompletionHandlerForSession:(<span class="built_in">NSString</span> *)identifier;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>NSURLSession提供了大量的配置选项，包括：</p>
<ol>
<li>支持缓存、cookie，认证及协议的私有存储</li>
<li>认证</li>
<li>上传下载文件</li>
<li>每个主机的配置最大数</li>
<li>超时时间</li>
<li>支持的TLS最小最小版本</li>
<li>自定义代理字典</li>
<li>控制cookie策略</li>
<li>控制HTTP管道行为</li>
</ol>
<p>由于大部分设置都包含在一个独立的配置对象中，所以我们可以重用这些配置。当我们初始一个会话对象时，我们指定了如下内容</p>
<ol>
<li>一个配置对象，用于管理其中的会话和任务的行为</li>
<li>一个代理对象，用于在收到数据时处理输入数据，及会话和任务中的其它事件，如服务端认证、确定一个资源加载请求是否应该转换成下载等。这个对象是可选的。但如果我们需要执行后台传输，则必须提供自定义代理。</li>
</ol>
<p>在实例一个会话对象后，我们不能改变改变配置或代理。</p>
<p><strong>代码清单2演示了如何创建一个会话</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURLSessionConfiguration</span> *defaultConfigObject = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">        </div><div class="line"><span class="comment">// 配置会话的缓存</span></div><div class="line"><span class="built_in">NSString</span> *cachePath = <span class="string">@"/MyCacheDirectory"</span>;</div><div class="line">        </div><div class="line"><span class="built_in">NSArray</span> *pathList = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>);</div><div class="line"><span class="built_in">NSString</span> *path = [pathList objectAtIndex:<span class="number">0</span>];</div><div class="line">        </div><div class="line"><span class="built_in">NSString</span> *bundleIdentifier = [[<span class="built_in">NSBundle</span> mainBundle] bundleIdentifier];</div><div class="line">        </div><div class="line"><span class="built_in">NSString</span> *fullCachePath = [[path stringByAppendingPathComponent:bundleIdentifier] stringByAppendingPathComponent:cachePath];</div><div class="line">        </div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"Cache path: %@"</span>, fullCachePath);</div><div class="line">        </div><div class="line"><span class="built_in">NSURLCache</span> *cache = [[<span class="built_in">NSURLCache</span> alloc] initWithMemoryCapacity:<span class="number">16384</span> diskCapacity:<span class="number">268435456</span> diskPath:cachePath];</div><div class="line">defaultConfigObject.URLCache = cache;</div><div class="line">defaultConfigObject.requestCachePolicy = <span class="built_in">NSURLRequestUseProtocolCachePolicy</span>;</div><div class="line">        </div><div class="line"><span class="keyword">self</span>.defaultSession = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:defaultConfigObject delegate:<span class="keyword">self</span> delegateQueue:[<span class="built_in">NSOperationQueue</span> mainQueue]];</div></pre></td></tr></table></figure>
<p>除了后台配置对象外，我们可以重用会话的配置对象来创建新的会话，正如上面所讲的，拷贝一个配置对象会生成一个新的独立的配置对象。我们可以在任何时候安全的修改配置对象。当创建一个会话时，会话会对配置对象进行深拷贝，所以修改只会影响到新的会话。代理清单3演示了创建一个新的会话，这个会话使用重用的配置对象。</p>
<p><strong>代码清单3：重用会话对象</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.ephemeralSession = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:ephemeralConfigObject delegate:<span class="keyword">self</span> delegateQueue:[<span class="built_in">NSOperationQueue</span> mainQueue]];</div><div class="line">        </div><div class="line">ephemeralConfigObject.allowsCellularAccess = <span class="literal">YES</span>;</div><div class="line">        </div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="built_in">NSURLSession</span> *ephemeralSessionWifiOnly = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:ephemeralConfigObject delegate:<span class="keyword">self</span> delegateQueue:[<span class="built_in">NSOperationQueue</span> mainQueue]];</div></pre></td></tr></table></figure>
<p>使用NSURLSession获取数据基本就是两步：</p>
<ol>
<li>创建一个配置对象及基于这个对象的会话</li>
<li>定义一个请求完成处理器来处理获取到的数据。</li>
</ol>
<p>如果使用系统提供的代理，只需要代码清单4这几行代码即可搞定</p>
<p><strong>代码清单4：使用系统提供代理</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURLSession</span> *delegateFreeSession = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:defaultConfigObject delegate:<span class="keyword">self</span> delegateQueue:[<span class="built_in">NSOperationQueue</span> mainQueue]];</div><div class="line">[delegateFreeSession dataTaskWithRequest:<span class="string">@"http://www.sina.com"</span></div><div class="line">                               completionHandler:^(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error) &#123;    </div><div class="line">                                   <span class="built_in">NSLog</span>(<span class="string">@"Got response %@"</span>, response);</div><div class="line">                               &#125;];</div></pre></td></tr></table></figure>
<p>只是系统提供的代理只提供有限的网络行为。如果应用需要更多的处理，如自定义认证或后台下载等，则需要使用自定义的代理。使用自定义代理来获取数据时，代理必须实现以下方法：</p>
<ol>
<li>URLSession:dataTask:didReceiveData: 从请求提供数据给我们的任务，一次一个数据块</li>
<li>URLSession:task:didCompleteWithError: 表示任务已经接受了所有的数据。</li>
</ol>
<p>如果我们在URLSession:dataTask:didReceiveData:方法返回后使用数据，则需要将数据存储在某个地方。</p>
<p><strong>代码清单5：演示了一个数据访问实例：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.sina.com"</span>];</div><div class="line"><span class="built_in">NSURLSessionDataTask</span> *dataTask = [<span class="keyword">self</span>.defaultSession dataTaskWithURL:url];</div><div class="line">[dataTask resume];</div></pre></td></tr></table></figure>
<p>如果远程服务器返回的状态表示需要一个认证，且认证需要连接级别的处理时，NSURLSession将调用认证相关代理方法。这个具体我们后面文章将详细讨论。</p>
<h2 id="处理iOS后台Activity"><a href="#处理iOS后台Activity" class="headerlink" title="处理iOS后台Activity"></a>处理iOS后台Activity</h2><p>在iOS中使用NSURLSession时，当一个下载完成时，会自动启动我们的应用。应用的代理方法application:handleEventsForBackgroundURLSession:completionHandler: 负责创建一个合适的会话，存储请求完成处理器，并在会话调用会话代理的URLSessionDidFinishEventsForBackgroundURLSession: 方法时调用这个处理器。代码清单6与代码清单7演示了这个处理流程</p>
<p><strong>代码清单6：iOS后台下载的会话代理方法</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)URLSessionDidFinishEventsForBackgroundURLSession:(<span class="built_in">NSURLSession</span> *)session</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"background url session %@"</span>, session);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (session.configuration.identifier)</div><div class="line">    &#123;</div><div class="line">        [<span class="keyword">self</span> callCompletionHandlerForSession:session.configuration.identifier];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)callCompletionHandlerForSession:(<span class="built_in">NSString</span> *)identifier</div><div class="line">&#123;</div><div class="line">    CompletionHandlerType handler = [<span class="keyword">self</span>.completionHandlerDictionary objectForKey:identifier];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (handler) &#123;</div><div class="line">        [<span class="keyword">self</span>.completionHandlerDictionary removeObjectForKey:identifier];</div><div class="line">        </div><div class="line">        handler();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>代码清单7：iOS后台下载的App 代理方法</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application handleEventsForBackgroundURLSession:(<span class="built_in">NSString</span> *)identifier completionHandler:(<span class="keyword">void</span> (^)())completionHandler</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSURLSessionConfiguration</span> *backgroundConfigObject = [<span class="built_in">NSURLSessionConfiguration</span> backgroundSessionConfiguration:identifier];</div><div class="line">    </div><div class="line">    URLSession *sessionDelegate = [[URLSession alloc] init];</div><div class="line">    </div><div class="line">    <span class="built_in">NSURLSession</span> *backgroundSession = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:backgroundConfigObject</div><div class="line">                                                                    delegate:sessionDelegate</div><div class="line">                                                               delegateQueue:[<span class="built_in">NSOperationQueue</span> mainQueue]];</div><div class="line">    </div><div class="line">    [sessionDelegate addCompletionHandler:completionHandler forSession:identifier];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html" target="_blank" rel="external">URL Loading System Programming Guide</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/07/11/url-load-system-1/" itemprop="url">
                  URL加载系统之一：基本结构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-07-11T19:10:29+08:00" content="2014-07-11">
              2014-07-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>URL加载系统是一组类和协议的集合，它允许我们的App访问URL指定的内容的。</p>
<p>URL加载系统的核心类是NSURL，该类提供了大量方法让我们操作URLs和它指向的资源。另外它还提供了一系列的类来加载URL的内容，上传数据到服务器，管理Cookie存储，控制响应缓存，处理认证存储和授权信息，及自定义协议扩展。</p>
<p>URL Loading System可支持以下协议</p>
<ol>
<li>ftp://</li>
<li>http://</li>
<li>https://</li>
<li>file://</li>
<li>data://</li>
</ol>
<p>另外它还支持代理服务和网关处理。</p>
<p>URL加载系统定义了用于加载URL的类，另外还定义了一些辅助类来修改加载类的行为。这些辅助类可以分为五大类：</p>
<ol>
<li>协议支持</li>
<li>授权与认证</li>
<li>Cookie存储</li>
<li>配置管理 </li>
<li>缓存管理</li>
</ol>
<p>整个URL加载系统的结构如下图所示：</p>
<p><img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/URLLoadingSystem/Art/nsobject_hierarchy_2x.png" alt="image"></p>
<p>下面对这张图做个简单的介绍</p>
<h2 id="URL-Loading"><a href="#URL-Loading" class="headerlink" title="URL Loading"></a>URL Loading</h2><p>在这张图中，我们用得最多的就是URL Loading中的这几个类。这些类允许我们从URL指定的源获取内容。根据不同的需求，我们可以使用不同的类，这主要依赖于我们应用所支持的系统版本，以及我们希望内容是以文件的形式获取还是以数据块的方式获取。对于系统的版本，主要有以下几点作为参考：</p>
<ol>
<li>在iOS7及后续版本中，推荐使用NSURLSession。</li>
<li>对于iOS7以前的版本，可以使用NSURLConnection来获取数据并加载到本地内存中。如果要保存数据，可以再将数据写入磁盘。</li>
</ol>
<p>而对于获取数据，主要看我们是获取数据到内存中还是下载文件并保存。如果只是获取数据到内存中，则有两种方法：</p>
<ol>
<li>对于简单的请求，可以使用NSURLSession</li>
<li>对于复杂的请求（如上传数据请求），提供了NSURLRequest对象来与NSURLSession和NSURLConnection一起使用。</li>
</ol>
<p>不管使用哪种方法，我们都可以获取到响应数据，为此，我们可以如下处理响应</p>
<ol>
<li>提供一个响应处理block。当URL Loading类完成从服务端接收数据时调用该block.</li>
<li>提供自定义有delegate。URL Loading类间断性地调用我们的代理方法来获取数据。在需要的情况下，我们的程序负责收集这些数据。</li>
</ol>
<p>另外，URL Loading提供了一个返回对象来封装与请求相关的元数据，如MIME类型等。</p>
<p>而如果我们需要下载文件，则有两个基本方法来处理：</p>
<ol>
<li>对于简单请求，可以使用NSURLSession</li>
<li>对于复杂请求，提供了NSURLRequest对象来与NSURLSession和NSURLDownload一起使用。</li>
</ol>
<p>相较于NSURLDownload，NSURLSession有两个明显的优势：NSURLSession可用于iOS系统，而NSURLDownload在iOS中不被支持；当应用挂起、终止或异常退出时，下载可以在后台继续进行。</p>
<p>URL Loading中还提供了两个类用于处理元数据，一个用于表示客户端请求(NSURLRequest)，一个用于表示服务端响应(NSURLResponse)。我们分别介绍一下这两个类。</p>
<h3 id="NSURLRequest"><a href="#NSURLRequest" class="headerlink" title="NSURLRequest"></a>NSURLRequest</h3><p>NSURLRequest对象封装了URL和协议指定的属性，及依赖于协议的行为。同时也指定了本地缓存策略及连接超时时间。一些协议支持协议指定的属性，如HTTP协议可以添加返回HTTP请求体，请求报头和传输方法到NSURLRequest中。</p>
<p>这里需要注意的是，当我们使用NSURLRequest的子类NSMutableURLRequest初始化一个连接或下载时，将会对NSMutableURLRequest实例进行深拷贝。因此在初始的请求上做修改时不会影响到连接和下载对象。</p>
<h3 id="NSURLResponse"><a href="#NSURLResponse" class="headerlink" title="NSURLResponse"></a>NSURLResponse</h3><p>一个响应可以分为两个部分：描述内容的元数据和内容数据本身。而NSURLResponse类封装了大部分协议的响应元数据，这些元数据包括MIME类型，期望的Content-Length，编码格式，及提供响应的URL。NSURLResponse的一些子类提供了与协议相关的额外元数据。如NSHTTPURLResponse存储了web服务器返回的响应头和状态码。</p>
<p>需要注意的是NSURLResponse对象只存储响应的元数据，而不存储响应数据本身。响应数据由URL Loading通过响应处理block和对象的代理来接收并处理。</p>
<h2 id="认证和证书"><a href="#认证和证书" class="headerlink" title="认证和证书"></a>认证和证书</h2><p>针对认证和证书，URL加载系统提供了以下几个类：</p>
<ol>
<li>NSURLCredential：封装了由认证信息和持久化行为组成的证书。</li>
<li>NSURLProtectionSpace：表示需要特定证书的区域。一个保护区域可以限制到单独的URL，拥有web服务器的区域，或引用一个代理。</li>
<li>NSURLCredientialStorage：一般是一个共享实例，用于管理证书存储和提供NSURLCredential对象到NSURLProductionSpace对象的映射。</li>
<li>NSURLAuthenticationChallenge：封装了认证一个请求的的NSURLProtocol实现所需要的信息：一个建议的证书、保护空间、错误信息或者协议用于确定所需要认证的响应、以及认证尝试次数等。初始对象（即请求发送者）必须实现NSURLAuthenticationChallengeSender协议。NSURLAuthenticationChallenge实例被用于NSURLProtocol的子类来告诉URL加载系统需要认证。他们同样为NSURLConnection和NSURLDownload的代理方法提供了便利的自定义认证处理。</li>
</ol>
<h2 id="缓存管理"><a href="#缓存管理" class="headerlink" title="缓存管理"></a>缓存管理</h2><p>URL加载系统提供基于磁盘和内存的缓存，允许程序减少对网络连接的依赖，并提供对缓存响应的快速访问。缓存存储在每个app的缓存文件夹下。NSURLConnection会根据缓存策略（初始化NSURLRequest对象中指定的）来查询缓存。</p>
<p>NSURLCache提供了配置缓存大小和磁盘存储位置的方法。同时提供了包含缓存响应的NSCacheURLResponse对象集合的方法。NSCacheURLResponse对象封装了NSURLResponse对象和URL数据，同时提供用户信息字典，这些信息可以用于缓存任何用户数据。</p>
<p>不是所有的协议实现都支持响应缓存。当前只有http和https请求可被缓存。</p>
<p>一个NSURLConnection对象可以通过connection:willCacheResponse:代理访求来控制是否缓存响应，响应是否只应该存储在内存中。</p>
<h2 id="Cookie存储"><a href="#Cookie存储" class="headerlink" title="Cookie存储"></a>Cookie存储</h2><p>由于HTTP协议是无状态的，所以客户端通常使用cookie来保存URL请求的数据。URL加载系统提供了接口来创建和管理cookie，将cookie作为HTTP请求的一部分来发送，及解析web服务端响应数据时接收cookie.</p>
<p>iOS提供了NSHTTPCookieStorage类来管理一个NSHTTPCookie对象的集合。</p>
<h2 id="协议支持"><a href="#协议支持" class="headerlink" title="协议支持"></a>协议支持</h2><p>URL加载系统默认支持http, https, file, ftp, data协议。另外，URL加载系统也允许我们注册自己的类来支持额外的系统层级的网络协议。我们也可以添加指定协议的属性到URL请求和URL响应对象</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/07/08/mix-swift-and-objective-c/" itemprop="url">
                  Swift和Objective-C混合编程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-07-08T16:58:06+08:00" content="2014-07-08">
              2014-07-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Swift和Objective-C可以在同一个工程中共存。不管创建工程时选择的是Swift还是Objective-C作为初始语言，我们都可以在工程中添加另一种语言的文件。</p>
<p>混合编程的处理过程在App工程和库工程中稍微有点不同。具体的工作模型如下图所示</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/Art/DAG_2x.png" alt="image"></p>
<p>下面我们讨论下具体的操作</p>
<h2 id="同一App工程中导入代码"><a href="#同一App工程中导入代码" class="headerlink" title="同一App工程中导入代码"></a>同一App工程中导入代码</h2><h3 id="在Swift工程中导入Objective-C"><a href="#在Swift工程中导入Objective-C" class="headerlink" title="在Swift工程中导入Objective-C"></a>在Swift工程中导入Objective-C</h3><p>如果我们需要在一个Swift工程中导入Objective-C代码，需要依托于Objective-C Bridging header(桥接头文件)。在Swift工程中，当我们添加一个Objective-C文件时，如果工程中没有现存的Bridging header文件，则XCode会提示我们是否创建该文件。如果我们点击Yes，则XCode会自动创建头文件，并命名为”工程名-Bridging-Header.h”。</p>
<p>我们需要编辑这个文件，以导入我们的Objective-C代码。</p>
<p>如果是从同一个target中导入Objective-C代码，则我们需要做如下操作</p>
<ol>
<li>在Bridging header文件中，import所有需要在Swift中使用的头文件</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"XYZCustomCell.h"</span>	</span></div><div class="line"><span class="meta">#import <span class="meta-string">"XYZCustomView.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"XYZCustomViewController.h"</span></span></div></pre></td></tr></table></figure>
<ol>
<li>在Build Settings中，确保Swift Compiler Code Generation-&gt;Objective-C Bridging Header下的头文件的路径是对的。路径必须直接指向文件本身，而不是文件所在的文件夹。</li>
</ol>
<p>所有在Bridging header中的公有Objective-C头文件在Swift都是可见的，并且其中的所有功能在所有Swift中都是可用的，而不需要任何导入处理。可以像使用Swift代码一样使用Objective-C代码。如下所示</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> myCell = <span class="type">XYZCustomCell</span>()</div><div class="line">myCell.subtitle = <span class="string">"A custom cell"</span></div></pre></td></tr></table></figure>
<h3 id="在Objective-C中导入Swift"><a href="#在Objective-C中导入Swift" class="headerlink" title="在Objective-C中导入Swift"></a>在Objective-C中导入Swift</h3><p>如果我们要在一个Objective-C工程中导入Swift，则需要依托于XCode-generated header文件。这个自动生成的文件是一个Objective-C头文件，其声明了在我们的target中使用的所有Swift接口。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/07/06/ios-swift-cpointer-2/" itemprop="url">
                  Swift对C指针实现浅析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-07-06T13:23:29+08:00" content="2014-07-06">
              2014-07-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>个人认为，Swift对指针的处理略显复杂。</p>
<p>我们通过调试可以看到存在这样一个类型Builtin.RawPointer，我们可以假设其为C指针在Swife中的内部表示，但不可以直接使用。相反，在Swift中，定义了7种指针类型，可以通过这7种类型来操作C指针。</p>
<h2 id="COpaquePointer"><a href="#COpaquePointer" class="headerlink" title="COpaquePointer"></a>COpaquePointer</h2><p>在C语言中，常使用typedef来定义一些指针类型的别名，如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">stack</span> *<span class="keyword">stack_t</span></div></pre></td></tr></table></figure>
<p>该定义表示一个指向栈结构的指针，但并没有给出结构的任何信息，我们不知道该结构都有哪些成员。类似于stack_t这样的指针就是一个不透明的指针。在程序中，我们可以自由的操纵这种指针，但无法反引用以获取指针的内部信息，只有接口的实现才有这种特权。这所以使用不透明指针，在于其隐藏了具体的实现细节，有助于捕获错误。即只能传相同的参数给函数，否则将产一变异错误。(参看《C语言接口与实现：创建可重用软件的技术》)</p>
<p>在Swift中，针对这种不透明指针，定义了一个包装器：COpaquePointer。该类型（实际为结构体）是一个不透明指针的包装器，主要用于Bridge Header中表示C中的复杂结构指针，当我们的指针指向的类型无法在Swift中有效地表示出来时，就可以使用该类型，而如果在Swift能找到对应的类型表示指针指向的类型，则可以使用UnsafePointer。</p>
<p>该类的实现及其扩展实现了四个协议，我们看看其具体代码</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">COpaquePointer</span> : <span class="title">Equatable</span>, <span class="title">Hashable</span>, <span class="title">LogicValue</span> </span>&#123;</div><div class="line">    <span class="keyword">init</span>()</div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">null</span><span class="params">()</span></span> -&gt; <span class="type">COpaquePointer</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getLogicValue</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span></div><div class="line">    <span class="keyword">var</span> hashValue: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">COpaquePointer</span> </span>&#123;</div><div class="line">	</div><div class="line">    <span class="comment">/// 将UnsafePointer类型转换为不透明C指针</span></div><div class="line">    <span class="keyword">init</span>&lt;<span class="type">T</span>&gt;(<span class="number">_</span> from: <span class="type">UnsafePointer</span>&lt;<span class="type">T</span>&gt;)</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">COpaquePointer</span> : <span class="title">CVarArg</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">()</span></span> -&gt; <span class="type">Word</span>[]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到该结构体并没有做太多的事情，仅仅实现了四个协议的接口，同时做了个UnsafePointer类型的转换操作。该类型在Swift使用得比较多，例如在NSData中，bytes属性的类型就是COpaquePointer，而该属性在Objective-C中的类型是const void*。</p>
<h2 id="UnsafePointer"><a href="#UnsafePointer" class="headerlink" title="UnsafePointer"></a>UnsafePointer</h2><p>UnsafePointer一个泛型结构体，可以说是处理C指针最主要的结构体了。它包装并存储了类型为T的C指针，主要用于与C标准库交互。该类没有提供自动管理内存功能，所以我们在使用的时候需要注意内存的分配与释放。当在Swift能找到与T类型相对应的类型时，可以使用该类型，否则就考虑使用COpaquePointer。</p>
<p>在该类型的声明中，我们可以看到它定义了大量的方法来处理指针，具体如下</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UnsafePointer</span>&lt;<span class="title">T</span>&gt; : <span class="title">BidirectionalIndex</span>, <span class="title">Comparable</span>, <span class="title">Hashable</span>, <span class="title">LogicValue</span> </span>&#123;	</div><div class="line">    <span class="comment">/// 构造一个空指针</span></div><div class="line">    <span class="keyword">init</span>()</div><div class="line">	</div><div class="line">    <span class="comment">/// 将一个不透明指针转换为类型指定的C指针，注意这种转换是不安全的</span></div><div class="line">    <span class="keyword">init</span>(<span class="number">_</span> other: <span class="type">COpaquePointer</span>)</div><div class="line">	</div><div class="line">    <span class="comment">/// 从给定的内存地址中构造一个UnsafePointer。注意这种转换是不安全的</span></div><div class="line">    <span class="keyword">init</span>(<span class="number">_</span> value: <span class="type">Int</span>)</div><div class="line">	</div><div class="line">    <span class="comment">/// 从一个不同类型的指针中转换。注意这种转换是不安全的</span></div><div class="line">    <span class="keyword">init</span>&lt;<span class="type">U</span>&gt;(<span class="number">_</span> from: <span class="type">UnsafePointer</span>&lt;<span class="type">U</span>&gt;)</div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">null</span><span class="params">()</span></span> -&gt; <span class="type">UnsafePointer</span>&lt;<span class="type">T</span>&gt;</div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">alloc</span><span class="params">(num: Int)</span></span> -&gt; <span class="type">UnsafePointer</span>&lt;<span class="type">T</span>&gt;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dealloc</span><span class="params">(num: Int)</span></span></div><div class="line">	</div><div class="line">    <span class="comment">/// 访问底层原始内存，获取并设置其值</span></div><div class="line">    <span class="keyword">var</span> memory: <span class="type">T</span></div><div class="line">	</div><div class="line">    <span class="comment">/// 初始化指针指向的值，用于构造一个事先未存储对象的对象</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">(newvalue: T)</span></span></div><div class="line">	</div><div class="line">    <span class="comment">/// 获取指针指向的值，并将其从内存引用的位置移除。</span></div><div class="line">    <span class="comment">/// 后置条件：值被销毁，且内存在再次使用前必须被初始化</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">move</span><span class="params">()</span></span> -&gt; <span class="type">T</span></div><div class="line">	</div><div class="line">    <span class="comment">/// 将起始于source处的count个值赋值给未初始化的内存，将原始值转换到原始内存中，并且</span></div><div class="line">    <span class="comment">/// 是从最后开始处理，一直到第一个。使用该方法将值拷贝到可能与原范围重叠的内存区域</span></div><div class="line">    <span class="comment">/// 这要求source的位置先于self或者在self+count之后</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">moveInitializeBackwardFrom</span><span class="params">(source: UnsafePointer&lt;T&gt;, <span class="built_in">count</span>: Int)</span></span></div><div class="line">	</div><div class="line">    <span class="comment">/// Assign from count values beginning at source into initialized</span></div><div class="line">    <span class="comment">/// memory, transforming the source values into raw memory.</span></div><div class="line">    <span class="comment">/// 将起始于source处的count个值赋值给已初始化的内存，将原始值转换到原始内存中</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">moveAssignFrom</span><span class="params">(source: UnsafePointer&lt;T&gt;, <span class="built_in">count</span>: Int)</span></span></div><div class="line">	</div><div class="line">    <span class="comment">/// 拷贝起始于source的count个值到内存中，将源值转换到内存中</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">moveInitializeFrom</span><span class="params">(source: UnsafePointer&lt;T&gt;, <span class="built_in">count</span>: Int)</span></span></div><div class="line">	</div><div class="line">    <span class="comment">/// 拷贝起始于source的count个值到内存中</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initializeFrom</span><span class="params">(source: UnsafePointer&lt;T&gt;, <span class="built_in">count</span>: Int)</span></span></div><div class="line">	</div><div class="line">    <span class="comment">/// 拷贝C元素到内存中</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initializeFrom</span>&lt;C : Collection where T == T&gt;<span class="params">(source: C)</span></span></div><div class="line">	</div><div class="line">    <span class="comment">/// 销毁指针指向的对象</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">destroy</span><span class="params">()</span></span></div><div class="line">	</div><div class="line">    <span class="comment">/// 销毁指针指向的count个对象</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">destroy</span><span class="params">(<span class="built_in">count</span>: Int)</span></span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getLogicValue</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span></div><div class="line">    <span class="keyword">subscript</span> (i: <span class="type">Int</span>) -&gt; <span class="type">T</span></div><div class="line">    <span class="keyword">var</span> hashValue: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">succ</span><span class="params">()</span></span> -&gt; <span class="type">UnsafePointer</span>&lt;<span class="type">T</span>&gt;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">pred</span><span class="params">()</span></span> -&gt; <span class="type">UnsafePointer</span>&lt;<span class="type">T</span>&gt;</div><div class="line">	</div><div class="line">	<span class="comment">/// 以下是将其它类型的指针转换化UnsafePoint的构造器</span></div><div class="line">    <span class="keyword">init</span>(<span class="number">_</span> cp: <span class="type">CConstPointer</span>&lt;<span class="type">T</span>&gt;)</div><div class="line">    <span class="keyword">init</span>(<span class="number">_</span> cm: <span class="type">CMutablePointer</span>&lt;<span class="type">T</span>&gt;)</div><div class="line">    <span class="keyword">init</span>(<span class="number">_</span> op: <span class="type">AutoreleasingUnsafePointer</span>&lt;<span class="type">T</span>&gt;)</div><div class="line">    <span class="keyword">init</span>(<span class="number">_</span> cp: <span class="type">CConstVoidPointer</span>)</div><div class="line">    <span class="keyword">init</span>(<span class="number">_</span> cp: <span class="type">CMutableVoidPointer</span>)</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UnsafePointer</span>&lt;<span class="title">T</span>&gt; : <span class="title">Printable</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>UnsafePointer提供了多个构造器，以从其它指针类型创建一个UnsafePointer。另外，CMutablePointer、CMutableVoidPointer、CConstPointer、CConstVoidPointer都提供了一个withUnsafePointer方法，该方法是让这些指针类型在一个闭包中可以像UnsafePointer类型一样使用。我们来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">func StringFromCptr(inChars:CMutablePointer&lt;CChar&gt;) -&gt; String &#123;</div><div class="line">    </div><div class="line">    var ptr:UnsafePointer&lt;UInt8&gt; = UnsafePointer&lt;UInt8&gt;(0)</div><div class="line">    inChars.withUnsafePointer(&#123; p in ptr = UnsafePointer&lt;UInt8&gt;(p) &#125;)</div><div class="line">    </div><div class="line">    var str = CString(ptr)</div><div class="line">    </div><div class="line">    return NSString(CString:str)</div><div class="line">&#125;</div><div class="line">	</div><div class="line">var Len = 10</div><div class="line">var Str = CChar[](count:Len, repeatedValue:CChar(0))</div><div class="line">	</div><div class="line">for var i = 0; i &lt; Len; i++ &#123;</div><div class="line">    Str[i] = CChar(i + 65)</div><div class="line">&#125;</div><div class="line">	</div><div class="line">var Result = StringFromCptr(&amp;Str)</div><div class="line">	</div><div class="line">println(&quot;\(Result)&quot;)</div><div class="line"></div><div class="line">// 输出：ABCDEFGHIJ</div></pre></td></tr></table></figure>
<p>目前感觉在通常情况下，UnsafePointer使用得不多，平时接触到的更多的是CMutablePointer、CMutableVoidPointer、CConstPointer、CConstVoidPointer、AutoreleasingUnsafePointer这五种指针类型，这五种指针的基本使用方法我们在<a href="http://southpeak.github.io/blog/2014/07/02/ios-swift-cpointer/">Swift中C指针的基本使用方法</a>有简单介绍过，下面我们也讲讲它们的基本实现。</p>
<h2 id="AutoreleasingUnsafePointer"><a href="#AutoreleasingUnsafePointer" class="headerlink" title="AutoreleasingUnsafePointer"></a>AutoreleasingUnsafePointer</h2><p>该类型的基本定义是一个指向Objective-C指针的可变指针。这个类型有几种隐式转换来允许传递下面几种参数类型给一个一个C或ObjC API：</p>
<ol>
<li>nil, 作为null指针传入</li>
<li>被引用类型的in-out参数，作为一个带有自动释放所有权语义的可回写变量的指针传递</li>
<li>UnsafePointer<t></t></li>
</ol>
<p>与CMutablePointer不同的是，Swift不直接支持传递一个指向元素是Objc类指针数组的指针。与UnsafePointer<t>不同的是，AutoreleasingUnsafePointer必须引用一个存储，该存储没有其引用值的引用计数。相反，UnsafePointer的操作假设引用的存储拥有其加载的值且可以对其进行修改。</t></p>
<p>该类型不像其它的C*Pointer类型一样携带一个所有者指针，因为它只需要引用in-out参数转换的结果，而这个参数已经有一个回写域的生命周期了。</p>
<p>我们来看看其声明：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AutoreleasingUnsafePointer</span>&lt;<span class="title">T</span>&gt; : <span class="title">Equatable</span>, <span class="title">LogicValue</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getLogicValue</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span></div><div class="line">	</div><div class="line">    <span class="comment">/// Access the underlying raw memory, getting and</span></div><div class="line">    <span class="comment">/// setting values.</span></div><div class="line">    <span class="keyword">var</span> memory: <span class="type">T</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="CConstPointer与CConstVoidPointer"><a href="#CConstPointer与CConstVoidPointer" class="headerlink" title="CConstPointer与CConstVoidPointer"></a>CConstPointer与CConstVoidPointer</h2><p>这两个类型都是C常量指针，分别对应于C中的const T<em>和const </em>void。它们没有自己的操作。它的值由owner-value对组成，也正因此，它不能直接传递给C函数。在桥接的过程中，它会维护一个owner的强引用，且指针值被传递到C或者Objective-C的入口点。这允许拥有堆存储的类型(如数组)将自己转换为一个指针，同时仍保证在调用的过程中仍然维护它们的存储。我们可以看下它们的具体实现</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CConstPointer</span>&lt;<span class="title">T</span>&gt; : <span class="title">Equatable</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> owner: <span class="type">AnyObject</span>?</div><div class="line">	</div><div class="line">    <span class="comment">/// True if this is a scoped pointer, meaning it has a owner reference</span></div><div class="line">    <span class="comment">/// that guarantees the lifetime of the referenced memory.</span></div><div class="line">    <span class="keyword">var</span> scoped: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">	</div><div class="line">    <span class="comment">/// Make the pointer available as an UnsafePointer within a closure.</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">withUnsafePointer</span>&lt;U&gt;<span class="params">(f: UnsafePointer&lt;T&gt; -&gt; U)</span></span> -&gt; <span class="type">U</span></div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CConstVoidPointer</span> : <span class="title">Equatable</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> owner: <span class="type">AnyObject</span>?</div><div class="line">	</div><div class="line">    <span class="comment">/// True if this is a scoped pointer, meaning it has a owner reference</span></div><div class="line">    <span class="comment">/// that guarantees the lifetime of the referenced memory.</span></div><div class="line">    <span class="keyword">var</span> scoped: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">	</div><div class="line">    <span class="comment">/// Make the pointer available as an UnsafePointer within a closure.</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">withUnsafePointer</span>&lt;T, U&gt;<span class="params">(f: UnsafePointer&lt;T&gt; -&gt; U)</span></span> -&gt; <span class="type">U</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="CMutablePointer与CMutableVoidPointer"><a href="#CMutablePointer与CMutableVoidPointer" class="headerlink" title="CMutablePointer与CMutableVoidPointer"></a>CMutablePointer与CMutableVoidPointer</h2><p>这两个类型都是C可变指针，分别对应于C中的T <em>和void </em>，其基本内容同上。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由上面的分析，依据类型是否可以直接用于C函数声明，可以将这7种指针类型分为两类：</p>
<ol>
<li>可直接用于C函数声明：COpaquePointer,UnsafePointer<t>,AutoreleasingUnsafePointer<t>，它们是对Builtin.RawPointer的封装，直接对应于C指针，其sizeof是单位字长</t></t></li>
<li>不可直接用于C函数声明：CMutablePointer<t>, CConstPointer<t>, CMutableVoidPointer, CConstVoidPointer。这几个类型都有一个owner属性用于管理实例的生命周期，可以直接从Swift对象的引用获得，另外还可以使用withUnsafePointer方法，该方法是让这些指针类型在一个闭包中可以像UnsafePointer类型一样使用。</t></t></li>
</ol>
<p>另外有两点需要注意</p>
<ol>
<li>非常量指针都实现了LogicValue协议，因此可以直接使用if a_pointer来判断其是否为NULL。</li>
<li>nil类型实现了到所有指针类型的隐式类型转换，等价于C中的NULL，可以直接判断。</li>
</ol>
<p>至于这些指针的使用，需要在根据实现情况来具体处理。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>《C语言接口与实现：创建可重用软件的技术》</li>
<li><a href="http://stackoverflow.com/questions/24089052/swift-string-to-cmutablepointercchar" target="_blank" rel="external">Swift.String to CMutablePointer<cchar></cchar></a></li>
<li><a href="http://andelf.github.io/blog/2014/06/18/swift-and-c-interop-cont/" target="_blank" rel="external">Swift and C Interop Cont. (简析 Swift 和 C 的交互，Part 二)</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/07/05/cover-flow/" itemprop="url">
                  Cover flow基本原理及Tapku实现方法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-07-05T17:51:43+08:00" content="2014-07-05">
              2014-07-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/sourcecode/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇是两年前在CocoaChina上写的，现在把它归集到这边来。大家也可以查看<a href="http://www.cocoachina.com/bbs/read.php?tid=75699" target="_blank" rel="external">原文</a>。</p>
<p>Cover flow是苹果首创的将多首歌曲的封面以3D界面的形式显示出来的方式。如下图所示：</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Cove%20flow.png?raw=true" alt="image"></p>
<p>从图中可以看到，显示在中间的图片为目标图片，两侧的图片在y轴都旋转了一定的角度，并且每两张图片之间都保持了一定的距离。在交互（如点击两侧的图片）的时候，滑动到中间的图片会逐渐放大，旋转的角度由原来的旋转角度a变为0，且位置上移动中间，变成新的目标图片；同时原处于中间位置的图片则缩小、旋转一定的角度、位置偏移到一侧。所以在整个过程中，主要有两个属性发生了变化：角度与位置(缩放只是视觉上的，并没有进行缩放操作)。</p>
<p>在每次点击一张图片时，如果这张图片在目标图片的左边，则所有的图片都会向右移动，同时做相应的旋转；相反，点击目标图片右侧的图片时，所有图片都会向左移动并做相应的旋转。</p>
<p>从如上描述的效果，可以看出在Cover Flow中最主要的的操作有两个：3D仿射变换与动画。仿射变换实质上是一种线性变换，通常主要用到的仿射变换有平移(Translation)、旋转(Rotation)、缩放(Scale)。<br>对于这两种操作，iOS都提供了非常简便的接口来实现。接下来我们便以tapku的实现方法为例，来说明实现Cover Flow的基本过程。</p>
<h2 id="图片的布局"><a href="#图片的布局" class="headerlink" title="图片的布局"></a>图片的布局</h2><p>从效果图可以看出，图片是按一条直接排列，图片与图片之间有一定的间距，目标图片是正向显示，两侧的图片则按一定的角度进行了旋转，与目标图片形成一定的角度。同时我们还能看到每个图片都有一个倒影，并且这个倒影是渐变的，由上而下逐渐透明度逐渐减小。</p>
<h3 id="Cover-Flow单元的定义"><a href="#Cover-Flow单元的定义" class="headerlink" title="Cover Flow单元的定义"></a>Cover Flow单元的定义</h3><p>在tapku中，每一个图片附属于一个视图(TKCoverflowCoverView)，这个视图相当于UITableViewCell，它包含了三个要素：图片(imageView)，倒影图片(reflected)，渐变层(gradientLayer)。渐变层覆盖于倒影图片上，且大小位置一致。</p>
<p>TKCoverflowCoverView的声明及布局代码如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TKCoverflowCoverView</span> : <span class="title">UIView</span> </span>&#123;</div><div class="line">	<span class="keyword">float</span> baseline;</div><div class="line">	<span class="built_in">UIImageView</span> *imageView;</div><div class="line">	<span class="built_in">UIImageView</span> *reflected;</div><div class="line">	<span class="built_in">CAGradientLayer</span> *gradientLayer;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line">	</div><div class="line">- (<span class="keyword">id</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame &#123;</div><div class="line">	<span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];</div><div class="line"> 	<span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">		<span class="keyword">self</span>.opaque = <span class="literal">NO</span>;</div><div class="line">		<span class="keyword">self</span>.backgroundColor = [<span class="built_in">UIColor</span> clearColor];</div><div class="line">		<span class="keyword">self</span>.layer.anchorPoint = <span class="built_in">CGPointMake</span>(<span class="number">0.5</span>, <span class="number">0.5</span>);</div><div class="line">		</div><div class="line">		imageView = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.frame.size.width, <span class="keyword">self</span>.frame.size.width)];</div><div class="line">		[<span class="keyword">self</span> addSubview:imageView];</div><div class="line">		reflected = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="keyword">self</span>.frame.size.width, <span class="keyword">self</span>.frame.size.width, <span class="keyword">self</span>.frame.size.width)];</div><div class="line">		reflected.transform = <span class="built_in">CGAffineTransformScale</span>(reflected.transform, <span class="number">1</span>, <span class="number">-1</span>);</div><div class="line">		[<span class="keyword">self</span> addSubview:reflected];</div><div class="line">		</div><div class="line">		gradientLayer = [<span class="built_in">CAGradientLayer</span> layer];</div><div class="line">		gradientLayer.colors = [<span class="built_in">NSArray</span> arrayWithObjects:(<span class="keyword">id</span>)[<span class="built_in">UIColor</span> colorWithWhite:<span class="number">0</span> alpha:<span class="number">0.5</span>].CGColor,(<span class="keyword">id</span>)[<span class="built_in">UIColor</span> colorWithWhite:<span class="number">0</span> alpha:<span class="number">1</span>].CGColor,<span class="literal">nil</span>];</div><div class="line">		gradientLayer.startPoint = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">		gradientLayer.endPoint = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0.4</span>);</div><div class="line">		gradientLayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="keyword">self</span>.frame.size.width, <span class="keyword">self</span>.frame.size.width, <span class="keyword">self</span>.frame.size.width);</div><div class="line">		[<span class="keyword">self</span>.layer addSublayer:gradientLayer];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">	<span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意：此次将视图的锚点(anchorPoint属性)设置为(0.5, 0.5)，即视图的中心点，目的是让视图以中心点为基点进行旋转。</p>
<p>在进行仿射变换时，视图作为一个整体进行变换。</p>
<h3 id="图片的布局-1"><a href="#图片的布局-1" class="headerlink" title="图片的布局"></a>图片的布局</h3><p>tapku中，图片的布局与交互是在TKCoverflowView类中完成的。类TKCoverflowView继承自UIScrollView，相当于是TableView。</p>
<p>该类中定义是两个仿射变量：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CATransform3D</span> leftTransform, rightTransform</div></pre></td></tr></table></figure>
<p>这两个变量分别设置了两侧图片的仿射变换，具体的设置方法为</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>) setupTransforms&#123;</div><div class="line">  	leftTransform = <span class="built_in">CATransform3DMakeRotation</span>(coverAngle, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">	leftTransform = <span class="built_in">CATransform3DConcat</span>(leftTransform,<span class="built_in">CATransform3DMakeTranslation</span>(-spaceFromCurrent, <span class="number">0</span>, <span class="number">-300</span>));</div><div class="line">  	rightTransform = <span class="built_in">CATransform3DMakeRotation</span>(-coverAngle, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">	rightTransform = <span class="built_in">CATransform3DConcat</span>(rightTransform,<span class="built_in">CATransform3DMakeTranslation</span>(spaceFromCurrent, <span class="number">0</span>, <span class="number">-300</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中coverAngle为旋转的角度。对每个仿射变量同时设置了旋转也平移变换。</p>
<p>Cover Flow单元是存储在一个数组中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableArray</span> *coverViews;</div></pre></td></tr></table></figure>
<p>初始化时设置数组的大小，并存入空对象。在后期获取某个索引位置的单元时，如果该单元为空，则生成一个新的TKCoverflowCoverView并放入相应位置。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>([coverViews objectAtIndex:cnt] == [<span class="built_in">NSNull</span> null])&#123;</div><div class="line">  	TKCoverflowCoverView *cover = [dataSource coverflowView:<span class="keyword">self</span> coverAtIndex:cnt];</div><div class="line">	[coverViews replaceObjectAtIndex:cnt withObject:cover];</div><div class="line">	......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每个Cover Flow单元的位置计算如下</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CGRect</span> r = cover.frame;</div><div class="line">r.origin.y = currentSize.height / <span class="number">2</span> - (coverSize.height/<span class="number">2</span>) - (coverSize.height/<span class="number">16</span>);</div><div class="line">r.origin.x = (currentSize.width/<span class="number">2</span> - (coverSize.width/ <span class="number">2</span>)) + (coverSpacing) * cnt;</div><div class="line">cover.frame = r;</div></pre></td></tr></table></figure>
<p>其中currentSize,coverSize,coverSpacing都是固定值。从中可以看出所有单元的y值都是一样的，而x值则与其在数组中的索引值相关，索引越大，x值也越大。而这就涉及我们之后的一个问题。一会再讲。<br>假定目标图片的索引为currentIndex，则目标图片两侧的仿射属性设置如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(cnt &gt; currentIndex)&#123;</div><div class="line">	cover.layer.transform = rightTransform;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">	cover.layer.transform = leftTransform;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上即为Cover Flow的基本布局，可以与UITableView比较一下。</p>
<h2 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h2><p>Cover Flow的基本交互是点击两侧的图片，则被点击的图片成为新的目标图片并移动中屏幕中间，而其它图片一起移动，在这个过程中所需要做的就两件事：旋转与平移。</p>
<p>方法很简单：在动画块中重新设置Cover Flow单元的transform属性，这样就可以缓动实现这个动画的过程。实际上只有新旧目标图片及中间的图片需要做这种变换，其余图片的transform属性都是不变的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">float</span> speed = <span class="number">0.3</span>;</div><div class="line">[<span class="built_in">UIView</span> beginAnimations:string context:<span class="literal">nil</span>];</div><div class="line">[<span class="built_in">UIView</span> setAnimationDuration:speed];</div><div class="line">[<span class="built_in">UIView</span> setAnimationCurve:<span class="built_in">UIViewAnimationCurveEaseOut</span>];</div><div class="line">[<span class="built_in">UIView</span> setAnimationBeginsFromCurrentState:<span class="literal">YES</span>];</div><div class="line">[<span class="built_in">UIView</span> setAnimationDelegate:<span class="keyword">self</span>];</div><div class="line">[<span class="built_in">UIView</span> setAnimationDidStopSelector:<span class="keyword">@selector</span>(animationDidStop:finished:context:)]; </div><div class="line"><span class="keyword">for</span>(<span class="built_in">UIView</span> *v <span class="keyword">in</span> views)&#123;</div><div class="line"><span class="keyword">int</span> i = [coverViews indexOfObject:v];</div><div class="line">	<span class="keyword">if</span>(i &lt; index) v.layer.transform = leftTransform;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(i &gt; index) v.layer.transform = rightTransform;</div><div class="line">	<span class="keyword">else</span> v.layer.transform = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line">&#125;</div><div class="line">[<span class="built_in">UIView</span> commitAnimations];</div></pre></td></tr></table></figure>
<p>但这在做的只是旋转了Cover Flow的内容，并没有对Cover Flow进行水平平移，Cover Flow水平位置已由其origin.x值固定。那么水平上的平移是如何实现的呢，我们看下面的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>) snapToAlbum:(<span class="built_in">BOOL</span>)animated&#123;</div><div class="line">  	<span class="built_in">UIView</span> *v = [coverViews objectAtIndex:currentIndex];</div><div class="line"> 	<span class="keyword">if</span>((<span class="built_in">NSObject</span>*)v!=[<span class="built_in">NSNull</span> null])&#123;</div><div class="line">		[<span class="keyword">self</span> setContentOffset:<span class="built_in">CGPointMake</span>(v.center.x - (currentSize.width/<span class="number">2</span>), <span class="number">0</span>) animated:animated];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span></div><div class="line">	&#123;  </div><div class="line">		[<span class="keyword">self</span> setContentOffset:<span class="built_in">CGPointMake</span>(coverSpacing*currentIndex, <span class="number">0</span>) animated:animated];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其所做的就是以目标图片为中心，整体平移TKCoverflowView视图。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由上可以看出，Cover Flow特效的原理很简单：对新旧目标图片及中间的图片以动画的形式做仿射变换。至于仿射变换如何处理，有不同的方法。tapku所实现的方法可以说相对简单灵活。</p>
<p>Android, Flash都有类似的Cover Flow特效实现方法，有兴趣的童鞋可以参考一下。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/07/02/ios-swift-cpointer-1/" itemprop="url">
                  Swift中C指针的基本使用方法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-07-02T20:51:30+08:00" content="2014-07-02">
              2014-07-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Swift尽可能避免让我们直接去访问指针。但当我们需要直接访问内存时，我们可以使用Swift提供的几种指针类型。在下面几个表中列出了各种情况下C类型指针语法与Swift语法对应关系，其中Type作为实际类型的占位符</p>
<p>对于函数参数，有以下对应关系</p>
<table>
<thead>
<tr>
<th>C语法</th>
<th>Swift语法</th>
</tr>
</thead>
<tbody>
<tr>
<td>const void *</td>
<td>CConstVoidPointer</td>
</tr>
<tr>
<td>void *</td>
<td>CMutableVoidPointer</td>
</tr>
<tr>
<td>const Type *</td>
<td>CConstPointer<type></type></td>
</tr>
<tr>
<td>Type *</td>
<td>CMutablePointer<type></type></td>
</tr>
</tbody>
</table>
<p>对于返回值，变量，二级以上的指针参数，有以下对应关系</p>
<table>
<thead>
<tr>
<th>C语法</th>
<th>Swift语法</th>
</tr>
</thead>
<tbody>
<tr>
<td>void *</td>
<td>COpaquePointer</td>
</tr>
<tr>
<td>Type *</td>
<td>UnsafePointer<type></type></td>
</tr>
</tbody>
</table>
<p>对于类类型，有以下对应关系</p>
<table>
<thead>
<tr>
<th>C语法</th>
<th>Swift语法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Type <em> const </em></td>
<td>CConstPointer<type></type></td>
</tr>
<tr>
<td>Type <em> __strong </em></td>
<td>CMutablePointer<type></type></td>
</tr>
<tr>
<td>Type **</td>
<td>AutoreleasingUnsafePointer<type></type></td>
</tr>
</tbody>
</table>
<p>下面简单介绍一下这几种类型的指针</p>
<h2 id="C可变指针"><a href="#C可变指针" class="headerlink" title="C可变指针"></a>C可变指针</h2><p>当我们声明一个包含CMutablePointer<type>参数的指针时，可以接收以下类型的值</type></p>
<ol>
<li>nil, 作为空指针传入</li>
<li>一个CMutablePointer<type>值</type></li>
<li>一个in-out表达式，它的操作数是Type类型的左值。该表达式作为左值地址传入</li>
<li>一个in-out Type[]值，它作为数组的首地址指针传入，且在调用时扩展了数据的生命周期</li>
</ol>
<p>假如我们声明了如下一个函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">takesAMutablePointer</span><span class="params">(x: CMutablePointer&lt;Float&gt;)</span></span> &#123; <span class="comment">/*...*/</span> &#125;</div></pre></td></tr></table></figure>
<p>那么我们可以用以下任何一种方式来调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var x: Float = 0.0</div><div class="line">var p: CMutablePointer&lt;Float&gt; = &amp;x</div><div class="line">var a: Float[] = [1.0, 2.0, 3.0]</div><div class="line">	</div><div class="line">takesAMutablePointer(nil)</div><div class="line">takesAMutablePointer(p)</div><div class="line">takesAMutablePointer(&amp;x)</div><div class="line">takesAMutablePointer(&amp;a)</div></pre></td></tr></table></figure>
<p>当声明一个包含CMutableVoidPointer参数的函数时，它可以接收与CMutablePointer<type>相同的形参，其中Type为任意类型。需要注意的是如果直接传递CMutablePointer<type>，目前的编译器会直接报编译错误</type></type></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">takesAMutableVoidPointer</span><span class="params">(x: CMutableVoidPointer)</span></span> &#123; <span class="comment">/* ... */</span> &#125;</div><div class="line">	</div><div class="line"><span class="keyword">var</span> x: <span class="type">Float</span> = <span class="number">0.0</span>, y: <span class="type">Int</span> = <span class="number">0</span></div><div class="line"><span class="keyword">var</span> p: <span class="type">CMutablePointer</span>&lt;<span class="type">Float</span>&gt; = &amp;x, q: <span class="type">CMutablePointer</span>&lt;<span class="type">Int</span>&gt; = &amp;y</div><div class="line"><span class="keyword">var</span> a: <span class="type">Float</span>[] = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>], b: <span class="type">Int</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">	</div><div class="line">takesAMutableVoidPointer(<span class="literal">nil</span>)</div><div class="line"><span class="comment">//takesAMutableVoidPointer(p)	编辑错误:CMutablePointer&lt;Float&gt; is not convertible to CMutableVoidPointer</span></div><div class="line"><span class="comment">//takesAMutableVoidPointer(q)</span></div><div class="line">takesAMutableVoidPointer(&amp;x)</div><div class="line">takesAMutableVoidPointer(&amp;y)</div><div class="line">takesAMutableVoidPointer(&amp;a)</div><div class="line">takesAMutableVoidPointer(&amp;b)</div></pre></td></tr></table></figure>
<h2 id="C常量指针"><a href="#C常量指针" class="headerlink" title="C常量指针"></a>C常量指针</h2><p>当我们声明一个带有CConstPointer<type>参数的函数时，可以接收以下类型的值：</type></p>
<ol>
<li>nil, 作为空指针传入</li>
<li>一个CMutablePointer<type>, CMutableVoidPointer, CConstPointer<type>, CConstVoidPointer, 或者AutoreleasingUnsafePointer<type>类型的值，如果需要则会转换成CConstPointer<type></type></type></type></type></li>
<li>一个in-out表达式，它的操作数是Type类型的左值。该表达式作为左值地址传入</li>
<li>一个in-out Type[]值，它作为数组的首地址指针传入，且在调用时扩展了数据的生命周期</li>
</ol>
<p>假如我们声明如下函数:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">takesAConstPointer</span><span class="params">(x: CConstPointer&lt;Float&gt;)</span></span> &#123; <span class="comment">/*...*/</span> &#125;</div></pre></td></tr></table></figure>
<p>那么我们可以用以下任何一种方式来调用</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x: <span class="type">Float</span> = <span class="number">0.0</span></div><div class="line"><span class="keyword">var</span> p: <span class="type">CConstPointer</span>&lt;<span class="type">Float</span>&gt; = <span class="literal">nil</span></div><div class="line">	</div><div class="line">takesAConstPointer(<span class="literal">nil</span>)</div><div class="line">takesAConstPointer(p)</div><div class="line">takesAConstPointer(&amp;x)</div><div class="line">takesAConstPointer([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>])</div></pre></td></tr></table></figure>
<p>当声明一个包含CConstVoidPointer参数的函数时，它可以接收与CConstPointer<type>相同的形参，其中Type为任意类型。</type></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">takesAConstVoidPointer</span><span class="params">(x: CConstVoidPointer)</span></span> &#123; <span class="comment">/* ... */</span> &#125;</div><div class="line">	</div><div class="line"><span class="keyword">var</span> x: <span class="type">Float</span> = <span class="number">0.0</span>, y: <span class="type">Int</span> = <span class="number">0</span></div><div class="line"><span class="keyword">var</span> p:<span class="type">CConstPointer</span>&lt;<span class="type">Float</span>&gt; = <span class="literal">nil</span>, q: <span class="type">CConstPointer</span>&lt;<span class="type">Int</span>&gt; = <span class="literal">nil</span></div><div class="line">	</div><div class="line">takesAConstVoidPointer(<span class="literal">nil</span>)</div><div class="line"><span class="comment">//takesAConstVoidPointer(p)</span></div><div class="line"><span class="comment">//takesAConstVoidPointer(q)</span></div><div class="line">takesAConstVoidPointer(&amp;x)</div><div class="line">takesAConstVoidPointer(&amp;y)</div><div class="line">takesAConstVoidPointer([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>])</div><div class="line">takesAConstVoidPointer([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div></pre></td></tr></table></figure>
<h2 id="AutoreleasingUnsafePointer"><a href="#AutoreleasingUnsafePointer" class="headerlink" title="AutoreleasingUnsafePointer"></a>AutoreleasingUnsafePointer</h2><p>当我们声明一个带有AutoreleasingUnsafePointer参数的函数时，可以接收以下类型的值：</p>
<ol>
<li>nil, 作为空指针传入</li>
<li>一个AutoreleasingUnsafePointer<type>值</type></li>
<li>一个in-out表达式，其操作数是临时非所属(nonowning)缓冲区，存储了原始值的拷贝。缓冲区的地址被传递给调用函数，且在返回时，缓冲区的值被加载(loaded)、保留(retained)并重新指派(reassigned)给操作数</li>
</ol>
<p>注意上面清单中不包含数组</p>
<p>如果我们声明了以下函数</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">takesAnAutoreleasingUnsafePointer</span><span class="params">(x: AutoreleasingUnsafePointer&lt;NSDate?&gt;)</span></span> &#123; <span class="comment">/*...*/</span> &#125;</div></pre></td></tr></table></figure>
<p>则可以用以下方式来调用</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x: <span class="type">NSDate</span>? = <span class="literal">nil</span></div><div class="line"><span class="keyword">var</span> p: <span class="type">AutoreleasingUnsafePointer</span>&lt;<span class="type">NSDate</span>?&gt; = <span class="literal">nil</span></div><div class="line">	</div><div class="line">takesAnAutoreleasingUnsafePointer(<span class="literal">nil</span>)</div><div class="line">takesAnAutoreleasingUnsafePointer(p)</div><div class="line">takesAnAutoreleasingUnsafePointer(&amp;x)</div></pre></td></tr></table></figure>
<p>最后需要注意的是在Swift中，没有导入C函数指针。</p>
<p>参考文档：<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html" target="_blank" rel="external">Using Swift with Cocoa and Objective-C</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/07/02/ios-swift-protocol/" itemprop="url">
                  Swift协议基础
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-07-02T14:09:11+08:00" content="2014-07-02">
              2014-07-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Swift的Protocol(协议)与Objective-C的协议一样，用于定义一系列的特定任务和功能的集合。Protocol自身并不提供这些任务的实现，只是描述实现看起来应该是什么样的。类、结构体或枚举可以实现一个Protocol，并提供Protocol中任务和功能的具体实现。Protocol可以要求这些实现类型有指定的实例属性、实例方法、类型方法、操作符和下标等。</p>
<p>Protocol的语法如下所示:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</div><div class="line">    <span class="comment">// 协议定义</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类、结构体、枚举可以同时实现多个Protocol，如下所示:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeStructure</span>: <span class="title">SomeProtocol</span>, <span class="title">AnotherProcotol</span> </span>&#123;</div><div class="line">    <span class="comment">// 协议定义</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要注意的是，子类在实现Protocol时，需要把父类写在前面，后面再跟上Protocol列表。</p>
<p>我们下面介绍Protocol可以定义的一些功能需求</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>Protocol可以要求实现类型提供指定名称和类型的实例属性或类型属性。Protocol不指定属性是存储属性还是计算属性，它只定义属性名和类型。Protocol也可以指定每个属性是只读的还是可读写的。</p>
<p>如果Protocol要求属性是可读写的，那么这个属性不能是常量存储属性或者只读的计算属性；如果Protocol只是要求属性是可读的，则这个属性可以是任何类型的属性，这种情况下我们的实现代码同样可以指定属性为可写的。通常情况下，在Protocol中属性一般定义为变量，具体语法如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> mustBeSettable: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">    <span class="keyword">var</span> doesNotNeedToBeSettable: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">someTypeProperty</span>: <span class="title">Int</span> </span>&#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果是类型属性，我们需要在前面加上class，即便是结构体可枚举来实现这个Protocol，也是一样。如上面代码所示。</p>
<p>代码清单1是一个详细的例子，定义了一个协议FullyNamed，其中声明了fullName属性，而在其两个个体的实现类型中，将fullName实现为不同的属性类型</p>
<p><strong>代码清单1</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">FullyNamed</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> fullName: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>: <span class="title">FullyNamed</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> fullName: <span class="type">String</span>        <span class="comment">// 可读写存储属性</span></div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sharship</span>: <span class="title">FullyNamed</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> <span class="keyword">prefix</span>: <span class="type">String</span>?</div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> fullName: <span class="type">String</span> &#123;      <span class="comment">// 只读的计算属性</span></div><div class="line">    <span class="keyword">return</span> (<span class="keyword">prefix</span> ? <span class="keyword">prefix</span>! + <span class="string">" "</span> : <span class="string">""</span>) + name</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>在Protocol中声明方法与在类中定义类似，只是没有实现体。另外声明方法是使用可变参数也是可以的，唯一的不同是在Protocol的方法声明中不能指定默认值。</p>
<p>与属性声明一样，如果是类型方法，需要加上class前缀。方法的声明及实现类型的实现如代码清单2所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">RandomNumberGenerator</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">random</span><span class="params">()</span></span> -&gt; <span class="type">Double</span></div><div class="line">&#125;</div><div class="line">	</div><div class="line">	</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearCongruentialGenerator</span>: <span class="title">RandomNumberGenerator</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> lastRandom = <span class="number">42.0</span></div><div class="line">    <span class="keyword">let</span> m = <span class="number">139968.0</span></div><div class="line">    <span class="keyword">let</span> a = <span class="number">3877.0</span></div><div class="line">    <span class="keyword">let</span> <span class="built_in">c</span> = <span class="number">29573.0</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">random</span><span class="params">()</span></span> -&gt; <span class="type">Double</span> &#123;</div><div class="line">        lastRandom = ((lastRandom * a + <span class="built_in">c</span>) % m)</div><div class="line">        <span class="keyword">return</span> lastRandom / m</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> generator = <span class="type">LinearCongruentialGenerator</span>()</div><div class="line">	</div><div class="line">generator.random()      <span class="comment">// 0.37464991998171</span></div></pre></td></tr></table></figure>
<p>另外，如果我们需要在方法中修改实例，则在方法前添加mutating关键字，与结构体中方法的定义是一样的。需要注意的是，只有在结构体和枚举的实现中才需要加mutating，类的实现是不需要的。</p>
<h2 id="该Protocol做为类型"><a href="#该Protocol做为类型" class="headerlink" title="该Protocol做为类型"></a>该Protocol做为类型</h2><p>Protocol可以作为一种类型在代码中使用。因为它是一种类型，所以在很多情况下都可以使用，包括</p>
<ol>
<li>作为函数、方法、初始化方法的参数或返回值</li>
<li>作为常量、变量或属性的类型</li>
<li>作为数组、字典或其它容器的元素</li>
</ol>
<p>基于此，Protocol也可以放入集合中，如数组、字典等。</p>
<p>下面是将Protocol作为类型的例子</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dice</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> sides: <span class="type">Int</span></div><div class="line">    <span class="keyword">let</span> generator: <span class="type">RandomNumberGenerator</span></div><div class="line">    <span class="keyword">init</span> (sides: <span class="type">Int</span>, generator: <span class="type">RandomNumberGenerator</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.sides = sides</div><div class="line">        <span class="keyword">self</span>.generator = generator</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">roll</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="type">Int</span>(generator.random() * <span class="type">Double</span>(sides)) + <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="comment">// 具体使用</span></div><div class="line"><span class="keyword">var</span> dice = <span class="type">Dice</span>(sides: <span class="number">6</span>, generator: <span class="type">LinearCongruentialGenerator</span>())</div></pre></td></tr></table></figure>
<h2 id="代理-Delegation"><a href="#代理-Delegation" class="headerlink" title="代理(Delegation)"></a>代理(Delegation)</h2><p>Swift与Objective-C的代理一样，允许将一个类或结构体的一些处理放到另外一个类型中(代理类)。Swift中代理模式的实现就是通过定义一个Protocol来封装代理方法，然后具体的实现类来实现这些代理方法。代理可以用于响应特定的行为，或者从外部资源获取数据，而不需要知道这些资源的类型。</p>
<p>如下是一个实现UITableView代理的简单例子</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">UITableViewDelegate</span>, <span class="title">UITableViewDataSource</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> tableView: <span class="type">UITableView</span>?</div><div class="line">                            </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></div><div class="line">        </div><div class="line">        tableView = <span class="type">UITableView</span>(frame: <span class="keyword">self</span>.view.bounds, style: <span class="type">UITableViewStyle</span>.<span class="type">Plain</span>)</div><div class="line">        tableView!.delegate = <span class="keyword">self</span></div><div class="line">        tableView!.dataSource = <span class="keyword">self</span></div><div class="line">    &#125;</div><div class="line">	</div><div class="line">	<span class="comment">// 实现UITableViewDataSource</span></div><div class="line">	</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView!, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">20</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView!, cellForRowAtIndexPath indexPath: NSIndexPath!)</span></span> -&gt; <span class="type">UITableViewCell</span>! &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="在扩展中实现Protocol"><a href="#在扩展中实现Protocol" class="headerlink" title="在扩展中实现Protocol"></a>在扩展中实现Protocol</h2><p>如果我们想让某个已存在的类型(我们没有源码的情况下)实现某个Protocol，则可以借助扩展。当类型的扩展实现了Protocol时，该类会自动实现Protocol(听着有点绕口)。但如果类型已经实现了Protocol的所有必须的方法(类型未采用Protocol)，这种情况下，若想让类型采用Protocol，则可以使用一个空的扩展来声明类型采用Protocol。如下代码所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TextRepresentable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">asText</span><span class="params">()</span></span> -&gt; <span class="type">String</span></div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hamster</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">asText</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"A Hamster"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Hamster</span> : <span class="title">TextRepresentable</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<h2 id="Protocol继承"><a href="#Protocol继承" class="headerlink" title="Protocol继承"></a>Protocol继承</h2><p>一个Protocol可以继承自一个或多个Protocol，并在自己的实现中添加更多的功能需求。Protocol继承的语法与类型继承是一样的，其语法如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">InheritingProtocol</span> : <span class="title">SomeProtocol</span>, <span class="title">AnotherProtocol</span> </span>&#123;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的例子中，所有实现子InheritingProtocol的类型都必须实现InheritingProtocol、SomeProtocol、AnotherProtocol三者中所有的必要功能。</p>
<h2 id="Protocol组合"><a href="#Protocol组合" class="headerlink" title="Protocol组合"></a>Protocol组合</h2><p>让一个类型同时实现多个Protocol是很有用的。这种情况下，我们可以使用Protocol组合来将多个Protocol组合成一个整体。其语法如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span>&lt;<span class="title">SomeProtocol</span>, <span class="title">AnotherProtocol</span>&gt;</span></div></pre></td></tr></table></figure>
<p>我们可以将多个Protocol放在&lt;&gt;中，在使用时，我们将其当成一个整体来处理，这种组合的实际含义是：任何同时实现&lt;&gt;所有Protocol的类型。让我们看看下面的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">P1</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> variable1 : <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">P2</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> variable2 : <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> : <span class="title">P1</span>, <span class="title">P2</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> variable1: <span class="type">String</span></div><div class="line">    <span class="keyword">var</span> variable2: <span class="type">Int</span></div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcWithProtocols</span><span class="params">(protocols: <span class="keyword">protocol</span>&lt;P1, P2&gt;)</span></span> &#123;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="keyword">let</span> st = <span class="type">MyStruct</span>(variable1: <span class="string">"v"</span>, variable2: <span class="number">2</span>)</div><div class="line">	</div><div class="line">funcWithProtocols(st)</div></pre></td></tr></table></figure>
<p>需要注意的是，Protocol组合并没有定义一个新的永久的Protocol类型，它仅仅是定义了一个临时的本地Protocol，该Protocol包含了组合中所有的功能。</p>
<h2 id="检查Protocol的一致性"><a href="#检查Protocol的一致性" class="headerlink" title="检查Protocol的一致性"></a>检查Protocol的一致性</h2><p>我们可以使用is操作符来检查Protocol的一致性，用as操作符来作Protocol转换。</p>
<ol>
<li>如果is操作符返回true，则一个实例实现了protocol，否则没有</li>
<li>as?操作符返回protocol类型的可选值，如果实例没有实现protocol，则返回nil</li>
<li>as操作符强制作类型转换，如果实例没有实现protocol，则引发一个错误</li>
</ol>
<p>需要注意的是，只有当protocol使用@objc属性标记时，才可以检查其一致性。@objc属性表明protocol应该暴露给Objective-C代码。但即使我们的代码不与Objective-C交互，如果需要对protocol进行一致性检测，也需要使用这个属性。另外@objc标明的protocol只能被类实现，而不能被结构体或枚举实现。</p>
<p>我们举个具体的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">HasArea</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> area: <span class="type">Double</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>: <span class="title">HasArea</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> pi = <span class="number">3.1415927</span></div><div class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span></div><div class="line">    <span class="keyword">var</span> area: <span class="type">Double</span> &#123; <span class="keyword">return</span> pi * radius * radius &#125;</div><div class="line">    <span class="keyword">init</span>(radius: <span class="type">Double</span>) &#123; <span class="keyword">self</span>.radius = radius &#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Country</span>: <span class="title">HasArea</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> area: <span class="type">Double</span></div><div class="line">    <span class="keyword">init</span>(area: <span class="type">Double</span>) &#123; <span class="keyword">self</span>.area = area &#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> legs: <span class="type">Int</span></div><div class="line">    <span class="keyword">init</span>(legs: <span class="type">Int</span>) &#123; <span class="keyword">self</span>.legs = legs &#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="keyword">let</span> objects: <span class="type">AnyObject</span>[] = [</div><div class="line">    <span class="type">Circle</span>(radius: <span class="number">2.0</span>),</div><div class="line">    <span class="type">Country</span>(area: <span class="number">243_610</span>),</div><div class="line">    <span class="type">Animal</span>(legs: <span class="number">4</span>)</div><div class="line">]</div><div class="line">	</div><div class="line"><span class="keyword">for</span> object : <span class="type">AnyObject</span> <span class="keyword">in</span> objects &#123;</div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> objectWithArea = object <span class="keyword">as</span>? <span class="type">HasArea</span> &#123;</div><div class="line">        <span class="built_in">println</span>(<span class="string">"Area is \(objectWithArea.area)"</span>)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">println</span>(<span class="string">"Something that doesn't have an area"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="comment">// Area is 12.5663708</span></div><div class="line"><span class="comment">// Area is 243610.0</span></div><div class="line"><span class="comment">// Something that doesn't have an area</span></div></pre></td></tr></table></figure>
<h2 id="可选需求"><a href="#可选需求" class="headerlink" title="可选需求"></a>可选需求</h2><p>与Objective-C类似，Swift的Protocol可以定义一些可选的需求，这些需求在实现类型中可以选择性的实现。我们使用@optional修饰符来定义这些需求。</p>
<p>一个可选的需求可以通过可选链来实现，这个可选链可以满足当某个类型没有实现所采用的Protocol的可选需求。这种调用的基本语法如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">someOptionalMethod?(someArgument)</div></pre></td></tr></table></figure>
<p>另外，可选的方法如果有返回值，总是返回一个可选值，以满足可能未被实现的需求。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/06/27/ios-swift-extension/" itemprop="url">
                  Swift扩展(Extension)基础
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-06-27T20:54:59+08:00" content="2014-06-27">
              2014-06-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>扩展(Extension)用于为已存在的类、结构体或枚举添加新的功能。它类似于Objecitve-C中的分类，不同的是Swift的扩展没有名字</p>
<p>Swift的扩展可以做以下事情：</p>
<ul>
<li>添加计算属性和静态计算属性</li>
<li>定义实例方法和类型方法</li>
<li>提供新的初始化方法</li>
<li>定义下标操作符</li>
<li>定义并使用新的嵌套类型</li>
<li>让已存在类型实现一个协议</li>
</ul>
<p>在定义类型的扩展后，访扩展中的功能可以用于类型所有已存在的实例中，即使这些实例在扩展之前定义。</p>
<p>我们使用关键字extension来声明一个扩展，一个扩展可以让类型实现一个或多个协议，如代码清单1所示：</p>
<p><strong>代码清单1</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SomeType</span>: <span class="title">SomeProtocol</span>, <span class="title">AnotherProtocol</span> </span>&#123;</div><div class="line">    <span class="comment">// implementation of protocol requirement goes here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们分别介绍如何去扩展一个已有类型的各种功能</p>
<h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>扩展可以添加实例计算属性和类型计算属性。如代码清单2所示：</p>
<p><strong>代码清单2</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Double</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> km: <span class="type">Double</span> &#123;<span class="keyword">return</span> <span class="keyword">self</span> * <span class="number">1_000.0</span>&#125;</div><div class="line">    <span class="keyword">var</span> m: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> &#125;</div><div class="line">    <span class="keyword">var</span> cm: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> / <span class="number">100.0</span> &#125;</div><div class="line">    <span class="keyword">var</span> mm: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> / <span class="number">1_000.0</span> &#125;</div><div class="line">    <span class="keyword">var</span> ft: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> / <span class="number">3.28084</span> &#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="keyword">let</span> onInch = <span class="number">25.4</span>.mm        <span class="comment">// 0.0254</span></div><div class="line"><span class="keyword">let</span> threeFeet = <span class="number">3</span>.ft        <span class="comment">// 0.914399970739201</span></div></pre></td></tr></table></figure>
<p>上例扩展了Double，并定义了一些实例计算属性。我们可以将其用于Double的实例，也可以用于Double类型的字面值。</p>
<p>需要注意的是，扩展可以添加新的计算属性，但不能添加存储属性，也不能给已存在的属性添加观察者</p>
<h2 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h2><p>扩展可以为已存在类型添加新的初始化方法。这可以让我们扩展某一类型以接受我们自定义的类型作为它的初始化方法，或者为现有类型提供额外的初始化方法。</p>
<p>扩展可以为类添加新的便捷初始化方法，但不能添加命名初始化方法(designated initializers)和析构方法，这两者必须由类型的原始实现来提供。</p>
<p>代码清单3定义了Rect类型，并通过扩展为其定义了一个新的初始化方法</p>
<p><strong>代码清单3</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Size</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span>, height = <span class="number">0.0</span></div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rect</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> origin = <span class="type">Point</span>()</div><div class="line">    <span class="keyword">var</span> size = <span class="type">Size</span>()</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="keyword">let</span> defaultRect = <span class="type">Rect</span>()</div><div class="line"><span class="keyword">let</span> memeberwiseRect = <span class="type">Rect</span>(origin: <span class="type">Point</span>(x: <span class="number">1.0</span>, y: <span class="number">2.0</span>), size: <span class="type">Size</span>(width: <span class="number">5.0</span>, height: <span class="number">10.0</span>))</div><div class="line">	</div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Rect</span> </span>&#123;</div><div class="line">    <span class="keyword">init</span> (center: <span class="type">Point</span>, size: <span class="type">Size</span>) &#123;</div><div class="line">        <span class="keyword">let</span> originX = center.x - (size.width / <span class="number">2</span>)</div><div class="line">        <span class="keyword">let</span> originY = center.y - size.height / <span class="number">2</span></div><div class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(origin: <span class="type">Point</span>(x: originX, y: originY), size:size)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="keyword">let</span> centerRect = <span class="type">Rect</span>(center: <span class="type">Point</span>(x: <span class="number">20.0</span>, y: <span class="number">3.0</span>), size: <span class="type">Size</span>(width: <span class="number">10.0</span>, height: <span class="number">40.0</span>))</div></pre></td></tr></table></figure>
<p>需要注意的是，如果我们提供新的初始化方法，仍然需要确保在初始化方法结束前初始化实例的所有常量和变量。</p>
<p>另外，如果我们扩展的类型的所有存储属性都有默认值，而没有定义初始化方法时，我们可以在扩展的初始化方法中调用默认的初始化方法和</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>扩展可以为已存在类型添加新的实例方法和类型方法。对于结构体和枚举类型而言，如果扩展的方法需要修改self或者它的属性的话，需要将实例方法标记为mutating(与结构体和枚举的原始实现相同)。</p>
<p><strong>代码清单4：演示了扩展方法的定义</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">repetitions</span><span class="params">(task: <span class="params">()</span></span></span> -&gt; ()) &#123;</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span>  <span class="number">0</span>..<span class="keyword">self</span> &#123;</div><div class="line">            task()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">()</span></span> &#123;        <span class="comment">// mutating</span></div><div class="line">        <span class="keyword">self</span> = <span class="keyword">self</span> * <span class="keyword">self</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="keyword">var</span> someInt = <span class="number">3</span></div><div class="line">someInt.square()</div></pre></td></tr></table></figure>
<h2 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h2><p>扩展可以为已存在类型添加新的下标。例如我们想为Int类型添加一个下标操作，指定下标为n时，返回数字从右侧起第n个数字，即</p>
<ul>
<li><p>123456789[0] = 9</p>
</li>
<li><p>123456789[1] = 8</p>
</li>
<li><p>…</p>
</li>
</ul>
<p>代码清单5给出了相应的实现</p>
<p><strong>代码清单5</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</div><div class="line">    <span class="keyword">subscript</span>(digitIndex: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">var</span> decimalBase = <span class="number">1</span></div><div class="line">            <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...digitIndex &#123;</div><div class="line">                decimalBase * <span class="number">10</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> (<span class="keyword">self</span> / decimalBase) % <span class="number">10</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="number">8738793219</span>[<span class="number">0</span>]   <span class="comment">// 9</span></div><div class="line"><span class="number">8738793219</span>[<span class="number">1</span>]   <span class="comment">// 1</span></div><div class="line"><span class="number">8738793219</span>[<span class="number">2</span>]   <span class="comment">// 2</span></div><div class="line"><span class="number">8738793219</span>[<span class="number">8</span>]   <span class="comment">// 7</span></div></pre></td></tr></table></figure>
<h2 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h2><p>扩展可以为已存在类型添加新的嵌套类型，如代码清单6所示</p>
<p><strong>代码清单6：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">extension Character &#123;</div><div class="line">    enum Kind &#123;</div><div class="line">        case Vowel, Consonant, Other</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    var kind:Kind &#123;</div><div class="line">	    switch String(self).lowercaseString &#123;</div><div class="line">	        case &quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;:</div><div class="line">	            return .Vowel</div><div class="line">	        case &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;,</div><div class="line">	             &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;:</div><div class="line">	            return .Consonant</div><div class="line">	        default:</div><div class="line">	            return .Other</div><div class="line">	    &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面为Character类型添加了一个嵌套枚举，以表示字符的类型。定义之后，嵌套类型就可以用于Character的值了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/06/27/ios-swift-property/" itemprop="url">
                  Swift属性Property
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-06-27T20:34:38+08:00" content="2014-06-27">
              2014-06-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Swift的属性与Objective-C中的属性是一样的，不同的是Swift细化了属性的类型，另外除了类之外，结构体和枚举也可以有属性。</p>
<p>Swift中有这么几种属性：</p>
<ol>
<li>存储属性(Stored properties)：存储实例的常量和变量，与类、结构体、枚举的实例相关</li>
<li>计算属性(Computed properties)：通过某种方式计算出来的属性，只与类、结构体的实例相关，枚举没有计算属性</li>
<li>类型属性(type properties)：与类型自身相关。</li>
</ol>
<p>另外，我们可以定义属性观察者来监听属性值的改变，以执行一些额外的操作。属性观察者可以添加到自定义的存储属性上，也可以添加到父类继承而来的属性上。</p>
<p>下面我们将详细介绍这些属性</p>
<h2 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h2><p>存储属性是最简单的属性，它作为类或结构体实例的一部分，用于存储常量和变量。</p>
<p>关于存储属性，有以下几点：</p>
<ol>
<li>我们可以给存储属性提供一个默认值，也可以在初始化方法中对其进行初始化，即使是常量型属性，也可以这样做。</li>
<li>如果创建一个常量结构体实例，我们不能修改该实例的变量型存储属性。这是因为结构体是值类型，当一个值类型的实例标记为常量时，它的所有属性也是常量。由于类是引用类型，所以该条不适用于类类型。</li>
<li>如果我们希望属性在使用到的时候再初始化，则可以使用懒惰存储属性(lazy stored property，使用修饰符@lazy)。懒惰存储属性总是应该定义为变量，因为常量型属性总需要在初始化方法完成之前初始化。</li>
<li>与Objective-C不同的是，Swift中的属性不需要一个与之对应的成员变量，我们不能直接访问属性的后备存储(backing store)。这种方式避免了混淆不同上下文环境下对值的访问，并将属性简化为单一、明确的声明。</li>
</ol>
<p><strong>代码清单1</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FixedLengthRange</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> firstValue:<span class="type">Int</span>      <span class="comment">// 变量存储属性</span></div><div class="line">    <span class="keyword">let</span> length:<span class="type">Int</span>          <span class="comment">// 常量存储属性</span></div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="keyword">var</span> item1 = <span class="type">FixedLengthRange</span>(firstValue: <span class="number">10</span>, length: <span class="number">10</span>)</div><div class="line">	</div><div class="line"><span class="keyword">let</span> item2 = <span class="type">FixedLengthRange</span>(firstValue: <span class="number">10</span>, length: <span class="number">10</span>)</div><div class="line"><span class="comment">//item2.firstValue = 6        // 错误：不能修改常量结构体实例的存储属性</span></div></pre></td></tr></table></figure>
<h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>计算属性并不存储实际的值，而是提供一个getter和一个可选的setter来间接获取和设置其它属性。</p>
<p>关于计算属性，有以下几点：</p>
<ol>
<li>如果计算属性的setter没有定义一个新值的变量名，则默认为newValue</li>
<li>如果只提供getter，而不提供setter，则该计算属性为只读属性</li>
<li>我们只能声明变量型只读属性，因为它们的值不是固定的</li>
<li>如果计算属性是只读的，则可以不使用get{}</li>
</ol>
<p>计算属性的实例如代码清单2：</p>
<p><strong>代码清单2</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Size</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span>, height = <span class="number">0.0</span></div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rect</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> origin = <span class="type">Point</span>()</div><div class="line">    <span class="keyword">var</span> size = <span class="type">Size</span>()</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> center:<span class="type">Point</span> &#123;          <span class="comment">// 计算属性</span></div><div class="line">	    <span class="keyword">get</span> &#123;</div><div class="line">	        <span class="keyword">let</span> centerX = origin.x + (size.width / <span class="number">2</span>)</div><div class="line">	        <span class="keyword">let</span> centerY = origin.y + (size.height / <span class="number">2</span>)</div><div class="line">	        <span class="keyword">return</span> <span class="type">Point</span>(x: centerX, y: centerY)</div><div class="line">	    &#125;</div><div class="line">	    <span class="keyword">set</span>(newCenter) &#123;            <span class="comment">// 若不提供新值变量名，则默认为newValue</span></div><div class="line">	        origin.x = newCenter.x - size.width / <span class="number">2</span></div><div class="line">	        origin.y = newCenter.y - size.height / <span class="number">2</span></div><div class="line">	    &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> maxX:<span class="type">Float</span> &#123;        <span class="comment">// 只读属性，省略get&#123;&#125;</span></div><div class="line">        <span class="keyword">return</span> <span class="type">Float</span>(origin.x) + <span class="type">Float</span>(size.width)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="keyword">var</span> square = <span class="type">Rect</span>(origin:<span class="type">Point</span>(x: <span class="number">0.0</span>, y: <span class="number">0.0</span>), size:<span class="type">Size</span>(width:<span class="number">100</span>, height:<span class="number">100</span>))</div><div class="line">	</div><div class="line"><span class="keyword">let</span> initialSquareCenter = square.center</div><div class="line">square.center = <span class="type">Point</span>(x: <span class="number">15.0</span>, y:<span class="number">15.0</span>)</div><div class="line">square.maxX</div></pre></td></tr></table></figure>
<h2 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h2><p>类型属性是与类型相关联的，而不是与类型的实例相关联。对于某一类型的所有实例，类型属性都只有一份拷贝。对于值类型，我们可以定义存储类型属性和计算类型属性。对于类，我们只能定义计算类型属性。和实例属性不同的是，我们总是需要给存储类型属性一个默认值。这是因为类型没有初始化方法来初始化类型属性。</p>
<p>类型属性的访问和设置与实例属性一样，不一样的是，类型属性通过类型来获取和设置，而不是类型的实例</p>
<p><strong>代码清单3</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AudioChannel</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">let</span> threaholdLevel = <span class="number">10</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">var</span> maxInputLevelForAllChannels = <span class="number">0</span></div><div class="line">    </div><div class="line">    <span class="keyword">var</span> currentLevel:<span class="type">Int</span> = <span class="number">0</span> &#123;</div><div class="line">	    <span class="keyword">didSet</span>&#123;</div><div class="line">	        <span class="keyword">if</span> currentLevel &gt; <span class="type">AudioChannel</span>.threaholdLevel &#123;</div><div class="line">	            currentLevel = <span class="type">AudioChannel</span>.threaholdLevel</div><div class="line">	        &#125;</div><div class="line">	        </div><div class="line">	        <span class="keyword">if</span> currentLevel &gt; <span class="type">AudioChannel</span>.maxInputLevelForAllChannels &#123;</div><div class="line">	            <span class="type">AudioChannel</span>.maxInputLevelForAllChannels = currentLevel</div><div class="line">	        &#125;</div><div class="line">	    &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="keyword">var</span> leftChannel = <span class="type">AudioChannel</span>()</div><div class="line"><span class="keyword">var</span> rightChannel = <span class="type">AudioChannel</span>()</div><div class="line">	</div><div class="line">leftChannel.currentLevel = <span class="number">7</span></div><div class="line">	</div><div class="line"><span class="built_in">println</span>(leftChannel.currentLevel)       <span class="comment">// 7</span></div><div class="line"><span class="built_in">println</span>(<span class="type">AudioChannel</span>.maxInputLevelForAllChannels)   <span class="comment">// 7</span></div><div class="line">	</div><div class="line">rightChannel.currentLevel = <span class="number">11</span></div><div class="line"><span class="built_in">println</span>(rightChannel.currentLevel)      <span class="comment">// 10</span></div><div class="line"><span class="built_in">println</span>(<span class="type">AudioChannel</span>.maxInputLevelForAllChannels)   <span class="comment">// 10</span></div></pre></td></tr></table></figure>
<h2 id="属性观察者"><a href="#属性观察者" class="headerlink" title="属性观察者"></a>属性观察者</h2><p>属性观察者用于监听和响应属性值的变化。在每次设置属性值的时候都会调用属性观察者方法，即使新旧值是一样的。我们可以为任何存储属性定义属性观察者，除了懒惰存储属性。我们同样可以在子类中给继承而来的属性添加观察者。</p>
<p>对于计算属性，我们不需要定义属性观察者，因为我们可以在计算属性的setter中直接观察并响应这种值的变化。</p>
<p>我们通过设置以下观察方法来定义观察者</p>
<ol>
<li>willSet：在属性值被存储之前设置。此时新属性值作为一个常量参数被传入。该参数名默认为newValue，我们可以自己定义该参数名</li>
<li>didSet：在新属性值被存储后立即调用。与willSet相同，此时传入的是属性的旧值，默认参数名为oldValue。</li>
</ol>
<p>willSet与didSet只有在属性第一次被设置时才会调用，在初始化时，不会去调用这些监听方法。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="南峰子" />
          <p class="site-author-name" itemprop="name">南峰子</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">83</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">南峰子</span>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1000523916'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1000523916%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
  </script>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  
  

  <div style="display: none;">
    <script src="http://s95.cnzz.com/z_stat.php?id=1000523916&web_id=1000523916" language="JavaScript"></script>
  </div>




</body>
</html>

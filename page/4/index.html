<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="南峰子的技术博客">
<meta property="og:url" content="http://southpeak.github.io/page/4/index.html">
<meta property="og:site_name" content="南峰子的技术博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="南峰子的技术博客">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://southpeak.github.io/page/4/"/>

  <title> 南峰子的技术博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-68856508-1', 'auto');
  ga('send', 'pageview');
</script>







  <div style="display: none;">
    <script src="http://s95.cnzz.com/z_stat.php?id=1000523916&web_id=1000523916" language="JavaScript"></script>
  </div>





  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">南峰子的技术博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">攀登，一步一个脚印，方能知其乐</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-techset">
          <a href="/categories/techset" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-fighter-jet"></i> <br />
            
            知识小集
          </a>
        </li>
      
        
        <li class="menu-item menu-item-swift">
          <a href="/categories/swift" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-space-shuttle"></i> <br />
            
            Swift
          </a>
        </li>
      
        
        <li class="menu-item menu-item-objectivec">
          <a href="/categories/objectivec" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-taxi"></i> <br />
            
            Objective-C
          </a>
        </li>
      
        
        <li class="menu-item menu-item-cocoa">
          <a href="/categories/cocoa" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-subway"></i> <br />
            
            Cocoa
          </a>
        </li>
      
        
        <li class="menu-item menu-item-translate">
          <a href="/categories/translate" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-rocket"></i> <br />
            
            翻译
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sourcecode">
          <a href="/categories/sourcecode" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-train"></i> <br />
            
            源码分析
          </a>
        </li>
      
        
        <li class="menu-item menu-item-something">
          <a href="/categories/something" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-bicycle"></i> <br />
            
            杂项
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/01/11/sourcecode-mantle/" itemprop="url">
                  Mantle实现分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-01-11T22:01:00+08:00" content="2015-01-11">
              2015-01-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/sourcecode/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>Mantle</code>是一个用于简化<code>Cocoa</code>或<code>Cocoa Touch</code>程序中<code>model</code>层的第三方库。通常我们的应该中都会定义大量的<code>model</code>来表示各种数据结构，而这些<code>model</code>的初始化和编码解码都需要写大量的代码。而<code>Mantle</code>的优点在于能够大大地简化这些代码。</p>
<p><code>Mantle</code>源码中最主要的内容包括：</p>
<ol>
<li><code>MTLModel</code>类：通常是作为我们的<code>Model</code>的基类，该类提供了一些默认的行为来处理对象的初始化和归档操作，同时可以获取到对象所有属性的键值集合。</li>
<li><code>MTLJSONAdapter</code>类：用于在<code>MTLModel</code>对象和<code>JSON</code>字典之间进行相互转换，相当于是一个适配器。</li>
<li><code>MTLJSONSerializing</code>协议：需要与<code>JSON</code>字典进行相互转换的<code>MTLModel</code>的子类都需要实现该协议，以方便<code>MTLJSONApadter</code>对象进行转换。</li>
</ol>
<p>在此就以这三者作为我们的分析点。</p>
<h2 id="基类MTLModel"><a href="#基类MTLModel" class="headerlink" title="基类MTLModel"></a>基类MTLModel</h2><p><code>MTLModel</code>是一个抽象类，它主要提供了一些默认的行为来处理对象的初始化和归档操作。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><code>MTLModel</code>默认的初始化方法<code>-init</code>并没有做什么事情，只是调用了下<code>[super init]</code>。而同时，它提供了一个另一个初始化方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithDictionary:(<span class="built_in">NSDictionary</span> *)dictionaryValue error:(<span class="built_in">NSError</span> **)error;</div></pre></td></tr></table></figure>
<p>其中参数<code>dictionaryValue</code>是一个字典，它包含了用于初始化对象的<code>key-value</code>对。我们来看下它的具体实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithDictionary:(<span class="built_in">NSDictionary</span> *)dictionary error:(<span class="built_in">NSError</span> **)error &#123;</div><div class="line">	...</div><div class="line">    </div><div class="line">	<span class="keyword">for</span> (<span class="built_in">NSString</span> *key <span class="keyword">in</span> dictionary) &#123;</div><div class="line"></div><div class="line">		<span class="comment">// 1. 将value标记为__autoreleasing，这是因为在MTLValidateAndSetValue函数中，</span></div><div class="line">		<span class="comment">//	  可以会返回一个新的对象存在在该变量中</span></div><div class="line">		__autoreleasing <span class="keyword">id</span> value = [dictionary objectForKey:key];</div><div class="line">		</div><div class="line">		<span class="comment">// 2. value如果为NSNull.null，会在使用前将其转换为nil</span></div><div class="line">		<span class="keyword">if</span> ([value isEqual:<span class="built_in">NSNull</span>.null]) value = <span class="literal">nil</span>;</div><div class="line">        </div><div class="line">		<span class="comment">// 3. MTLValidateAndSetValue函数利用KVC机制来验证value的值对于key是否有效，</span></div><div class="line">		<span class="comment">//	  如果无效，则使用使用默认值来设置key的值。</span></div><div class="line">		<span class="comment">//	  这里同样使用了对象的KVC特性来将value值赋值给model对应于key的属性。</span></div><div class="line">		<span class="comment">//	  有关MTLValidateAndSetValue的实现可参考源码，在此不做详细说明。</span></div><div class="line">		<span class="built_in">BOOL</span> success = <span class="built_in">MTLValidateAndSetValue</span>(<span class="keyword">self</span>, key, value, <span class="literal">YES</span>, error);</div><div class="line">		<span class="keyword">if</span> (!success) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">	&#125;</div><div class="line">    </div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>子类可以重写该方法，以在设置完对象的属性后做进一步的处理或初始化工作，不过需要记住的是：应该通过<code>super</code>来调用父类的实现。</p>
<h3 id="获取属性的键-key-、值-value"><a href="#获取属性的键-key-、值-value" class="headerlink" title="获取属性的键(key)、值(value)"></a>获取属性的键(key)、值(value)</h3><p><code>MTLModel</code>类提供了一个类方法<code>+propertyKeys</code>，该方法返回所有<code>@property</code>声明的属性所对应的名称字符串的一个集合，但不包括只读属性和<code>MTLModel</code>自身的属性。在这个类方法会去遍历<code>model</code>的所有属性，如果属性是非只读且其<code>ivar</code>值不为<code>NULL</code>，则获取到表示属性名的字符串，并将其放入到集合中，其实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSSet</span> *)propertyKeys &#123;</div><div class="line">	<span class="comment">// 1. 如果对象中已有缓存的属性名的集合，则直接返回缓存。该缓存是放在一个关联对象中。</span></div><div class="line">    <span class="built_in">NSSet</span> *cachedKeys = objc_getAssociatedObject(<span class="keyword">self</span>, <span class="built_in">MTLModelCachedPropertyKeysKey</span>);</div><div class="line">    <span class="keyword">if</span> (cachedKeys != <span class="literal">nil</span>) <span class="keyword">return</span> cachedKeys;</div><div class="line"></div><div class="line">    <span class="built_in">NSMutableSet</span> *keys = [<span class="built_in">NSMutableSet</span> set];</div><div class="line"></div><div class="line">    <span class="comment">// 2. 遍历对象所有的属性</span></div><div class="line">    <span class="comment">//	  enumeratePropertiesUsingBlock方法会沿着superclass链一直向上遍历到MTLModel，</span></div><div class="line">    <span class="comment">//	  查找当前model所对应类的继承体系中所有的属性(不包括MTLModel)，并对该属性执行block中的操作。</span></div><div class="line">    <span class="comment">//	  有关enumeratePropertiesUsingBlock的实现可参考源码，在此不做详细说明。</span></div><div class="line">    [<span class="keyword">self</span> enumeratePropertiesUsingBlock:^(objc_property_t property, <span class="built_in">BOOL</span> *stop) &#123;</div><div class="line">        mtl_propertyAttributes *attributes = mtl_copyPropertyAttributes(property);</div><div class="line">        @onExit &#123;</div><div class="line">            free(attributes);</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="comment">// 3. 过滤只读属性和ivar为NULL的属性</span></div><div class="line">        <span class="keyword">if</span> (attributes-&gt;<span class="keyword">readonly</span> &amp;&amp; attributes-&gt;ivar == <span class="literal">NULL</span>) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 4. 获取属性名字符串，并存储到集合中</span></div><div class="line">        <span class="built_in">NSString</span> *key = @(property_getName(property));</div><div class="line">        [keys addObject:key];</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    <span class="comment">// 5. 将集合缓存到关联对象中。</span></div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="built_in">MTLModelCachedPropertyKeysKey</span>, keys, OBJC_ASSOCIATION_COPY);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> keys;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有了上面这个类方法，要想获取到对象中所有属性及其对应的值就方法了。为此<code>MTLModel</code>提供了一个只读属性<code>dictionaryValue</code>来取一个包含当前<code>model</code>所有属性及其值的字典。如果属性值为<code>nil</code>，则会用<code>NSNull</code>来代替。另外该属性不会为<code>nil</code>。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDictionary</span> *dictionaryValue;</div><div class="line"></div><div class="line"><span class="comment">// 实现</span></div><div class="line">- (<span class="built_in">NSDictionary</span> *)dictionaryValue &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> dictionaryWithValuesForKeys:<span class="keyword">self</span>.class.propertyKeys.allObjects];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="合并对象"><a href="#合并对象" class="headerlink" title="合并对象"></a>合并对象</h3><p>合并对象是指将两个<code>MTLModel</code>对象按照自定义的方法将其对应的属性值进行合并。为此，在<code>MTLModel</code>定义了以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)mergeValueForKey:(<span class="built_in">NSString</span> *)key fromModel:(<span class="built_in">MTLModel</span> *)model;</div></pre></td></tr></table></figure>
<p>该方法将当前对象指定的<code>key</code>属性的值与<code>model</code>参数对应的属性值按照指定的规则来进行合并，这种规则由我们自定义的<code>-merge&lt;Key&gt;FromModel:</code>方法来确定。如果我们的子类中实现了<code>-merge&lt;Key&gt;FromModel:</code>方法，则会调用它；如果没有找到，且<code>model</code>不为<code>nil</code>，则会用<code>model</code>的属性的值来替代当前对象的属性的值。具体实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)mergeValueForKey:(<span class="built_in">NSString</span> *)key fromModel:(<span class="built_in">MTLModel</span> *)model &#123;</div><div class="line">    <span class="built_in">NSParameterAssert</span>(key != <span class="literal">nil</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 1. 根据传入的key拼接"merge&lt;Key&gt;FromModel:"字符串，并从该字符串中获取到对应的selector</span></div><div class="line">    <span class="comment">//	  如果当前对象没有实现-merge&lt;Key&gt;FromModel:方法，且model不为nil，则用model的属性值</span></div><div class="line">    <span class="comment">//	  替代当前对象的属性值</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// 	  MTLSelectorWithCapitalizedKeyPattern函数以C语言的方式来拼接方法字符串，具体实现请</span></div><div class="line">    <span class="comment">//	  参数源码，在此不详细说明</span></div><div class="line">    SEL selector = <span class="built_in">MTLSelectorWithCapitalizedKeyPattern</span>(<span class="string">"merge"</span>, key, <span class="string">"FromModel:"</span>);</div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> respondsToSelector:selector]) &#123;</div><div class="line">        <span class="keyword">if</span> (model != <span class="literal">nil</span>) &#123;</div><div class="line">            [<span class="keyword">self</span> setValue:[model valueForKey:key] forKey:key];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 2. 通过NSInvocation方式来调用对应的-merge&lt;Key&gt;FromModel:方法。</span></div><div class="line">    <span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:[<span class="keyword">self</span> methodSignatureForSelector:selector]];</div><div class="line">    invocation.target = <span class="keyword">self</span>;</div><div class="line">    invocation.selector = selector;</div><div class="line"></div><div class="line">    [invocation setArgument:&amp;model atIndex:<span class="number">2</span>];</div><div class="line">    [invocation invoke];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此外，<code>MTLModel</code>还提供了另一个方法来合并两个对象所有的属性值，即：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)mergeValuesForKeysFromModel:(<span class="built_in">MTLModel</span> *)model;</div></pre></td></tr></table></figure>
<p>需要注意的是<code>model</code>必须是当前对象所属类或其子类。</p>
<h3 id="归档对象-Archive"><a href="#归档对象-Archive" class="headerlink" title="归档对象(Archive)"></a>归档对象(Archive)</h3><p><code>Mantle</code>将对<code>MTLModel</code>的编码解码处理都放在了<code>MTLModel</code>的<code>NSCoding</code>分类中进行处理了，该分类及相关的定义都放在<code>MTLModel+NSCoding</code>文件中。</p>
<p>对于不同的属性，在编码解码过程中可能需要区别对待，为此<code>Mentle</code>定义了枚举<code>MTLModelEncodingBehavior</code>来确定一个<code>MTLModel</code>属性被编码到一个归档中的行为。其定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> : <span class="built_in">NSUInteger</span> &#123;</div><div class="line">    <span class="built_in">MTLModelEncodingBehaviorExcluded</span> = <span class="number">0</span>,			<span class="comment">// 属性绝不应该被编码</span></div><div class="line">    <span class="built_in">MTLModelEncodingBehaviorUnconditional</span>,			<span class="comment">// 属性总是应该被编码</span></div><div class="line">    <span class="built_in">MTLModelEncodingBehaviorConditional</span>,			<span class="comment">// 对象只有在其它地方被无条件编码时才应该被编码。这只适用于对象属性</span></div><div class="line">&#125; <span class="built_in">MTLModelEncodingBehavior</span>;</div></pre></td></tr></table></figure>
<p>具体每个属性的归档行为我们可以在<code>+encodingBehaviorsByPropertyKey</code>类方法中设置。<code>MTLModel</code>类为我们提供了一个默认实现，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSDictionary</span> *)encodingBehaviorsByPropertyKey &#123;</div><div class="line">	<span class="comment">// 1. 获取所有属性键值</span></div><div class="line">    <span class="built_in">NSSet</span> *propertyKeys = <span class="keyword">self</span>.propertyKeys;</div><div class="line">    <span class="built_in">NSMutableDictionary</span> *behaviors = [[<span class="built_in">NSMutableDictionary</span> alloc] initWithCapacity:propertyKeys.count];</div><div class="line"></div><div class="line">    <span class="comment">// 2. 对每一个属性进行处理</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *key <span class="keyword">in</span> propertyKeys) &#123;</div><div class="line">        objc_property_t property = class_getProperty(<span class="keyword">self</span>, key.UTF8String);</div><div class="line">        <span class="built_in">NSAssert</span>(property != <span class="literal">NULL</span>, <span class="string">@"Could not find property \"%@\" on %@"</span>, key, <span class="keyword">self</span>);</div><div class="line"></div><div class="line">        mtl_propertyAttributes *attributes = mtl_copyPropertyAttributes(property);</div><div class="line">        @onExit &#123;</div><div class="line">            free(attributes);</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="comment">// 3. 当属性为weak时，默认设置为MTLModelEncodingBehaviorConditional，否则默认为MTLModelEncodingBehaviorUnconditional，设置完后，将其封装在NSNumber中并放入字典中。</span></div><div class="line">        <span class="built_in">MTLModelEncodingBehavior</span> behavior = (attributes-&gt;<span class="keyword">weak</span> ? <span class="built_in">MTLModelEncodingBehaviorConditional</span> : <span class="built_in">MTLModelEncodingBehaviorUnconditional</span>);</div><div class="line">        behaviors[key] = @(behavior);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> behaviors;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>任何不在该返回字典中的属性都不会被归档。子类可以根据自己的需要来指定各属性的归档行为。但在实际时应该通过super来调用父类的实现。</p>
<p>而为了从归档中解码指定的属性，<code>Mantle</code>提供了以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)decodeValueForKey:(<span class="built_in">NSString</span> *)key withCoder:(<span class="built_in">NSCoder</span> *)coder modelVersion:(<span class="built_in">NSUInteger</span>)modelVersion;</div></pre></td></tr></table></figure>
<p>默认情况下，该方法会查找当前对象中类似于<strong><code>-decode&lt;Key&gt;WithCoder:modelVersion:</code></strong>的方法，如果找到便会调用相应方法，并按照自定义的方式来处理属性的解码。如果我们没有实现自定义的方法或者<code>coder</code>不需要安全编码，则会对指定的key调用<code>-[NSCoder decodeObjectForKey:]</code>方法。其具体实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)decodeValueForKey:(<span class="built_in">NSString</span> *)key withCoder:(<span class="built_in">NSCoder</span> *)coder modelVersion:(<span class="built_in">NSUInteger</span>)modelVersion &#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    SEL selector = <span class="built_in">MTLSelectorWithCapitalizedKeyPattern</span>(<span class="string">"decode"</span>, key, <span class="string">"WithCoder:modelVersion:"</span>);</div><div class="line">    <span class="comment">// 1. 如果自定义了-decode&lt;Key&gt;WithCoder:modelVersion:方法，则通过NSInvocation来调用方法</span></div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:selector]) &#123;</div><div class="line">        <span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:[<span class="keyword">self</span> methodSignatureForSelector:selector]];</div><div class="line">        invocation.target = <span class="keyword">self</span>;</div><div class="line">        invocation.selector = selector;</div><div class="line">        [invocation setArgument:&amp;coder atIndex:<span class="number">2</span>];</div><div class="line">        [invocation setArgument:&amp;modelVersion atIndex:<span class="number">3</span>];</div><div class="line">        [invocation invoke];</div><div class="line"></div><div class="line">        __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> result = <span class="literal">nil</span>;</div><div class="line">        [invocation getReturnValue:&amp;result];</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">@try</span> &#123;</div><div class="line">    	<span class="comment">// 2. 如果没有找到自定义的-decode&lt;Key&gt;WithCoder:modelVersion:方法，</span></div><div class="line">    	<span class="comment">// 	  则走以下流程。</span></div><div class="line">    	<span class="comment">//</span></div><div class="line">    	<span class="comment">// coderRequiresSecureCoding方法的具体实现请参数源码</span></div><div class="line">        <span class="keyword">if</span> (coderRequiresSecureCoding(coder)) &#123;</div><div class="line">        	<span class="comment">// 3. 如果coder要求安全编码，则会从需要安全编码的字典中取出属性所对象的类型，然后根据指定</span></div><div class="line">        	<span class="comment">//	  类型来对属性进行解码操作。</span></div><div class="line">        	<span class="comment">//	  为此，MTLModel提供了类方法allowedSecureCodingClassesByPropertyKey，来获取</span></div><div class="line">        	<span class="comment">//	  类的对象包含的所有需要安全编码的属性及其对应的类的字典。该方法首先会查看是否已有</span></div><div class="line">        	<span class="comment">//	  缓存的字典，如果没有则遍历类的所有属性。首先过滤掉那些不需要编码的属性，</span></div><div class="line">        	<span class="comment">//	  然后遍历剩下的属性，如果是非对象类型或类类型，则其对应的类型设定为NSValue，</span></div><div class="line">        	<span class="comment">//	  如果是这两者，则对应的类型即为相应类型。</span></div><div class="line">        	<span class="comment">//	  该方法的具体实现请参考源代码。</span></div><div class="line">            <span class="built_in">NSArray</span> *allowedClasses = <span class="keyword">self</span>.class.allowedSecureCodingClassesByPropertyKey[key];</div><div class="line">            <span class="built_in">NSAssert</span>(allowedClasses != <span class="literal">nil</span>, <span class="string">@"No allowed classes specified for securely decoding key \"%@\" on %@"</span>, key, <span class="keyword">self</span>.class);</div><div class="line"></div><div class="line">            <span class="keyword">return</span> [coder decodeObjectOfClasses:[<span class="built_in">NSSet</span> setWithArray:allowedClasses] forKey:key];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">        	<span class="comment">// 4. 不需要安全编码</span></div><div class="line">            <span class="keyword">return</span> [coder decodeObjectForKey:key];</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，所有的编码解码工作还得需要我们实现<code>-initWithCoder:</code>和<code>-encodeWithCoder:</code>两个方法来完成。我们在定义<code>MTLModel</code>的子类时，可以根据自己的需要来对特定的属性进行处理，不过最好调用<code>super</code>的实现来执行父类的操作。<code>MTLModel</code>对这两个方法的实现请参考源码，在此不多作说明。</p>
<h2 id="适配器MTLJSONApadter"><a href="#适配器MTLJSONApadter" class="headerlink" title="适配器MTLJSONApadter"></a>适配器MTLJSONApadter</h2><p>为了便于在<code>MTLModel</code>对象和<code>JSON</code>字典之间进行相互转换，<code>Mantle</code>提供了类<code>MTLJSONApadter</code>，作为这两者之间的一个适配器。</p>
<h3 id="MTLJSONSerializing协议"><a href="#MTLJSONSerializing协议" class="headerlink" title="MTLJSONSerializing协议"></a>MTLJSONSerializing协议</h3><p><code>Mantle</code>定义了一个协议<code>MTLJSONSerializing</code>，那些需要与<code>JSON</code>字典进行相互转换的<code>MTLModel</code>的子类都需要实现该协议，以方便<code>MTLJSONApadter</code>对象进行转换。这个协议中定义了三个方法，具体如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">MTLJSONSerializing</span></span></div><div class="line"><span class="keyword">@required</span></div><div class="line"></div><div class="line">+ (<span class="built_in">NSDictionary</span> *)JSONKeyPathsByPropertyKey;</div><div class="line"></div><div class="line"><span class="keyword">@optional</span></div><div class="line">  </div><div class="line">+ (<span class="built_in">NSValueTransformer</span> *)JSONTransformerForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">+ (Class)classForParsingJSONDictionary:(<span class="built_in">NSDictionary</span> *)JSONDictionary;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这三个方法都是类方法。其中<code>+JSONKeyPathsByPropertyKey</code>是必须实现的，它返回的字典指定了如何将对象的属性映射到<code>JSON</code>中不同的<code>key path</code>(字符串值或<code>NSNull</code>)中。任何不在此字典中的属性被认为是与<code>JSON</code>中使用的<code>key</code>值相匹配。而映射到<code>NSNull</code>的属性在<code>JSON</code>序列化过程中将不进行处理。</p>
<p><code>+JSONTransformerForKey:</code>方法指定了如何将一个<code>JSON</code>值转换为指定的属性值。反过来，转换器也用于将属性值转换成<code>JSON</code>值。如果转换器实现了<code>+&lt;key&gt;JSONTransformer</code>方法，则<code>MTLJSONAdapter</code>会使用这个具体的方法，而不使用<code>+JSONTransformerForKey:</code>方法。另外，如果不需要执行自定义的转换，则返回nil。</p>
<p>重写<code>+classForParsingJSONDictionary:</code>方法可以将当前<code>Model</code>解析为一个不同的类对象。这对象类簇是非常有用的，其中抽象基类将被传递给<code>-[MTLJSONAdapter initWithJSONDictionary:modelClass:]</code>方法，而实例化的则是子类。</p>
<p>如果我们希望<code>MTLModel</code>的一个子类能使用<code>MTLJSONApadter</code>来进行转换，则需要实现这个协议，并实现相应的方法。</p>
<h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><p><code>MTLJSONApadter</code>对象有一个只读属性，该属性即为适配器需要处理的<code>MTLModel</code>对象，其声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">MTLModel</span>&lt;<span class="built_in">MTLJSONSerializing</span>&gt; *model;</div></pre></td></tr></table></figure>
<p>可见该对象必须是实现了<code>MTLJSONSerializing</code>协议的<code>MTLModel</code>对象。该属性是只读的，因此它只能通过初始化方法来初始化。</p>
<p><code>MTLJSONApadter</code>对象不能通过<code>-init</code>来初始化，这个方法会直接断言。而是需要通过类提供的两个初始化方法来初始化，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)initWithJSONDictionary:(<span class="built_in">NSDictionary</span> *)JSONDictionary modelClass:(Class)modelClass error:(<span class="built_in">NSError</span> **)error;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)initWithModel:(<span class="built_in">MTLModel</span>&lt;<span class="built_in">MTLJSONSerializing</span>&gt; *)model;</div></pre></td></tr></table></figure>
<p>其中<code>-(id)initWithJSONDictionary:modelClass:error:</code>是使用一个字典和需要转换的类来进行初始化。字典<code>JSONDictionary</code>表示一个<code>JSON</code>数据，这个字典需要符合<code>NSJSONSerialization</code>返回的格式。如果该参数为空，则方法返回<code>nil</code>，且返回带有<code>MTLJSONAdapterErrorInvalidJSONDictionary</code>码的<code>error</code>对象。该方法的具体实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)initWithJSONDictionary:(<span class="built_in">NSDictionary</span> *)JSONDictionary modelClass:(Class)modelClass error:(<span class="built_in">NSError</span> **)error &#123;</div><div class="line">	...</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (JSONDictionary == <span class="literal">nil</span> || ![JSONDictionary isKindOfClass:<span class="built_in">NSDictionary</span>.class]) &#123;</div><div class="line">		...</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">	&#125;</div><div class="line">    </div><div class="line">	<span class="keyword">if</span> ([modelClass respondsToSelector:<span class="keyword">@selector</span>(classForParsingJSONDictionary:)]) &#123;</div><div class="line">		modelClass = [modelClass classForParsingJSONDictionary:JSONDictionary];</div><div class="line">		<span class="keyword">if</span> (modelClass == <span class="literal">nil</span>) &#123;</div><div class="line">			...</div><div class="line">            </div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">		&#125;</div><div class="line">        </div><div class="line">		...</div><div class="line">	&#125;</div><div class="line">    </div><div class="line">	...</div><div class="line">    </div><div class="line">	_modelClass = modelClass;</div><div class="line">	_JSONKeyPathsByPropertyKey = [[modelClass JSONKeyPathsByPropertyKey] <span class="keyword">copy</span>];</div><div class="line">    </div><div class="line">	<span class="built_in">NSMutableDictionary</span> *dictionaryValue = [[<span class="built_in">NSMutableDictionary</span> alloc] initWithCapacity:JSONDictionary.count];</div><div class="line">    </div><div class="line">	<span class="built_in">NSSet</span> *propertyKeys = [<span class="keyword">self</span>.modelClass propertyKeys];</div><div class="line">    </div><div class="line">	<span class="comment">// 1. 检验model的+JSONKeyPathsByPropertyKey中字典key-value对的有效性</span></div><div class="line">	<span class="keyword">for</span> (<span class="built_in">NSString</span> *mappedPropertyKey <span class="keyword">in</span> <span class="keyword">self</span>.JSONKeyPathsByPropertyKey) &#123;</div><div class="line">		<span class="comment">// 2. 如果model对象的属性不包含+JSONKeyPathsByPropertyKey返回的字典中的某个属性键值</span></div><div class="line">		<span class="comment">//	  则返回nil。即+JSONKeyPathsByPropertyKey中指定的属性键值必须是model对象所包含</span></div><div class="line">		<span class="comment">// 	  的属性。</span></div><div class="line">		<span class="keyword">if</span> (![propertyKeys containsObject:mappedPropertyKey]) &#123;</div><div class="line">			...</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">		&#125;</div><div class="line">        </div><div class="line">		<span class="keyword">id</span> value = <span class="keyword">self</span>.JSONKeyPathsByPropertyKey[mappedPropertyKey];</div><div class="line">        </div><div class="line">		<span class="comment">// 3. 如果属性不是映射到一个JSON关键路径或者是NSNull，也返回nil。</span></div><div class="line">		<span class="keyword">if</span> (![value isKindOfClass:<span class="built_in">NSString</span>.class] &amp;&amp; value != <span class="built_in">NSNull</span>.null) &#123;</div><div class="line">			...</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">    </div><div class="line">	<span class="keyword">for</span> (<span class="built_in">NSString</span> *propertyKey <span class="keyword">in</span> propertyKeys) &#123;</div><div class="line">		<span class="built_in">NSString</span> *JSONKeyPath = [<span class="keyword">self</span> JSONKeyPathForPropertyKey:propertyKey];</div><div class="line">		<span class="keyword">if</span> (JSONKeyPath == <span class="literal">nil</span>) <span class="keyword">continue</span>;</div><div class="line">        </div><div class="line">		<span class="keyword">id</span> value;</div><div class="line">		<span class="keyword">@try</span> &#123;</div><div class="line">			value = [JSONDictionary valueForKeyPath:JSONKeyPath];</div><div class="line">		&#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *ex) &#123;</div><div class="line">			...</div><div class="line">            </div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">		&#125;</div><div class="line">        </div><div class="line">		<span class="keyword">if</span> (value == <span class="literal">nil</span>) <span class="keyword">continue</span>;</div><div class="line">        </div><div class="line">		<span class="keyword">@try</span> &#123;</div><div class="line">			<span class="comment">// 4. 获取一个转换器，</span></div><div class="line">			<span class="comment">//	  如上所述，+JSONTransformerForKey:会先去查看是否有+&lt;key&gt;JSONTransformer方法，</span></div><div class="line">			<span class="comment">//    如果有则会使用这个具体的方法，如果没有，则调用相应的+JSONTransformerForKey:方法</span></div><div class="line">			<span class="comment">//	  该方法具体实现请参考源码</span></div><div class="line">			<span class="built_in">NSValueTransformer</span> *transformer = [<span class="keyword">self</span> JSONTransformerForKey:propertyKey];</div><div class="line">			<span class="keyword">if</span> (transformer != <span class="literal">nil</span>) &#123;</div><div class="line">				</div><div class="line">				<span class="comment">// 5. 获取转换器转换生的值</span></div><div class="line">				<span class="keyword">if</span> ([value isEqual:<span class="built_in">NSNull</span>.null]) value = <span class="literal">nil</span>;</div><div class="line">				value = [transformer transformedValue:value] ?: <span class="built_in">NSNull</span>.null;</div><div class="line">			&#125;</div><div class="line">            </div><div class="line">			dictionaryValue[propertyKey] = value;</div><div class="line">		&#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *ex) &#123;</div><div class="line">			...</div><div class="line">            </div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">    </div><div class="line">	<span class="comment">// 6. 初始化_model</span></div><div class="line">	_model = [<span class="keyword">self</span>.modelClass modelWithDictionary:dictionaryValue error:error];</div><div class="line">	<span class="keyword">if</span> (_model == <span class="literal">nil</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">	<span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外，<code>MTLJSONApadter</code>还提供了几个类方法来创建一个<code>MTLJSONApadter</code>对象，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ (id)modelOfClass:(Class)modelClass fromJSONDictionary:(NSDictionary *)JSONDictionary error:(NSError **)error;</div><div class="line"></div><div class="line">+ (NSArray *)modelsOfClass:(Class)modelClass fromJSONArray:(NSArray *)JSONArray error:(NSError **)error;</div><div class="line"></div><div class="line">+ (NSDictionary *)JSONDictionaryFromModel:(MTLModel&lt;MTLJSONSerializing&gt; *)model;</div></pre></td></tr></table></figure>
<p>具体实现可参考源码。</p>
<h3 id="从对象中获取JSON数据"><a href="#从对象中获取JSON数据" class="headerlink" title="从对象中获取JSON数据"></a>从对象中获取JSON数据</h3><p>从<code>MTLModel</code>对象中获取<code>JSON</code>数据是上述初始化过程中的一个逆过程。该过程由<code>-JSONDictionary</code>方法来实现，具体如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSDictionary</span> *)JSONDictionary &#123;</div><div class="line">	<span class="built_in">NSDictionary</span> *dictionaryValue = <span class="keyword">self</span>.model.dictionaryValue;</div><div class="line">	<span class="built_in">NSMutableDictionary</span> *JSONDictionary = [[<span class="built_in">NSMutableDictionary</span> alloc] initWithCapacity:dictionaryValue.count];</div><div class="line">    </div><div class="line">	[dictionaryValue enumerateKeysAndObjectsUsingBlock:^(<span class="built_in">NSString</span> *propertyKey, <span class="keyword">id</span> value, <span class="built_in">BOOL</span> *stop) &#123;</div><div class="line">		<span class="built_in">NSString</span> *JSONKeyPath = [<span class="keyword">self</span> JSONKeyPathForPropertyKey:propertyKey];</div><div class="line">		<span class="keyword">if</span> (JSONKeyPath == <span class="literal">nil</span>) <span class="keyword">return</span>;</div><div class="line">        </div><div class="line">		<span class="comment">// 1. 获取属性的值</span></div><div class="line">		<span class="built_in">NSValueTransformer</span> *transformer = [<span class="keyword">self</span> JSONTransformerForKey:propertyKey];</div><div class="line">		<span class="keyword">if</span> ([transformer.class allowsReverseTransformation]) &#123;</div><div class="line">			<span class="keyword">if</span> ([value isEqual:<span class="built_in">NSNull</span>.null]) value = <span class="literal">nil</span>;</div><div class="line">			value = [transformer reverseTransformedValue:value] ?: <span class="built_in">NSNull</span>.null;</div><div class="line">		&#125;</div><div class="line">        </div><div class="line">		<span class="built_in">NSArray</span> *keyPathComponents = [JSONKeyPath componentsSeparatedByString:<span class="string">@"."</span>];</div><div class="line">        </div><div class="line">		<span class="comment">// 2. 对于嵌套属性值的设置，会先从keypath中获取每一层属性，</span></div><div class="line">		<span class="comment">//	  如果当前层级的obj中没有该属性，则为其设置一个空字典；然后再进入下一层级，依此类推</span></div><div class="line">		<span class="comment">//	  最后设置如下形式的字典: @&#123;@"nested": @&#123;@"name": @"foo"&#125;&#125;</span></div><div class="line">		<span class="keyword">id</span> obj = JSONDictionary;</div><div class="line">		<span class="keyword">for</span> (<span class="built_in">NSString</span> *component <span class="keyword">in</span> keyPathComponents) &#123;</div><div class="line">			<span class="keyword">if</span> ([obj valueForKey:component] == <span class="literal">nil</span>) &#123;</div><div class="line">				[obj setValue:[<span class="built_in">NSMutableDictionary</span> dictionary] forKey:component];</div><div class="line">			&#125;</div><div class="line">            </div><div class="line">			obj = [obj valueForKey:component];</div><div class="line">		&#125;</div><div class="line">        </div><div class="line">		[JSONDictionary setValue:value forKeyPath:JSONKeyPath];</div><div class="line">	&#125;];</div><div class="line">    </div><div class="line">	<span class="keyword">return</span> JSONDictionary;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上可以看出，该方法实际上最终获得的是一个字典。而获得字典后，再将其序列化为<code>JSON</code>串就容易了。</p>
<p><code>MTLJSONApadter</code>也提供了一个简便的方法，来从一个<code>model</code>中获取一个<code>JSON</code>字典，其定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSDictionary</span> *)JSONDictionaryFromModel:(<span class="built_in">MTLModel</span>&lt;<span class="built_in">MTLJSONSerializing</span>&gt; *)model;</div></pre></td></tr></table></figure>
<h3 id="MTLManagedObjectAdapter"><a href="#MTLManagedObjectAdapter" class="headerlink" title="MTLManagedObjectAdapter"></a>MTLManagedObjectAdapter</h3><p>为了适应<code>Core Data</code>，<code>Mantle</code>专门定义了<code>MTLManagedObjectAdapter</code>类。该类用作<code>MTLModel</code>对象与<code>NSManagedObject</code>对象之前的转换。具体的我们在此不详细描述。</p>
<h2 id="技术点总结"><a href="#技术点总结" class="headerlink" title="技术点总结"></a>技术点总结</h2><p><code>Mantle</code>的功能主要是进行对象间数据的转换：即如何在一个<code>MTLModel</code>和一个<code>JSON</code>字典中进行数据的转换。因此，所使用的技术大都是<code>Cocoa Foundation</code>提供的功能。除了对于<code>Core Data</code>的处理之外，主要用到的技术的有如下几条：</p>
<ol>
<li><code>KVC</code>的应用：这主要体现在对<code>MTLModel</code>子类的属性赋值中，通过<code>KVC</code>机制来验证值的有效性并为属性赋值。</li>
<li><code>NSValueTransform</code>：这主要用于对<code>JSON</code>值转换为属性值的处理，我们可以自定义转换器来满足我们自己的转换需求。</li>
<li><code>NSInvocation</code>：这主要用于统一处理针对特定<code>key</code>值的一些方法的调用。比如<code>-merge&lt;Key&gt;FromModel:</code>这一类方法。</li>
<li><code>Run time</code>函数的使用：这主要用于对从一个字符串中获取到方法对应的字符串，然后通过<code>sel_registerName</code>函数来注册一个<code>selector</code>。</li>
</ol>
<p>当然在<code>Mantle</code>中还会涉及到其它的一些技术点，在此不多做叙述。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://github.com/Mantle/Mantle" target="_blank" rel="external">Mantle工程</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/01/11/tool-mantle/" itemprop="url">
                  工具篇：Mantle
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-01-11T21:55:03+08:00" content="2015-01-11">
              2015-01-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/something/" itemprop="url" rel="index">
                    <span itemprop="name">杂项</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>来源：<a href="https://github.com/Mantle/Mantle" target="_blank" rel="external">https://github.com/Mantle/Mantle</a></p>
<p>版本：1.5.3</p>
<blockquote>
<p>Mantle makes it easy to write a simple model layer for your Cocoa or Cocoa Touch application.</p>
</blockquote>
<p>由上面这句话可知，<code>Mantle</code>的目的是让我们能简化<code>Cocoa</code>和<code>Cocoa Touch</code>应用的<code>model</code>层。那先来看看通常我们是怎么处理<code>model</code>层的吧。</p>
<h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><p>在我们写代码时，总要面对不同的数据来源。这些数据可能是来自网络服务器、本地数据库或者是内存中。通常我们需要将这些数据存储到一个<code>Model</code>中。一般情况下，我们会怎么去定义一个<code>Model</code>呢？以<code>Mantle</code>官方的例子为例，可能是这样的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> : <span class="built_in">NSUInteger</span> &#123;</div><div class="line">    GHIssueStateOpen,</div><div class="line">    GHIssueStateClosed</div><div class="line">&#125; GHIssueState;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">GHIssue</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCoding</span>, <span class="title">NSCopying</span>&gt;</span></div><div class="line">  </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSURL</span> *URL;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSURL</span> *HTMLURL;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSNumber</span> *number;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) GHIssueState state;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *reporterLogin;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDate</span> *updatedAt;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) GHUser *assignee;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDate</span> *retrievedAt;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *title;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *body;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)initWithDictionary:(<span class="built_in">NSDictionary</span> *)dictionary;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>假定我们从网络服务器上获取了一组<code>GHIssue</code>对应的<code>JSON</code>数据，并已经将其转换为字典后，我们便可以用这个字典对<code>GHIssue</code>对象进行初始化了，<code>-initWithDictionary:</code>的实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)initWithDictionary:(<span class="built_in">NSDictionary</span> *)dictionary &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">self</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> == <span class="literal">nil</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    _URL = [<span class="built_in">NSURL</span> URLWithString:dictionary[<span class="string">@"url"</span>]];</div><div class="line">    _HTMLURL = [<span class="built_in">NSURL</span> URLWithString:dictionary[<span class="string">@"html_url"</span>]];</div><div class="line">    _number = dictionary[<span class="string">@"number"</span>];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ([dictionary[<span class="string">@"state"</span>] isEqualToString:<span class="string">@"open"</span>]) &#123;</div><div class="line">        _state = GHIssueStateOpen;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([dictionary[<span class="string">@"state"</span>] isEqualToString:<span class="string">@"closed"</span>]) &#123;</div><div class="line">        _state = GHIssueStateClosed;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    _title = [dictionary[<span class="string">@"title"</span>] <span class="keyword">copy</span>];</div><div class="line">    _retrievedAt = [<span class="built_in">NSDate</span> date];</div><div class="line">    _body = [dictionary[<span class="string">@"body"</span>] <span class="keyword">copy</span>];</div><div class="line">    _reporterLogin = [dictionary[<span class="string">@"user"</span>][<span class="string">@"login"</span>] <span class="keyword">copy</span>];</div><div class="line">    _assignee = [[GHUser alloc] initWithDictionary:dictionary[<span class="string">@"assignee"</span>]];</div><div class="line">    </div><div class="line">    _updatedAt = [<span class="keyword">self</span>.class.dateFormatter dateFromString:dictionary[<span class="string">@"updated_at"</span>]];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果<code>GHIssue</code>对象有归档需求，则还需要实现以下两个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)coder &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">self</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> == <span class="literal">nil</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    _URL = [coder decodeObjectForKey:<span class="string">@"URL"</span>];</div><div class="line">    _HTMLURL = [coder decodeObjectForKey:<span class="string">@"HTMLURL"</span>];</div><div class="line">    _number = [coder decodeObjectForKey:<span class="string">@"number"</span>];</div><div class="line">    _state = [coder decodeUnsignedIntegerForKey:<span class="string">@"state"</span>];</div><div class="line">    _title = [coder decodeObjectForKey:<span class="string">@"title"</span>];</div><div class="line">    _retrievedAt = [<span class="built_in">NSDate</span> date];</div><div class="line">    _body = [coder decodeObjectForKey:<span class="string">@"body"</span>];</div><div class="line">    _reporterLogin = [coder decodeObjectForKey:<span class="string">@"reporterLogin"</span>];</div><div class="line">    _assignee = [coder decodeObjectForKey:<span class="string">@"assignee"</span>];</div><div class="line">    _updatedAt = [coder decodeObjectForKey:<span class="string">@"updatedAt"</span>];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)coder &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.URL != <span class="literal">nil</span>) [coder encodeObject:<span class="keyword">self</span>.URL forKey:<span class="string">@"URL"</span>];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.HTMLURL != <span class="literal">nil</span>) [coder encodeObject:<span class="keyword">self</span>.HTMLURL forKey:<span class="string">@"HTMLURL"</span>];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.number != <span class="literal">nil</span>) [coder encodeObject:<span class="keyword">self</span>.number forKey:<span class="string">@"number"</span>];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.title != <span class="literal">nil</span>) [coder encodeObject:<span class="keyword">self</span>.title forKey:<span class="string">@"title"</span>];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.body != <span class="literal">nil</span>) [coder encodeObject:<span class="keyword">self</span>.body forKey:<span class="string">@"body"</span>];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.reporterLogin != <span class="literal">nil</span>) [coder encodeObject:<span class="keyword">self</span>.reporterLogin forKey:<span class="string">@"reporterLogin"</span>];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.assignee != <span class="literal">nil</span>) [coder encodeObject:<span class="keyword">self</span>.assignee forKey:<span class="string">@"assignee"</span>];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.updatedAt != <span class="literal">nil</span>) [coder encodeObject:<span class="keyword">self</span>.updatedAt forKey:<span class="string">@"updatedAt"</span>];</div><div class="line">    </div><div class="line">    [coder encodeUnsignedInteger:<span class="keyword">self</span>.state forKey:<span class="string">@"state"</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>额，好多代码。嗯，说实话，以前也经常写这种代码，真可谓又臭又长啊。也许我的工程中还有很多这样的Model，然后，然后……靠，好烦啊。再然后，某天，服务端的同事告诉我有N个接口需要加字段，额～～崩溃中。而且，从上面的<code>Model</code>中，我无法将其还原为对应的<code>JSON</code>串，且如果某些信息变了，那么归档的数据可能就无法使用了。</p>
<p><code>Mantle</code>就是针对这几个问题而开发的一个开源库。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>其实<code>Mantle</code>的使用还是很简单的，它最主要的就是二个类和一个协议，即：</p>
<ol>
<li><code>MTLModel</code>类：通常是作为我们的<code>Model</code>的基类，该类提供了一些默认的行为来处理对象的初始化和归档操作，同时可以获取到对象所有属性的键值集合。</li>
<li><code>MTLJSONAdapter</code>类：用于在<code>MTLModel</code>对象和<code>JSON</code>字典之间进行相互转换，相当于是一个适配器。</li>
<li><code>MTLJSONSerializing</code>协议：需要与<code>JSON</code>字典进行相互转换的<code>MTLModel</code>的子类都需要实现该协议，以方便<code>MTLJSONApadter</code>对象进行转换。</li>
</ol>
<p>还以<code>GHIssue</code>为例，我们通常会以以下方式来定义我们的<code>Model</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">GHIssue</span> : <span class="title">MTLModel</span> &lt;<span class="title">MTLJSONSerializing</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSURL</span> *URL;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSURL</span> *HTMLURL;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSNumber</span> *number;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) GHIssueState state;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>可以看到，我们的<code>Model</code>继承了通常是<code>MTLModel</code>类，同时实现了<code>MTLJSONSerializing</code>协议。这样，我们不再需要像上面那样写一大堆的赋值代码和编码解码方法，而只需要实现<code>MTLJSONSerializing</code>协议的<code>+JSONKeyPathsByPropertyKey</code>类方法，将我们的属性名的键值与<code>JSON</code>字典的键值做一个映射，我们便可以在<code>MTLJSONAdapter</code>对象的帮助下自动进行赋值操作和编码解码操作。我们来看看<code>GHIssue</code>类的具体实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">GHIssue</span></span></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">+ (<span class="built_in">NSDictionary</span> *)JSONKeyPathsByPropertyKey &#123;</div><div class="line">    <span class="keyword">return</span> @&#123;</div><div class="line">        <span class="string">@"URL"</span>: <span class="string">@"url"</span>,</div><div class="line">        <span class="string">@"HTMLURL"</span>: <span class="string">@"html_url"</span>,</div><div class="line">        <span class="string">@"reporterLogin"</span>: <span class="string">@"user.login"</span>,</div><div class="line">        <span class="string">@"assignee"</span>: <span class="string">@"assignee"</span>,</div><div class="line">        <span class="string">@"updatedAt"</span>: <span class="string">@"updated_at"</span></div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>可以看到，<code>Model</code>对象的属性与<code>JSON</code>数据之间的映射是通过字典来实现的。通过这种对应关系，<code>Model</code>对象便可以和<code>JSON</code>数据相互转换。需要注意的是返回中字典中的<code>key</code>值在<code>Model</code>对象中必须有对应的属性，否则Model对象将无法初始化成功。</p>
<p>当然这两者的值之间的转换关系可能需要我们自己来定义，这时我们就可以在<code>Model</code>中自定义<code>+(NSValueTransformer *)&lt;key&gt;JSONTransformer</code>方法来完成这一操作，如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">GHIssue</span></span></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">+ (<span class="built_in">NSValueTransformer</span> *)URLJSONTransformer &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSValueTransformer</span> valueTransformerForName:<span class="built_in">MTLURLValueTransformerName</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="built_in">NSValueTransformer</span> *)HTMLURLJSONTransformer &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSValueTransformer</span> valueTransformerForName:<span class="built_in">MTLURLValueTransformerName</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="built_in">NSValueTransformer</span> *)stateJSONTransformer &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSValueTransformer</span> mtl_valueMappingTransformerWithDictionary:@&#123;</div><div class="line">        <span class="string">@"open"</span>: @(GHIssueStateOpen),</div><div class="line">        <span class="string">@"closed"</span>: @(GHIssueStateClosed)</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>​    </p>
<p>这样，在转换过程中，会自动调用这些方法来做数据的转换。而如果没有实现相应的方法，则会调用默认的<code>+JSONTransformerForKey:</code>来做处理，具体的实现可以参考<a href="http://southpeak.github.io/blog/2015/01/11/sourcecode-mantle/">《Mantle实现分析》</a>。</p>
<p>有了上面这些准备工作，我们就需要通过<code>MTLJSONAdapter</code>类来适配<code>MTLModel</code>对象和<code>JSON</code>数据了，这个更容易了，代码如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line"></div><div class="line"><span class="built_in">NSDictionary</span> *JSONDictionary = ...;</div><div class="line"></div><div class="line">GHIssue *issue = [<span class="built_in">MTLJSONAdapter</span> modelOfClass:GHIssue.class fromJSONDictionary:JSONDictionary error:&amp;error];</div></pre></td></tr></table></figure>
<p>这样就根据一个<code>JSON</code>字典创建了一个<code>GHIssue</code>对象，而如果要从这个对象中获取到相应的<code>JSON</code>字典，则可以如下操作：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSDictionary</span> *JSONDictionary = [<span class="built_in">MTLJSONAdapter</span> JSONDictionaryFromModel:issue];</div></pre></td></tr></table></figure>
<p>以上便是<code>Mantle</code>的简单使用，当然更多的使用方式还需要在实践中多挖掘了。</p>
<p>这里还需要注意的是：</p>
<ol>
<li><code>MTLModel</code>的转换只针对我们定义的属性，而无法支持成员变量。</li>
<li>支持嵌套属性的转换，这对于对象属性来说非常有用。</li>
</ol>
<h2 id="导入工程"><a href="#导入工程" class="headerlink" title="导入工程"></a>导入工程</h2><p>想在我们的工程中使用<code>Mantle</code>，可以通过以下步骤导入：</p>
<ol>
<li>将<code>Mantle</code>库作为应用的子模块添加进来。</li>
<li>运行<code>Mantle</code>文件夹下的<code>script/bootstrap</code>脚本。</li>
<li>将<code>Mantle.xcodeproj</code>拖进我们的<code>XCode</code>工程或工作空间。</li>
<li>在程序<code>target</code>的<code>Build Phases</code>选项卡中，在<code>Link Binary With Libraries</code>下添加<code>Mantle</code>的相关信息。在<code>iOS</code>工程中，添加<code>libMantle.a</code>库。</li>
<li>在<code>&quot;Header Search Paths&quot;</code>设置中添加<code>&quot;$(BUILD_ROOT)/../IntermediateBuildFilesPath/UninstalledProducts/include&quot; $(inherited)</code>。</li>
<li>对于<code>iOS</code>目标，在<code>&quot;Other Linker Flags&quot;</code>设置中添加<code>-ObjC</code>。</li>
<li>如果我们将<code>Mantle</code>添加到工程(而不是工作空间)，则我们需要将<code>Mantle</code>依赖的库添加到程序的<code>&quot;Target Dependencies&quot;</code>中。</li>
</ol>
<p>不过，我还是喜欢用<code>CocoaPods</code>来处理，只需要在<code>Podfile</code>中添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod &apos;Mantle&apos;, &apos;~&gt; 1.5.3&apos;</div></pre></td></tr></table></figure>
<p>然后在对应目录下运行<code>pod install</code>，稍等片刻便可以使用<code>Mantle</code>了。关于<code>CocoaPods</code>的使用，可参考<a href="https://github.com/CocoaPods/CocoaPods" target="_blank" rel="external">github上的cocoapods工程</a>。</p>
<h2 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h2><p><code>Mantle</code>使用简单方便，极大的简化了我们的代码，可以满足我们大部分的需求。不过有时候我们可能会遇到这样的情况，由服务端提供的两个接口A和B，其实际上返回的数据可以转换为程序的同一个<code>Model</code>，只不过由于提供接口的是两个人，而且没有相互约定；抑或是服务端接口返回的数据与本地数据库的数据可以转换化同一个<code>Model</code>，但由于历史原因，这两者的字段也没对应上，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// A接口返回的JSON数据为</span></div><div class="line">&#123;<span class="string">"user"</span>: <span class="string">"abc"</span>, <span class="string">"password"</span>: <span class="string">"abc"</span>&#125;</div><div class="line"></div><div class="line"><span class="comment">// B接口返回的JSON数据为</span></div><div class="line">&#123;<span class="string">"user"</span>: <span class="string">"123"</span>, <span class="string">"pwd"</span>: <span class="string">"123"</span>&#125;</div></pre></td></tr></table></figure>
<p>这种情况下如何使用<code>Mantle</code>呢？看着实际上都一样，只是字段名不一样。这时似乎就不好处理了。因为<code>+JSONKeyPathsByPropertyKey</code>中，字典的<code>key</code>表示的是<code>MTLModel</code>的属性键值，是通过属性的键值去找相应的<code>JSON</code>数据的<code>key</code>。因此，这种情况下可能就得定义两个<code>Model</code>了。</p>
<p>在我们之前的工程中，也有做过类似<code>Mantle</code>的处理，只不过没有做得这么细致。针对上面的问题，我们的方案是刚好反过来，这个映射字典的key是<code>JSON</code>字典的<code>key</code>值，而映射字典的<code>value</code>是对象属性的<code>key</code>值。这样，我们就可以将不回数据来源的<code>JSON</code>字典的不同<code>key</code>映射到同一个<code>Model</code>对象的同一个属性上了。</p>
<p>另外一方面，由于转换过程涉及到一些映射查找操作，所以性能上也不如直接写赋值语句来得快。不过<code>Mantle</code>已以通过缓存对此做了优化，所以这一点还是可以接受的。</p>
<h2 id="参考与推荐"><a href="#参考与推荐" class="headerlink" title="参考与推荐"></a>参考与推荐</h2><ol>
<li><a href="https://github.com/Mantle/Mantle" target="_blank" rel="external">Mantle工程</a></li>
<li><a href="http://southpeak.github.io/blog/2015/01/11/yuan-ma-pian-:mantle/">源码篇：Mantle</a></li>
<li><a href="http://ourui.github.io/blog/2014/01/22/mantle-use/" target="_blank" rel="external">Mantle 初步使用</a></li>
<li><a href="http://blog.codingcoder.com/use-mantle-to-model/" target="_blank" rel="external">使用Mantle处理Model层对象</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/01/08/quartz2d-13/" itemprop="url">
                  Quartz 2D编程指南之十三：PDF文档的创建、显示及转换
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-01-08T22:51:40+08:00" content="2015-01-08">
              2015-01-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>PDF文档存储依赖于分辨率的向量图形、文本和位图，并用于程序的一系列指令中。一个PDF文档可以包含多页的图形和文本。PDF可用于创建跨平台、只读的文档，也可用于绘制依赖于分辨率的图形。</p>
<p>Quartz为所有应用程序创建高保真的PDF文档，这些文档保留应用的绘制操作，如图13-1所示。PDF文档的结果将通过系统的其它部分或第三方法的产品来有针对性地进行优化。Quartz创建的PDF文档在Preview和Acrobat中都能正确的显示。</p>
<p><strong>Figure 13-1  Quartz creates high-quality PDF documents</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/postscript_to_PDF.gif" alt="image"></p>
<p>Quartz不仅仅只使用PDF作为它的数字页，它同样包含一些API来显示和生成PDF文件，及完成一些其它PDF相关的工作。</p>
<h2 id="打开和查看PDF"><a href="#打开和查看PDF" class="headerlink" title="打开和查看PDF"></a>打开和查看PDF</h2><p>Quartz提供了CGPDFDocumentRef数据类型来表示PDF文档。我们可以使用CGPDFDocumentCreateWithProvider或CGPDFDocumentCreateWithURL来创建CGPDFDocument对象。在创建CGPDFDocument对象后，我们可以将其绘制到图形上下文中。图13-2显示了在一个窗体中绘制PDF文档。</p>
<p><strong>Figure 13-2  A PDF document</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/rooster_up.gif" alt="image"></p>
<p>代码清单13-1显示了如何创建一个CGPDFDocument对象及获取文档的页数。</p>
<p><strong>Listing 13-1  Creating a CGPDFDocument object from a PDF file</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function">CGPDFDocumentRef <span class="title">MyGetPDFDocumentRef</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span></div><div class="line">&#123;</div><div class="line">    CFStringRef path;</div><div class="line">    CFURLRef url;</div><div class="line">    CGPDFDocumentRef document;</div><div class="line">    <span class="keyword">size_t</span> count;</div><div class="line"> </div><div class="line">    path = CFStringCreateWithCString (<span class="literal">NULL</span>, filename,</div><div class="line">                         kCFStringEncodingUTF8);</div><div class="line">    url = CFURLCreateWithFileSystemPath (<span class="literal">NULL</span>, path, </div><div class="line">                        kCFURLPOSIXPathStyle, <span class="number">0</span>);</div><div class="line">    CFRelease (path);</div><div class="line">    document = CGPDFDocumentCreateWithURL (url);</div><div class="line">    CFRelease(url);</div><div class="line">    count = CGPDFDocumentGetNumberOfPages (document);</div><div class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"`%s' needs at least one page!"</span>, filename);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> document;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码清单显示了如何将一个PDF页绘制到图形上下文中。</p>
<p><strong>Listing 13-2  Drawing a PDF page</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDisplayPDFPage</span> <span class="params">(CGContextRef myContext,</span></span></div><div class="line">                    <span class="keyword">size_t</span> pageNumber,</div><div class="line">                    <span class="keyword">const</span> <span class="keyword">char</span> *filename)</div><div class="line">&#123;</div><div class="line">    CGPDFDocumentRef document;</div><div class="line">    CGPDFPageRef page;</div><div class="line"> </div><div class="line">    document = MyGetPDFDocumentRef (filename);</div><div class="line">    page = CGPDFDocumentGetPage (document, pageNumber);</div><div class="line">    CGContextDrawPDFPage (myContext, page);</div><div class="line">    CGPDFDocumentRelease (document);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="为PDF页创建一个转换"><a href="#为PDF页创建一个转换" class="headerlink" title="为PDF页创建一个转换"></a>为PDF页创建一个转换</h2><p>Quartz提供了函数CGPDFPageGetDrawingTransform来创建一个仿射变换，该变换基于将PDF页的BOX映射到指定的矩形中。函数原型是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">CGAffineTransform <span class="title">CGPDFPageGetDrawingTransform</span> <span class="params">(</span></span></div><div class="line">        CGPPageRef page,</div><div class="line">        CGPDFBox box,</div><div class="line">        CGRect rect,</div><div class="line">        <span class="keyword">int</span> rotate,</div><div class="line">        <span class="keyword">bool</span> preserveAspectRatio</div><div class="line">);</div></pre></td></tr></table></figure>
<p>该函数通过如下算法来返回一个仿射变换：</p>
<ol>
<li>将在box参数中指定的PDF box的类型相关的矩形(media, crop, bleed, trim, art)与指定的PDF页的/MediaBox入口求交集。相交的部分即为一个有效的矩形(effectiverectangle)。</li>
<li>将effective rectangle旋转参数/Rotate入口指定的角度。</li>
<li>将得到的矩形放到rect参数指定的中间。</li>
<li>如果rotate参数是一个非零且是90的倍数，函数将effective rectangel旋转该值指定的角度。正值往右旋转；负值往左旋转。需要注意的是我们传入的是角度，而不是弧度。记住PDF页的/Rotate入口也包含一个旋转，我们提供的rotate参数是与/Rotate入口接合在一起的。</li>
<li>如果需要，可以缩放矩形，从而与我们提供的矩形保持一致。</li>
<li>如果我们通过传递true值给preserveAspectRadio参数以指定保持长宽比，则最后的矩形将与rect参数的矩形的边一致。</li>
</ol>
<p>【注：上面这段翻译得不是很好】</p>
<p>例如，我们可以使用这个函数来创建一个与图13-3类似的PDF浏览程序。如果我们提供一个Rotate Left/Rotate Right属性，则可以调用CGPDFPageGetDrawingTransform来根据当前的窗体大小和旋转设置计算出适当的转换。</p>
<p><strong>Figure 13-3  A PDF page rotated 90 degrees to the right</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/rooster_rotate.gif" alt="image"></p>
<p>程序清单13-3显示了为一个PDF页创建及应用仿射变换，然后绘制PDF。</p>
<p><strong>Listing 13-3  Creating an affine transform for a PDF page</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDrawPDFPageInRect</span> <span class="params">(CGContextRef context,</span></span></div><div class="line">                    CGPDFPageRef page,</div><div class="line">                    CGPDFBox box,</div><div class="line">                    CGRect rect,</div><div class="line">                    <span class="keyword">int</span> rotation,</div><div class="line">                    <span class="keyword">bool</span> preserveAspectRatio)</div><div class="line">&#123;</div><div class="line">    CGAffineTransform m;</div><div class="line"> </div><div class="line">    m = CGPDFPageGetDrawingTransform (page, box, rect, rotation,</div><div class="line">                                    preserveAspectRato);</div><div class="line">    CGContextSaveGState (context);</div><div class="line">    CGContextConcatCTM (context, m);</div><div class="line">    CGContextClipToRect (context,CGPDFPageGetBoxRect (page, box));</div><div class="line">    CGContextDrawPDFPage (context, page);</div><div class="line">    CGContextRestoreGState (context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="创建PDF文件"><a href="#创建PDF文件" class="headerlink" title="创建PDF文件"></a>创建PDF文件</h2><p>使用Quartz创建PDF与绘制其它图形上下文一下简单。我们指定一个PDF文件地址，设置一个PDF图形上下文，并使用与其它图形上下文一样的绘制程序。如代码清单13-4所示的MyCreatePDFFile函数，显示了创建一个PDF的所有工作。</p>
<p>注意，代码在CGPDFContextBeginPage和CGPDFContextEndPage中来绘制PDF。我们可以传递一个CFDictionary对象来指定页属性，包括media, crop, bleed,trim和art boxes。</p>
<p><strong>Listing 13-4  Creating a PDF file</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyCreatePDFFile</span> <span class="params">(CGRect pageRect, <span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span></div><div class="line">&#123;</div><div class="line">    CGContextRef pdfContext;</div><div class="line">    CFStringRef path;</div><div class="line">    CFURLRef url;</div><div class="line">    CFDataRef boxData = <span class="literal">NULL</span>;</div><div class="line">    CFMutableDictionaryRef myDictionary = <span class="literal">NULL</span>;</div><div class="line">    CFMutableDictionaryRef pageDictionary = <span class="literal">NULL</span>;</div><div class="line"> </div><div class="line">    path = CFStringCreateWithCString (<span class="literal">NULL</span>, filename, </div><div class="line">                                kCFStringEncodingUTF8);</div><div class="line">    url = CFURLCreateWithFileSystemPath (<span class="literal">NULL</span>, path, </div><div class="line">                     kCFURLPOSIXPathStyle, <span class="number">0</span>);</div><div class="line">    CFRelease (path);</div><div class="line">    myDictionary = CFDictionaryCreateMutable(<span class="literal">NULL</span>, <span class="number">0</span>,</div><div class="line">                        &amp;kCFTypeDictionaryKeyCallBacks,</div><div class="line">                        &amp;kCFTypeDictionaryValueCallBacks); </div><div class="line">    CFDictionarySetValue(myDictionary, kCGPDFContextTitle, CFSTR(<span class="string">"My PDF File"</span>));</div><div class="line">    CFDictionarySetValue(myDictionary, kCGPDFContextCreator, CFSTR(<span class="string">"My Name"</span>));</div><div class="line">    pdfContext = CGPDFContextCreateWithURL (url, &amp;pageRect, myDictionary); </div><div class="line">    CFRelease(myDictionary);</div><div class="line">    CFRelease(url);</div><div class="line">    pageDictionary = CFDictionaryCreateMutable(<span class="literal">NULL</span>, <span class="number">0</span>,</div><div class="line">                        &amp;kCFTypeDictionaryKeyCallBacks,</div><div class="line">                        &amp;kCFTypeDictionaryValueCallBacks); </div><div class="line">    boxData = CFDataCreate(<span class="literal">NULL</span>,(<span class="keyword">const</span> UInt8 *)&amp;pageRect, <span class="keyword">sizeof</span> (CGRect));</div><div class="line">    CFDictionarySetValue(pageDictionary, kCGPDFContextMediaBox, boxData);</div><div class="line">    CGPDFContextBeginPage (pdfContext, pageDictionary); </div><div class="line">    myDrawContent (pdfContext);</div><div class="line">    CGPDFContextEndPage (pdfContext);</div><div class="line">    CGContextRelease (pdfContext);</div><div class="line">    CFRelease(pageDictionary); </div><div class="line">    CFRelease(boxData);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="添加链接"><a href="#添加链接" class="headerlink" title="添加链接"></a>添加链接</h2><p>我们可以在PDF上下文中添加链接和锚点。Quartz提供了三个函数，每个函数都以PDF图形上下文作为参数，还有链接的信息：</p>
<ol>
<li>CGPDFContextSetURLForRect可以让我们指定在点击当前PDF页中的矩形时打开一个URL。</li>
<li>CGPDFContextSetDestinationForRect指定在点击当前PDF页中的矩形区域时设置目标以进行跳转。我们需要提供一个目标名。</li>
<li>CGPDFContextAddDestinationAtPoint指定在点击当前PDF页中的一个点时设置目标以进行跳转。我们需要提供一个目标名。</li>
</ol>
<h2 id="保护PDF内容"><a href="#保护PDF内容" class="headerlink" title="保护PDF内容"></a>保护PDF内容</h2><p>为了保护PDF内容，我们可以在辅助字典中指定一些安全选项并传递给CGPDFContextCreate。我们可以通过包含如下关键字来设置所有者密码、用户密码、PDF是否可以被打印或拷贝：</p>
<ol>
<li>kCGPDFContextOwnerPassword: 定义PDF文档的所有者密码。如果指定该值，则文档使用所有者密码来加密；否则文档不加密。该关键字的值必须是ASCII编码的CFString对象。只有前32位是用于密码的。该值没有默认值。如果该值不能表示成ASCII，则无法创建文档并返回NULL。Quartz使用40-bit加密。</li>
<li>kCGPDFContextUserPassword: 定义PDF文档的用户密码。如果文档加密了，则该值是文档的用户密码。如果没有指定，则用户密码为空。该关键字的值必须是ASCII编码的CFString对象。只有前32位是用于密码的。如果该值不能表示成ASCII，则无法创建文档并返回NULL。</li>
<li>kCGPDFContextAllowsPrinting:指定当使用用户密码锁定时文档是否可以打印。该值必须是CFBoolean对象。默认值是kCGBooleanTrue。</li>
<li>kCGPDFContextAllowsCopying: 指定当使用用户密码锁定时文档是否可以拷贝。该值必须是CFBoolean对象。默认值是kCGBooleanTrue。</li>
</ol>
<p>代码清单14-4(下一章)显示了确认PDF文档是否被锁定，及用密码打开文档。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/01/08/quartz2d-12/" itemprop="url">
                  Quartz 2D编程指南之十二：Core Graphics层绘制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-01-08T22:47:51+08:00" content="2015-01-08">
              2015-01-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>CGLayer对象(CGLayerRef数据类型)允许程序使用层来进行绘制。</p>
<p>层适合于以下几种情况：</p>
<ol>
<li>高质量离屏渲染，以绘制我们想重用的图形。例如，我们可能要建立一个场景并重用相同的背景。将背景场景绘制于一个层上，然后在需要的时候再绘制层。一个额外的好处是我们不需要知道颜色空间或其它设备依赖的信息来绘制层。</li>
<li>重复绘制。例如，我们可能想创建一个由相同元素反复绘制而组成的模式。将元素绘制到一个层中，然后重复绘制这个层，如图12-1所示。任何我们重复绘制的Quartz对象，包括CGPath, CGShading和CGPDFPage对象，都可以通过将其绘制到CGLayer来优化性能。注意一个层不仅仅是用于离屏绘制；我们也可以将其用于那些不是面向屏幕的图形上下文，如PDF图形上下文。</li>
<li>缓存。虽然我们可以将层用于此目的，但通常不需要这样做，因为Quartz Compositor已经做了此事。如果我们必须绘制一个缓存，则使用层来代替位图图形上下文。</li>
</ol>
<p><strong>Figure 12-1  Repeatedly painting the same butterfly image</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/stamp_layers.gif" alt="image"></p>
<p>CGLayer对象和透明层是与CGPath对象以及CGContext函数创建的路径并行的。对于一个CGLayer或者CGPath对象，我们可以将其绘制到一个抽象目标，之后可以将其完整地绘制到另一个目标，如显示器或才PDF中。当我们在透明层上绘制或者使用绘制路径的CGContext函数时，可以直接绘制到图形上下文表示的目标上，而不需要负责组装绘制的中间抽象目标。</p>
<h2 id="层如何工作"><a href="#层如何工作" class="headerlink" title="层如何工作"></a>层如何工作</h2><p>一个层由CGLayerRef数据类型表示，是为优化性能而设计的。在可能的时候，Quartz使用合适的机制将一个CGLayer对象缓存到与之相关的Quartz图形上下文中。例如，与显卡相关的图形上下文可能将层缓存到显卡中，这样绘制在层中的内容时，就比渲染从一个位图图形上下文中构造的类似图像要快得多。基于这个原因，层比位图图形上下文更适用于离屏绘制。</p>
<p>所有的Quartz绘制函数都是绘制到图形上下文中。图形上下文提供了一个抽象的渲染目标，而将我们从目标的细节中解放出来。我们使用用户空间，Quartz执行必要的转换来将绘图正确地渲染到目标。当我们使用CGLayer对象来绘制时，我们也是绘制到图形上下文中。图12-1演示了层绘制的必要步骤。</p>
<p><strong>Figure 12-2  Layer drawing</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/layer_context.gif" alt="image"></p>
<p>所有在图形上下文中层的绘制都是以使用函数CGLayerCreateWithContext创建一个CGLayer对象开始的。用于创建CGLayer对象的图形上下文通常是一个window图形上下文。Quartz创建一个层，使得它具有图形上下文的所有特性：包括分辨率，颜色空间和图形状态设置。如果我们不想使用图形上下文的大小，则可以提供一个大小给层。在图12-2中，左侧显示了用于创建层的图形上下文。框右侧的灰色部分，即标记为CGLayer对象的部分表示新创建的层。</p>
<p>在我们可以绘制层之前，我们必须通过调用CGLayerGetContext函数来获取与层相关的图形上下文。这个图形上下文与用于创建层的图形上下文是差不多的。只要用于创建层的图形上下文是一个window图形上下文，则CGLayer图形上下文会尽可能地被缓存到GPU中。图12-2中位于框右侧的白色部分表示新创建的层图形上下文。</p>
<p>在层图形上下文中绘制与在其它图形上下文中绘制一样，将层图形上下文作为参数传给绘制函数。图12-2显示了一片绘制到层图形上下文的叶子。</p>
<p>当我们准备使用层的内容时，我们可以调用函数CGContextDrawLayerInRect或者CGContextDrawLayerAtPoint将层绘制到一个图形上下文。通常情况下，我们会将层绘制到创建层对象的图形上下文中，但这不是必须的。我们可以将层绘制到任意的图形上下文，记住：层带有创建层对象的图形上下文的所有特性，这可能会产生一些限制(如性能或分辨率)。例如，与屏幕关联的层可能会被缓存到显卡中。如果目标上下文是一个打印机或PDF上下文，则可能需要将层对象从显卡中取出并放到内存中，从而导致性能很差。</p>
<p>图12-2显示了层的内容–叶子–被重复地绘制到创建层对象的图形上下文中。我们可以在释放CGLayer对象之前，任意地重复使用层中的绘图。</p>
<h2 id="使用层来绘制"><a href="#使用层来绘制" class="headerlink" title="使用层来绘制"></a>使用层来绘制</h2><p>我们需要按照如下几个步骤来使用层对象进行绘制：</p>
<ol>
<li>创建一个使用已存在的图形上下文初始化的层对象</li>
<li>为层获取图形上下文</li>
<li>绘制到CGLayer图形上下文</li>
<li>将层绘制到目标图形上下文</li>
</ol>
<p>我们将在下面详细描述这几个步骤。</p>
<h3 id="创建一个使用已存在的图形上下文初始化的层对象"><a href="#创建一个使用已存在的图形上下文初始化的层对象" class="headerlink" title="创建一个使用已存在的图形上下文初始化的层对象"></a>创建一个使用已存在的图形上下文初始化的层对象</h3><p>函数CGLayerCreateWithContext返回一个使用已存在的图形上下文初始化的层对象。这个层对象继承了该图形上下文的所有特性，包括颜色空间、大小、分辨率和像素格式。后期当我们绘制层对象到一个目标时，Quartz会自动对层与目标上下文进行颜色匹配。</p>
<p>函数CGLayerCreateWithContext带有三个参数：</p>
<ol>
<li>用于创建层的图形上下文。通常我们传递一个window图形上下文以便后面可以离屏绘制层。</li>
<li>层相对于图形上下文的大小。层的大小可以和图形上下文一样，或者更小。如果想要获得层的大小，我们可以调用函数CGLayerGetSize。</li>
<li>一个辅助字典。这个参数现在已经不用了，所以传递NULL即可。</li>
</ol>
<h3 id="为层获取图形上下文"><a href="#为层获取图形上下文" class="headerlink" title="为层获取图形上下文"></a>为层获取图形上下文</h3><p>Quartz总是在一个图形上下文中进行绘制。现在我们有了一个层对象，我们必须创建一个与层相关的图形上下文。所有绘制到层图形上下文的内容都是层的一部分。</p>
<p>函数CGLayerGetContext获取一个层对象作为参数，并返回与之相关的图形上下文。</p>
<h3 id="绘制到CGLayer图形上下文"><a href="#绘制到CGLayer图形上下文" class="headerlink" title="绘制到CGLayer图形上下文"></a>绘制到CGLayer图形上下文</h3><p>在获取到与层相关的图形上下文之后，我们可以在层图形上下文中绘制任何东西。我们可以打开一个PDF文件或一个图像文件，并将文件内容绘制到层中。我们可以使用Quartz 2D的任何函数来绘制矩形、直线或其它绘制单元。图12-3显示了在层中绘制一个矩形和直线。</p>
<p><strong>Figure 12-3  A layer that contains two rectangles and a series of lines</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/rect_star_layer.gif" alt="image"></p>
<p>例如，为了在CGLayer图形上下文中绘制一个填充矩形，我们调用函数CGContextFillRect，并提供从CGLayerGetContext函数中获取到的图形上下文作为参数。假设这个图形上下文命名为myLayerContext，则函数调用如下：</p>
<pre><code>CGContextFillRect (myLayerContext, myRect)
</code></pre><h3 id="将层绘制到目标图形上下文"><a href="#将层绘制到目标图形上下文" class="headerlink" title="将层绘制到目标图形上下文"></a>将层绘制到目标图形上下文</h3><p>当我们已经准备好将层绘制到目标图形上下文时，我们可以使用以下任一一个函数：</p>
<ol>
<li>CGContextDrawLayerInRect：将层绘制到图形上下文中指定的矩形内。</li>
<li>CGContextDrawLayerAtPoint：将层绘制到图形上下文中指定的点。</li>
</ol>
<p>通常情况下，我们提供的目标图形上下文是一个window图形上下文，这也是我们用于创建层对象所使用的图形上下文。图12-4显示了重复绘制图12-3所绘制的层。为了达到模式效果，我们可以使用上面两个方法中的任意一个，只是每次改变偏移量而已。例如，我们每次绘制层时，可以调用函数CGContextTranslateCTM来改变坐标系统的原点。</p>
<p><strong>Figure 12-4  Drawing a layer repeatedly</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/rect_star_pattern.gif" alt="image"></p>
<blockquote>
<p>注意：我们不必要将层绘制到初始层所使用的图形上下文中。然而，如果我们将层绘制到其它图形上下文中，原始图形上下文的所有限制都会反映到我们的绘图中。</p>
</blockquote>
<h2 id="例子：使用多个CGLayer对象来绘制旗子"><a href="#例子：使用多个CGLayer对象来绘制旗子" class="headerlink" title="例子：使用多个CGLayer对象来绘制旗子"></a>例子：使用多个CGLayer对象来绘制旗子</h2><p>这一节演示了如何使用CGLayer对象来在屏幕上绘制图12-5中的旗子。首先我们会看到如何将旗子分解成简单的绘制单元，然后会看到要完成这些任务的代码。</p>
<p><strong>Figure 12-5  The result of using layers to draw the United States flag</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/us_flag.gif" alt="image"></p>
<p>从上面可以看出，旗子主要分三部分：</p>
<ol>
<li>红色条纹和白色条纹的模式。我们可以将这个模式分解为一个单一的红色条纹，因为对于屏幕绘制来说，我们可以假设其背景颜色为白色。我们创建一个红色矩形，然后以变化的偏移量来重复绘制这个矩形，以创建美国国旗上的七条红色条纹。我们将红色矩形绘制到一个层，然后将其绘制到屏幕上七次。</li>
<li>一个蓝色矩形。我们只需要一个蓝色矩形，所以没有必要使用层。当绘制蓝色矩形时，直接将其绘制到屏幕上。</li>
<li>50个白色星星的模式。与红色条纹一下，可以使用层来绘制星星。我们创建星星边框的一个路径，然后使用白条来填充。将一个星星绘制到层，然后重复50次绘制这个层，每次绘制时适当调整偏移量。</li>
</ol>
<p>代码清单12-2完成了对图12-5的绘制。myDrawFlag例程在一个Cocoa程序中调用。这个程序传递一个window图形上下文和一个与图形上下文相关的视图的大小。</p>
<p><strong>Listing 12-1  Code that uses layers to draw a flag</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">myDrawFlag</span> <span class="params">(CGContextRef context, CGRect* contextRect)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span>          i, j,</div><div class="line">                 num_six_star_rows = <span class="number">5</span>,</div><div class="line">                 num_five_star_rows = <span class="number">4</span>;</div><div class="line">    CGFloat      start_x = <span class="number">5.0</span>,</div><div class="line">                 start_y = <span class="number">108.0</span>,</div><div class="line">                 red_stripe_spacing = <span class="number">34.0</span>,</div><div class="line">                 h_spacing = <span class="number">26.0</span>,</div><div class="line">                 v_spacing = <span class="number">22.0</span>;</div><div class="line">    CGContextRef myLayerContext1,</div><div class="line">                 myLayerContext2;</div><div class="line">    CGLayerRef   stripeLayer,</div><div class="line">                 starLayer;</div><div class="line">    CGRect       myBoundingBox,</div><div class="line">                 stripeRect,</div><div class="line">                 starField;</div><div class="line"> <span class="comment">// ***** Setting up the primitives *****</span></div><div class="line"> 	CGPoint point1 = &#123;<span class="number">5</span>, <span class="number">5</span>&#125;, point2 = &#123;<span class="number">10</span>, <span class="number">15</span>&#125;, point3 = &#123;<span class="number">10</span>, <span class="number">15</span>&#125;, point4 = &#123;<span class="number">15</span>, <span class="number">5</span>&#125;;</div><div class="line"> 	CGPoint point5 = &#123;<span class="number">15</span>, <span class="number">5</span>&#125;, point6 = &#123;<span class="number">2.5</span>, <span class="number">11</span>&#125;, point7 = &#123;<span class="number">2.5</span>, <span class="number">11</span>&#125;, point8 = &#123;<span class="number">16.5</span>, <span class="number">11</span>&#125;;</div><div class="line"> 	CGPoint point9 = &#123;<span class="number">16.5</span>, <span class="number">11</span>&#125;, point10 = &#123;<span class="number">5</span>, <span class="number">5</span>&#125;;</div><div class="line">    <span class="keyword">const</span> CGPoint myStarPoints[] = &#123;point1, point2,</div><div class="line">                                    point3, point4,</div><div class="line">                                    point5, point6,</div><div class="line">                                    point7, point8,</div><div class="line">                                    point9, point10&#125;;</div><div class="line"> </div><div class="line">    stripeRect  = CGRectMake (<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">17</span>); <span class="comment">// stripe</span></div><div class="line">    starField  =  CGRectMake (<span class="number">0</span>, <span class="number">102</span>, <span class="number">160</span>, <span class="number">119</span>); <span class="comment">// star field</span></div><div class="line"> </div><div class="line">    myBoundingBox = CGRectMake (<span class="number">0</span>, <span class="number">0</span>, contextRect-&gt;size.width, </div><div class="line">                                      contextRect-&gt;size.height);</div><div class="line"> </div><div class="line">     <span class="comment">// ***** Creating layers and drawing to them *****</span></div><div class="line">    stripeLayer = CGLayerCreateWithContext (context, </div><div class="line">                            stripeRect.size, <span class="literal">NULL</span>);</div><div class="line">    myLayerContext1 = CGLayerGetContext (stripeLayer);</div><div class="line"> </div><div class="line">    CGContextSetRGBFillColor (myLayerContext1, <span class="number">1</span>, <span class="number">0</span> , <span class="number">0</span>, <span class="number">1</span>);</div><div class="line">    CGContextFillRect (myLayerContext1, stripeRect);</div><div class="line"> </div><div class="line">    starLayer = CGLayerCreateWithContext (context,</div><div class="line">                            starField.size, <span class="literal">NULL</span>);</div><div class="line">    myLayerContext2 = CGLayerGetContext (starLayer);</div><div class="line">    CGContextSetRGBFillColor (myLayerContext2, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1</span>);</div><div class="line">    CGContextAddLines (myLayerContext2, myStarPoints, <span class="number">10</span>);</div><div class="line">    CGContextFillPath (myLayerContext2);    </div><div class="line"> </div><div class="line">     <span class="comment">// ***** Drawing to the window graphics context *****</span></div><div class="line">    CGContextSaveGState(context);    </div><div class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt; <span class="number">7</span>;  i++)   </div><div class="line">    &#123;</div><div class="line">        CGContextDrawLayerAtPoint (context, CGPointZero, stripeLayer);</div><div class="line">        CGContextTranslateCTM (context, <span class="number">0.0</span>, red_stripe_spacing);</div><div class="line">    &#125;</div><div class="line">    CGContextRestoreGState(context);</div><div class="line"> </div><div class="line">    CGContextSetRGBFillColor (context, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.329</span>, <span class="number">1.0</span>);</div><div class="line">    CGContextFillRect (context, starField);</div><div class="line"> </div><div class="line">    CGContextSaveGState (context);              </div><div class="line">    CGContextTranslateCTM (context, start_x, start_y);      </div><div class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt; num_six_star_rows;  j++)   </div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt; <span class="number">6</span>;  i++)</div><div class="line">        &#123;</div><div class="line">            CGContextDrawLayerAtPoint (context,CGPointZero,</div><div class="line">                                            starLayer);</div><div class="line">            CGContextTranslateCTM (context, h_spacing, <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">        CGContextTranslateCTM (context, (-i*h_spacing), v_spacing); </div><div class="line">    &#125;</div><div class="line">    CGContextRestoreGState(context);</div><div class="line"> </div><div class="line">    CGContextSaveGState(context);</div><div class="line">    CGContextTranslateCTM (context, start_x + h_spacing/<span class="number">2</span>, </div><div class="line">                                 start_y + v_spacing/<span class="number">2</span>);</div><div class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt; num_five_star_rows;  j++) </div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt; <span class="number">5</span>;  i++)</div><div class="line">        &#123;</div><div class="line">        CGContextDrawLayerAtPoint (context, CGPointZero,</div><div class="line">                            starLayer);</div><div class="line">            CGContextTranslateCTM (context, h_spacing, <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">        CGContextTranslateCTM (context, (-i*h_spacing), v_spacing);</div><div class="line">    &#125;</div><div class="line">    CGContextRestoreGState(context);</div><div class="line"> </div><div class="line">    CGLayerRelease(stripeLayer);</div><div class="line">    CGLayerRelease(starLayer);        </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在此不再翻译对代码的注释，请各位看官查看文档原文<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_layers/dq_layers.html#//apple_ref/doc/uid/TP30001066-CH219-TPXREF101" target="_blank" rel="external">Core Graphics Layer Drawing</a>。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/01/05/quartz2d-11/" itemprop="url">
                  Quartz 2D编程指南之十一：位图与图像遮罩
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-01-05T23:10:23+08:00" content="2015-01-05">
              2015-01-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>位图与图像遮罩和Quartz中的其它绘制元素一样。这两者在Quartz中都是用CGImageRef数据类型来表示。正如在本章后面看到的一样，我们有一系列的方法来创建一个图像。其中一些需要数据提供者或图像源来提供位图数据。另外一些函数则通过拷贝图像或在图像上应用操作来从已存在的图像中创建图像。不管我们是以何种方式来创建图像，我们都可以将图像绘制到任何类型的图形上下文。记住，位图是在指定分辨率下的一个字节数组。如果我们将位图绘制到一个依赖于分辨率的图形上下文中(如PDF图形上下文)，则位图受限于创建它的图形上下文的分辨率。</p>
<p>我们可以通过调用CGImageMaskCreate函数来创建一个Quartz图像遮罩。我们将在“创建图像遮罩”一节中看到如何创建遮罩。使用图像遮罩不是绘制遮罩的唯一方法，具体的我们都会在下面看到。</p>
<h2 id="位图和图像遮罩"><a href="#位图和图像遮罩" class="headerlink" title="位图和图像遮罩"></a>位图和图像遮罩</h2><p>一个位图是一个像素数组。每一个像素表示图像中的一个点。JPEG, TIFF和PNG图像文件都是位图。应用程序的icon也是位图。位图被限定在一个矩形内。但是通过使用alpha分量，它们可以呈现不同的形式，也可以旋转或被裁剪，如图11-1所示：</p>
<p><strong>Figure 11-1  Bitmap images</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/images.gif" alt="image"></p>
<p>位图中的每一个采样包含特定颜色空间下的一个或更多颜色分量，以及一个额外的用于指定alpha值以表示透明度的分量。每一个分量可以是从1-32位。在Mac OS X中，Quartz支持浮点值分量。在Mac OS X和iOS中支持的格式将会在下文中介绍。ColorSync提供了位图支持的颜色空间。</p>
<p>Quartz同样支持图像遮罩(image masks)。一个图像遮罩也是一个位图，它指定了一个绘制区域，而不是颜色。从效果上来说，一个图像遮罩更像一个模块，它指定在page中绘制颜色的位置。Quartz使用当前的填充颜色来绘制一个图像遮罩。一个颜色遮罩可以有1-8位的深度。</p>
<h2 id="位图信息"><a href="#位图信息" class="headerlink" title="位图信息"></a>位图信息</h2><p>Quartz提供了很多图像格式并内建了多种常用的格式。在iOS中，这些格式包括JPEG, GIF, PNG, TIF, ICO, GMP, XBM, 和CUR。其它的位图格式或专有格式需要我们指定图像格式的详细信息，以便Quartz能正确地解析图像。我们提供给CGImageCreate函数的图像数据必须是以像素为单位的，而不是基于扫描线的。Quartz不支持平面数据。</p>
<p>这一节描述了与位图相关的信息。当我们创建并使用Quartz图像时(使用CGImageRef数据类型)，我们将看到一些Quartz图像创建函数需要我们指定所有的信息，而其它函数只需要部分信息。我们所需要提供的信息依赖于位图数据的编码，以及位图是表示一个图像还是图像遮罩。</p>
<blockquote>
<p>注意：当使用原始图像数据时，为了获得更好的性能，我们可以使用vImage框架。我们可以使用vImageBuffer_InitWithCGImage函数从一个CGImageRef引用导入图像数据到vImage中。</p>
</blockquote>
<p>创建一个位图(CGImageRef)时，Quartz使用以下信息：</p>
<ol>
<li>位图数据源：可以是一个Quartz数据提供者或者是一个Quartz图像源。</li>
<li>可选的解码数组。(Decode Array)</li>
<li>插值设置：这是一个布尔值，指定Quartz在重置图像大小时是否使用插值算法。</li>
<li>渲染意图：指定如何映射位于图形上下文中的目标颜色空间中的颜色。该值在图像遮罩中不需要。</li>
<li>图像尺寸</li>
<li>像素格式，包括每个分量中的位数，每个像素的位数和每行中的字节数。</li>
<li>对于图像来说，颜色空间和位图布局信息描述了alpha的位置和位置是否使用浮点值。图像遮罩不需要这个信息。</li>
</ol>
<h3 id="解码数组"><a href="#解码数组" class="headerlink" title="解码数组"></a>解码数组</h3><p>一个解码数组将图像颜色值映射到其它颜色值，这对于诸如对一个图像做去饱和或者反转颜色值非常有用。数组包含每个颜色分量的一个数值对。当Quartz渲染图像时，它利用一个线性转换将原始分量值映射到一个目标颜色空间中的指定范围内一个相关值。例如，在RGB颜色空间中的一个图像的解码数组包含6个输入，分别用于红、绿、蓝颜色分量。</p>
<h3 id="像素格式"><a href="#像素格式" class="headerlink" title="像素格式"></a>像素格式</h3><p>像素格式包含以下信息：</p>
<ol>
<li>每个分量的位数，即在一个像素中每个独立颜色分量的位数。对于一个图像遮罩，这个值是源像素中遮罩bit的数目。例如，如果源图片是8-bit的遮罩，则指定每个分量是8位。</li>
<li>每个像素的位数，即一个源像素所占的总的位数。这个值必须至少是每个分量的位数乘以每个像素中分量的数目。</li>
<li>每行的字节数，即图像中水平行的字节数。</li>
</ol>
<h3 id="颜色空间和位图布局"><a href="#颜色空间和位图布局" class="headerlink" title="颜色空间和位图布局"></a>颜色空间和位图布局</h3><p>为了确保Quartz能正确的解析每个像素的位，我们必须指定：</p>
<ol>
<li>一个位图是否包含alpha通道。Quartz包含RGB,CMYK和灰度颜色空间。它也支持alpha，或者透明度，虽然并不是所有位图图像格式都支持alpha通道。当它可用时，alpha分量可以位于像素最显著的位置，也可以是最不显著的位置。</li>
<li>对于有alpha分量的位图，指定颜色分量是否已经乘以了alpha值。预乘alpha(Premultiplied alpha)表示一个已将颜色分量乘以了alpha值的源颜色。这种预处理通过消除每个颜色分量的额外的乘法运算来加速图片的渲染。</li>
<li>采样的数据格式–是整型还是浮点型。</li>
</ol>
<p>当我们使用CGImageCreate函数来创建一个图像时，我们提供一个类型为CGImageBitmapInfo的bitmapInfo参数，来指定位置布局信息。以下的常量指定了alpha分量的位置及颜色分量是否做预处理：</p>
<ol>
<li>kCGImageAlphaLast：alpha分量存储在每个像素中最不显著的位置，如RGBA。</li>
<li>kCGImageAlphaFirst：alpha分量存储在每个像素中最显著的位置，如ARGB。</li>
<li>kCGImageAlphaPremultipliedLast：alpha分量存储在每个像素中最不显著的位置，但颜色分量已经乘以了alpha值。</li>
<li>kCGImageAlphaPremultipliedFirst：alpha分量存储在每个像素中最显著的位置，同时颜色分量已经乘以了alpha值。</li>
<li>kCGImageAlphaNoneSkipLast：没有alpha分量。如果像素的总大小大于颜色空间中颜色分量数目所需要的空间，则最不显著位置的位将被忽略。</li>
<li>kCGImageAlphaNoneSkipFirst：没有alpha分量。如果像素的总大小大于颜色空间中颜色分量数目所需要的空间，则最显著位置的位将被忽略。</li>
<li>kCGImageAlphaNone：等于kCGImageAlphaNoneSkipLast。</li>
</ol>
<p>我们使用常量kCGBitmapFloatComponents来标识一个位图格式使用浮点值。对于浮点格式，我们将这个常量与上而描述的合适的常量进行逻辑OR操作。例如，对于每个像素有128位的使用预处理的浮点格式，同时alpha值位于像素中最不显示位置，我们将以下信息提供给Quartz：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kCGImageAlphaPremultipliedLast | kCGBitmapFloatComponents</div></pre></td></tr></table></figure>
<p>图11-2演示了一个像素在使用16-或32-bit整型像素格式的CMYK和RGB颜色空间中如何表示。32-bit整型像素格式中，每个分量占8位。16-bit整型像素格式中每个分量占5位。Quartz同样支持128-bit浮点像素格式，每个分量占32位。128-bit格式没有显示在下图中。</p>
<p><strong>Figure 11-2  32-bit and 16-bit pixel formats for CMYK and RGB color spaces in Quartz 2D</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/colorformatrgba32.gif" alt="image"></p>
<h2 id="创建图像"><a href="#创建图像" class="headerlink" title="创建图像"></a>创建图像</h2><p>表11-1罗列了Quartz提供的用于创建CGImageRef对象的函数。函数的选择依赖于图像的数据源。最常用的函数是CGImageCreate。它可以从任何类型的位图数据来创建一个图像。然而，它是最复杂的函数，因为需要提供所有的位图信息。为了使用这个函数，我们需要熟悉上面讨论的位图图像信息的内容。</p>
<p>如果我们想从一个标准的图像格式，如PNG或JPEG，来创建一个CGImage对象，则最简单的方法是调用函数CGImageSourceCreateWithURL来创建一个图像源，然后调用CGImageSourceCreateImageAtIndex以使用从图像源中索引index指定的图像数据来创建一个图像。如果源图像文件只包含一个图像，则索引为0。如果图像文件格式支持包含多个图像的文件，则需要提供所需要图像的索引值，记住起始值是0。</p>
<p>如果我们已经将内容渲染到一个位图图形上下文，并想要从中获取到CGImage对象，则调用CGBitmapContextCreateImage函数。</p>
<p>有几个函数可以操作已有的图像，如拷贝、创建一个缩略图，或从一个大图像中创建一个图像。不管如何创建一个图像对象，我们都使用函数CGContextDrawImage将图像绘制到一个图形上下文中。记住CGImage是不可变的。当不再需要一个CGImage对象时，调用CGImageRelease函数来释放它。</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/quartz-2d-table11-1.png?raw=true" alt="image"></p>
<p>接下来将讨论如何创建：</p>
<ol>
<li>从一个已存在图像中创建一个子图像</li>
<li>从一个图像图形上下文中创建一个图像</li>
</ol>
<h3 id="从一个大图片中创建一个图像"><a href="#从一个大图片中创建一个图像" class="headerlink" title="从一个大图片中创建一个图像"></a>从一个大图片中创建一个图像</h3><p>我们可以使用CGImageCreateWithImageInRect函数从一个大图像中创建一个图像。图11-3演示了这一情形。</p>
<p><strong>Figure 11-3  A subimage created from a larger image</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/subimage.gif" alt="image"></p>
<p>函数CGImageCreateWithImageInRect返回的图像保留了源图像的一个引用，这意味着我们在调用完这个函数后可以释放源图像。</p>
<p>图11-4是另外一个例子。在这种情况下，公鸡的头部被从大图中提取出来，然后绘制到一个大于子图像的矩形中。</p>
<p>代码清单11-1显示了创建并绘制子图像的过程。CGContextDrawImage函数绘制公鸡头部的矩形区域是所提取的子图像的四倍大小。清单中的只是一个代码片断。我们需要声明合适的变量，创建公鸡头像，并部署公鸡图像及公鸡头部子图像。因为只是代码片断，所以没有演示如何创建一个图形上下文。我们可以使用任何我们所喜欢的图形上下文。创建图形上下文的例子可以查看“图形上下文”一章。</p>
<p><strong>Figure 11-4  An image, a subimage taken from it and drawn so it’s enlarged</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/rooster_image_zoom.gif" alt="image"></p>
<p><strong>Listing 11-1  Code that creates a subimage and draws it enlarged</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">myImageArea = CGRectMake (rooster_head_x_origin, rooster_head_y_origin,</div><div class="line">                            myWidth, myHeight);</div><div class="line">mySubimage = CGImageCreateWithImageInRect (myRoosterImage, myImageArea);</div><div class="line">myRect = CGRectMake(<span class="number">0</span>, <span class="number">0</span>, myWidth*<span class="number">2</span>, myHeight*<span class="number">2</span>);</div><div class="line">CGContextDrawImage(context, myRect, mySubimage);</div></pre></td></tr></table></figure>
<h3 id="从一个位图图形上下文创建一个图像"><a href="#从一个位图图形上下文创建一个图像" class="headerlink" title="从一个位图图形上下文创建一个图像"></a>从一个位图图形上下文创建一个图像</h3><p>为了从一个已存在的位图图形上下文创建一个图像，我们可以调用函数CGBitmapContextCreateImage，如以下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CGImageRef myImage;</div><div class="line">myImage = CGBitmapContextCreateImage (myBitmapContext);</div></pre></td></tr></table></figure>
<p>这个函数返回的CGImage对象是通过一个拷贝操作创建的。因此我们对位图图形上下文所做的修改都不会影响到已返回的CGImage对象。在一些情况下，这个拷贝操作实际上沿用了copy-on-write语义，即只有当位图图形上下文中的数据被修改时才会去实际拷贝这些数据。我们可能需要在绘制额外数据到位图图形上下文之前使用结果数据或者释放它们，以便我们可以避免实际去拷贝这些数据。</p>
<p>如何创建一个位图图形上下文，可以参考”创建图形上下文”相关的内容。</p>
<h2 id="创建一个图像遮罩"><a href="#创建一个图像遮罩" class="headerlink" title="创建一个图像遮罩"></a>创建一个图像遮罩</h2><p>一个Quartz位图图像遮罩如同艺术家使用丝网印刷品(silkscreen)一样。一个位图图像遮罩定义了如何转换颜色，而不是使用哪些颜色。图像遮罩中的每个采样值指定了在特定位置中，当前填充颜色值被遮罩的数量。采样值指定了遮罩的不透明度。值越大，表示越不透明，Quartz在指定位置绘制的颜色越少。我们可以将采样值当成alpha值的反转。1表示透明的，而0表示不透明。</p>
<p>图像遮罩的每个分量可能是1，2，4或者8位。对于1-bit的遮罩，采样值1指定遮罩的区域掩盖了当前的填充颜色。值为0表示当绘制遮罩时，显示当前的填充颜色。我们可以将1-bit遮罩当成黑色和白色；要么完全遮挡，要么完全显示。</p>
<p>每个分量中有2，4，8位的图像遮罩代表灰度值。每个分量使用以下的公式将值映射到[0, 1]之间的值：</p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/inline_equations.jpg" alt="image"></p>
<p>例如，一个4-bit的遮罩其值位于[0, 1]之间，且增长的步长为1/15。0和1这两个值分别是最小和最大值–分别表示完全遮盖或完全透明。0和1之间的值使用(1-MaskSampleValue)这个公式来处理局部绘制。例如，如果一个8-bit遮罩的采样值设置为0.7，则那些alpha值为(1-0.7)，即0.3的颜色将会被绘制。</p>
<p>函数CGImageMaskCreate从我们提供的位图图像信息中创建一个Quartz图像遮罩。我们提供的信息与创建图像所提供的信息是一样的，只是不需要提供颜色空间信息，位图信息常量或渲染意图，我们可以从代码清单11-2中看到这个函数原型：</p>
<p><strong>Listing 11-2  The prototype for the function CGImageMaskCreate</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function">CGImageRef <span class="title">CGImageMaskCreate</span> <span class="params">(</span></span></div><div class="line">        <span class="keyword">size_t</span> width,</div><div class="line">        <span class="keyword">size_t</span> height,</div><div class="line">        <span class="keyword">size_t</span> bitsPerComponent,</div><div class="line">        <span class="keyword">size_t</span> bitsPerPixel,</div><div class="line">        <span class="keyword">size_t</span> bytesPerRow,</div><div class="line">        CGDataProviderRef provider,</div><div class="line">        <span class="keyword">const</span> CGFloat decode[],</div><div class="line">        <span class="keyword">bool</span> shouldInterpolate</div><div class="line">);</div></pre></td></tr></table></figure>
<h2 id="遮罩图像"><a href="#遮罩图像" class="headerlink" title="遮罩图像"></a>遮罩图像</h2><p>遮罩技术可以让我们通过控制图片的哪一部分被绘制，以生成很多有趣的效果，我们可以：</p>
<ol>
<li>在一个图像上使用图像遮罩。我们也可以把一个图像作为遮罩图，以获取同使用图像遮罩相反的效果。</li>
<li>使用颜色来遮罩图像的一部分，其中包含被称为颜色遮罩的技术</li>
<li>将图形上下文剪切到一个图像或图像遮罩，当Quartz绘制内容到剪切的图形上下文时来遮罩一个图像。</li>
</ol>
<h3 id="使用一个图像遮罩来遮罩图像"><a href="#使用一个图像遮罩来遮罩图像" class="headerlink" title="使用一个图像遮罩来遮罩图像"></a>使用一个图像遮罩来遮罩图像</h3><p>函数CGImageCreateWithMask通过将图像遮罩使用到一个图像上的方式来创建一个图像。这个函数带有两个参数：</p>
<ol>
<li>原始图像，遮罩将用于其上。这个图像不能是图像遮罩，也不能有与之相关的遮罩颜色。</li>
<li>一个图像遮罩，通过调用CGImageMaskCreate函数创建的。也可以提供一个图像来替代图像遮罩，但这将给出非常不同的结果。这将在下面描述。</li>
</ol>
<p>一个图像遮罩的采样如同一个反转的alpha值。一个图像遮罩采样值(S)：</p>
<ol>
<li>为1时，则不会绘制对应的图像样本。</li>
<li>为0时，则允许完全绘制对应的图像样本。</li>
<li>0和1之间的值，则让对应的图像样本的alpha的值为(1-S)。</li>
</ol>
<p>图11-5显示了一个由Quartz图像创建函数创建的图像，而图11-6显示了一个使用CGImageMaskCreate函数创建的图像遮罩。图11-7则显示了一个使用CGImageCreateWithMask函数将图像遮罩应用于一个图像的效果。</p>
<p><strong>Figure 11-5  The original image</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/two_tigers.gif" alt="image"></p>
<p><strong>Figure 11-6  An image mask</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/two_tiger_mask.gif" alt="image"></p>
<p>注意，源图像中与遮罩黑色区域对应的区域绘制出来，而与白色区域对应的部分则没有绘制出来。而与遮罩灰色区域对应的区域则使用一个与(1-图像遮罩采样值)相同的alpha值来绘制。</p>
<p><strong>Figure 11-7  The image that results from applying the image mask to the original image</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/image_create_w_mask.gif" alt="image"></p>
<h3 id="使用一个图像来遮罩一个图像"><a href="#使用一个图像来遮罩一个图像" class="headerlink" title="使用一个图像来遮罩一个图像"></a>使用一个图像来遮罩一个图像</h3><p>我们可以使用函数CGImageCreateWithMask来用一个图像遮罩另一个图像，而不是使用一个图像遮罩。我们可以使用这种方式来达到与使用图像遮罩相反的效果。那此时我们传递给CGImageCreateWithMask函数的就不是一个图像遮罩了，而是传递一个通过Quartz图像创建函数创建的图像。</p>
<p>用于遮罩的图像的采样也是操作alpha值。一个图像采样值(S)：</p>
<ol>
<li>为1时，则允许完全绘制对应的图像样本。</li>
<li>为0时，则不会绘制对应的图像样本。</li>
<li>0和1之间的值，则让对应的图像样本的alpha的值为S。</li>
</ol>
<p>图11-8显示了调用CGImageCreateWithMask函数将图11-6中的图像作为遮罩应用于图11-5中的图像上的效果。在这个例子中，我们假定图11-6中的图像是使用Quartz图像创建函数(如CGImageCreate)创建的。比较图11-8与图11-7，可以看出使用图像采样时，可以获取与使用图像遮罩采样相反的效果。</p>
<p>在图11-8的结果图像中，源图像中与图像的黑色区域对应的区域没有绘制出来。与白色区域对应的区域则绘制出来了。在遮罩中与灰色区域对应的区域则使用与遮罩图像采样值相同的alpha值来绘制。</p>
<p><strong>Figure 11-8  The image that results from masking the original image with an image</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/image_mask_image.gif" alt="image"></p>
<h3 id="使用颜色来遮罩图像"><a href="#使用颜色来遮罩图像" class="headerlink" title="使用颜色来遮罩图像"></a>使用颜色来遮罩图像</h3><p>函数CGImageCreateWithMaskingColors通过遮罩一种颜色或一个颜色范围内的颜色来创建一个图像。使用这个函数，我们可以执行如图11-9所示的颜色遮罩，当然也可以遮罩一个范围内的颜色，如图11-11、11-12和11-13所示的效果。</p>
<p>函数CGImageCreateWithMaskingColors有两个参数：</p>
<ol>
<li>一个图像，它不能是遮罩图像，也不能是使用过图像遮罩或颜色遮罩的图像。</li>
<li>一个颜色分量数组，指定了一个颜色或一组颜色值，以用于遮罩图像。</li>
</ol>
<p><strong>Figure 11-9  Chroma key masking</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/chroma_key.gif" alt="image"></p>
<p>颜色分量数组中元素的个数必须等于图像所在颜色空间的颜色分量数目的两倍。对于颜色空间中的每一个颜色分量，提供一个最小值和一个最大值来限定遮罩颜色的范围。如果只使用一个颜色，则设置最大值等于最小值即可。颜色分量数组中的值按以下顺序来提供：</p>
<pre><code>{min[1], max[1], ... min[N], max[N]}，其中N是分量的数目
</code></pre><p>如果图像使用整型像素分量，则颜色分量数组中的每个值必须在[0 .. 2^bitsPerComponent - 1]范围之内。如果图像使用浮点像素分量，则值可以是表示任何有效的颜色分量值的浮点数。</p>
<p>一个图像采样如果其颜色值在以下范围内，则不会被绘制：</p>
<pre><code>{c[1], ... c[N]}，其中min[i] &lt;= c[i] &lt;= max[i] for 1 &lt;= i &lt;= N
</code></pre><p>图11-10中两只老虎的图像使用了每个分量有8位的RGB颜色空间。为了在这个图像上屏蔽一组颜色，我们提供一组在[0, 255]区间内的最小和最大颜色分量值。</p>
<p><strong>Figure 11-10  The original image</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/two_tigers1.gif" alt="image"></p>
<p>代码清单11-3演示了如何设置颜色分量数组，并将其提供给CGImageCreateWithMaskingColors函数以达到图11-11的效果。</p>
<p><strong>Listing 11-3  Masking light to mid-range brown colors in an image</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CGImageRef myColorMaskedImage;</div><div class="line"><span class="keyword">const</span> CGFloat myMaskingColors[<span class="number">6</span>] = &#123;<span class="number">124</span>, <span class="number">255</span>,  <span class="number">68</span>, <span class="number">222</span>, <span class="number">0</span>, <span class="number">165</span>&#125;;</div><div class="line">myColorMaskedImage = CGImageCreateWithMaskingColors (image,</div><div class="line">                                        myMaskingColors);</div><div class="line">CGContextDrawImage (context, myContextRect, myColorMaskedImage);</div></pre></td></tr></table></figure>
<p><strong>Figure 11-11  An image with light to midrange brown colors masked out</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/beige_brown_masking.gif" alt="image"></p>
<p>代码清单11-14同样操作图11-10并得到图11-12的效果。这个例子遮罩了一组暗色。</p>
<p><strong>Listing 11-4  Masking shades of brown to black</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CGImageRef myMaskedImage;</div><div class="line"><span class="keyword">const</span> CGFloat myMaskingColors[<span class="number">6</span>] = &#123; <span class="number">0</span>, <span class="number">124</span>, <span class="number">0</span>, <span class="number">68</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</div><div class="line">myColorMaskedImage = CGImageCreateWithMaskingColors (image,</div><div class="line">                                        myMaskingColors);</div><div class="line">CGContextDrawImage (context, myContextRect, myColorMaskedImage);</div></pre></td></tr></table></figure>
<p><strong>Figure 11-12  A image after masking colors from dark brown to black</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/brown_black_masking_colors.gif" alt="image"></p>
<p>我们同样可以设置一个填充颜色来作为图像的遮罩颜色，以达到图11-13的效果，其中被遮罩区域使用了填充颜色。代码清单11-15演示了这一过程</p>
<p><strong>Listing 11-5  Masking a range of colors and setting a fill color and</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CGImageRef myMaskedImage;</div><div class="line"><span class="keyword">const</span> CGFloat myMaskingColors[<span class="number">6</span>] = &#123; <span class="number">0</span>, <span class="number">124</span>, <span class="number">0</span>, <span class="number">68</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</div><div class="line">myColorMaskedImage = CGImageCreateWithMaskingColors (image,</div><div class="line">                                        myMaskingColors);</div><div class="line">CGContextSetRGBFillColor (myContext, <span class="number">0.6373</span>,<span class="number">0.6373</span>, <span class="number">0</span>, <span class="number">1</span>);</div><div class="line">CGContextFillRect(context, rect);</div><div class="line">CGContextDrawImage(context, rect, myColorMaskedImage);</div></pre></td></tr></table></figure>
<p><strong>Figure 11-13  An image drawn after masking a range of colors and setting a fill color</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/fill_color_with_mask.gif" alt="image"></p>
<h3 id="通过裁减上下文来遮罩一个图片"><a href="#通过裁减上下文来遮罩一个图片" class="headerlink" title="通过裁减上下文来遮罩一个图片"></a>通过裁减上下文来遮罩一个图片</h3><p>函数CGContextClipToMask将遮罩映射为一个矩形并将其与图形上下文的当前裁减区域求个交集。我们提供以下参数：</p>
<ol>
<li>需要裁减的图形上下文</li>
<li>要使用遮罩的矩形区域</li>
<li>一个图像遮罩，其通过CGImageMaskCreate函数创建。我们可以使用图像来替代图像遮罩以达到相反的效果。但图像必须使用Quartz图像创建函数来创建，但不能是使用过图像遮罩或颜色遮罩的图像。</li>
</ol>
<p>裁减区域的结果依赖于是否提供了一个图像遮罩或图像给CGContextClipToMask函数。</p>
<p>我们看看图11-14.假设它是通过调用CGImageMaskCreate函数创建的一个图像遮罩，然后将其作为CGContextClipToMask函数的参数。结果上下文允许绘制黑色区域，而不绘制白色区域，并使用(1-S)的alpha值来绘制灰色区域，其中S是图像遮罩的采样值。如果使用CGContextDrawImage函数来将一个图像绘制到裁减上下文，则可以获得图11-15所示的结果。</p>
<p><strong>Figure 11-14  A masking image</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/the_mask.gif" alt="image"></p>
<p><strong>Figure 11-15  An image drawn to a context after clipping the content with an image mask</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/mask_as_mask.gif" alt="image"></p>
<p>当遮罩图像被当成一个图像时，可以获得相反的结果，如图11-16所示：</p>
<p><strong>Figure 11-16  An image drawn to a context after clipping the content with an image</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/inverse_mask_clip.gif" alt="image"></p>
<h2 id="在图像中使用混合模式"><a href="#在图像中使用混合模式" class="headerlink" title="在图像中使用混合模式"></a>在图像中使用混合模式</h2><p>此处略，类似于在颜色中使用混合模式。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/12/11/quartz2d-10/" itemprop="url">
                  Quartz 2D编程指南之十：Quartz 2D中的数据管理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-12-11T09:19:08+08:00" content="2014-12-11">
              2014-12-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>管理数据是每一个图形应用程序所需要处理的工作。对于Quartz来说，数据管理涉及为Quartz 2D程序提供数据，及从中获取数据。一些Quartz 2D程序将数据传输到Quartz中，如从文件或程序其它部分获取图片或PDF数据。另一些程序则获取Quartz数据，如将图像或PDF数据写入到文件，或提供给程序其它部分这些数据。</p>
<p>Quartz提供了一系列的函数来管理数据。通过学习本章，我们可以了解到哪些函数是最适合我们的程序的。</p>
<blockquote>
<p>注：我们推荐使用图像I/O框架来读取和写入数据，该框架在iOS 4、Mac OS X 10.4或者更高版本中可用。查看《Image I/OProgramming Guide 》可以获取更多关于CGImageSourceRef和CGImageDestinationRef的信息。图像源和目标不仅提供了访问图像数据的方法，不提供了更多访问图像原数据的方法。</p>
</blockquote>
<p>Quartz可识别三种类型的数据源和目标：</p>
<ol>
<li>URL：通过URL指定的数据可以作为数据的提供者和接收者。我们使用Core Foundation数据类型CFURLRef作为参数传递给Quartz函数。</li>
<li>CFData：Core Foundation数据类型CFDataRef和CFMutableDataRef可简化Core Foundation对象的内存分配行为。CFData是一个”toll-freebridged”类，CocoaFoundation中对应的类是NSData；如果在Quartz 2D中使用Cocoa框架，你可以传递一个NSData对象给Quartz方法，以取代CFData对象。</li>
<li>原始数据：我们可以提供一个指向任何类型数据的指针，连同处理这些数据基本内存管理的回调函数集合。</li>
</ol>
<p>这些数据，无论是URL、CFData对象，还是数据缓存，都可以是图像数据或PDF数据。图像数据可以是任何格式的数据。Quartz能够解析大部分常用的图像文件格式。一些Quartz数据管理函数专门用于处理图像数据，一些只处理PDF数据，还有一些可同时处理PDF和图像数据。</p>
<p>URL，CFData和原始数据源和目标中的数据都是在Mac OS X 或者iOS图像领域范围之外的，如图10-1所示。Mac OS X或iOS的其它图像技术通常会提供它们自己的方式来和Quartz通信。例如，一个Mac OS X 应用程序可以传输一个Quartz图像给Core Image，并使用Core Image来实现更复杂的效果。</p>
<p><strong>Figure 10-1  Moving data to and from Quartz 2D in Mac OS X</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/movingdata.gif" alt="image"></p>
<h2 id="传输数据给Quartz-2D"><a href="#传输数据给Quartz-2D" class="headerlink" title="传输数据给Quartz 2D"></a>传输数据给Quartz 2D</h2><p>表10-1列出了从数据源获取数据的方法。所有的这些函数，除了CGPDFDocumentCreateWithURL，都返回一个图像源(CGImageSourceRef)或者数据提供者(CGDataProviderRef)。图像源和数据提供者抽象了数据访问工作，并避免了程序去管理原始内存缓存。</p>
<p>图像源是将图像数据传输给Quartz的首先方式。图像源可表示很多种图像数据。一个图像源可表示多于一个图像，也可表示缩略图、图像的属性和图像文件。当我们拥有CGImageSourceRef对象后，我们可以完成如下工作：</p>
<ol>
<li>使用函数CGImageSourceCreateImageAtIndex,CGImageSourceCreateThumbnailAtIndex, CGImageSourceCreateIncremental创建图像(CGImageRef). 一个CGImageRef数据类型表示一个单独的Quartz图像。</li>
<li>通过函数CGImageSourceUpdateData或CGImageSourceUpdateDataProvider来添加内容到图像源中。</li>
<li>使用函数CGImageSourceGetCount, CGImageSourceCopyProperties和CGImageSourceCopyTypeIdentifiers获取图像源的信息。</li>
</ol>
<p>CFPDFDocumentCreateWithURL函数可以方便地从URL指定的文件创建PDF文档。</p>
<p>数据提供者是比较老的机制，它有很多限制。它们可用于获取图像或PDF数据。</p>
<p>我们可以将数据提供者用于：</p>
<ol>
<li>一个图像创建函数，如CGImageCreate,CGImageCreateWithPNGDataProvider或者CGImageCreateWithJPEGDataProvider。</li>
<li>PDF文档的创建函数CGPDFDocumentCreateWithProvider.</li>
<li>函数CGImageSourceUpdateDataProvider用于更新已存在的图像源。</li>
</ol>
<p>关于图像的更多信息，可查看“Bitmap Images andImage Masks”。</p>
<p><strong>Table 10-1  Functions that move data into Quartz 2D</strong></p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/quartz-2d-table10-1.png?raw=true" alt="image"></p>
<h2 id="获取Quartz-2D的数据"><a href="#获取Quartz-2D的数据" class="headerlink" title="获取Quartz 2D的数据"></a>获取Quartz 2D的数据</h2><p>表10-2列出地从Quartz 2D中获取数据的方法。所有这些方法，除了CGPDFContextCreateWithURL，都返回一个图像目标(CGImageDestinationRef)或者是数据消费者(CGDataComsumerRef)。图像目标和数据消费者抽象的数据写入工作，让Quartz来处理细节。</p>
<p>一个图像目标是获取Quartz数据的首先方法。与图像源一样，图像目标也可以表示很多图像数据，如一个单独图片、多个图片、缩略图、图像属性或者图片文件。在获取到CGImageDestinationRef后，我们可以完成以下工作：</p>
<ol>
<li>使用函数CGImageDestinationAddImage或者CGImageDestinationAddImageFromSource添加一个图像(CGImageRef)到目标中。一个CGImageRef表示一个图片。</li>
<li>使用函数CGImageDestinationSetProperties设置属性</li>
<li>使用函数CGImageDestinationCopyTypeIdentifiers和CGImageDestinationGetTypeID从图像目标中获取信息。</li>
</ol>
<p>函数CGPDFContextCreateWithURL可以方便地将PDF数据写入URL指定的位置。</p>
<p>数据消费者是一种老的机制，有很多限制。它们用于写图像或PDF数据。我们可以将数据消费者用于：</p>
<ol>
<li>PDF上下文创建函数CGPDFContextCreate。该函数返回一个图形上下文，用于记录一系列的PDF绘制命令。</li>
<li>函数CGImageDestinationCreateWithDataConsumer，用于从数据消费者中创建图像目标。</li>
</ol>
<p>关于图像的更多信息，可查看“Bitmap Images andImage Masks”。</p>
<p><strong>Table 10-2  Functions that move data out of Quartz 2D</strong></p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/quartz-2d-table10-2.png?raw=true" alt="image"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/12/10/quartz2d-9/" itemprop="url">
                  Quartz 2D编程指南之九：透明层
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-12-10T09:13:04+08:00" content="2014-12-10">
              2014-12-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>透明层(TransparencyLayers)通过组合两个或多个对象来生成一个组合图形。组合图形被看成是单一对象。当需要在一组对象上使用特效时，透明层非常有用，如图9-1所示的给三个圆使用阴影的效果。</p>
<p><strong>Figure 9-1  Three circles as a composite in a transparency layer</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/trans_layer1.gif" alt="image"></p>
<p>如果没有使用透明层来渲染图9-1中的三个圆，对它们使用阴影的效果将是如图9-2所示：</p>
<p><strong>Figure 9-2  Three circles painted as separate entities</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/trans_layer2.gif" alt="image"> </p>
<h2 id="透明层的工作方式"><a href="#透明层的工作方式" class="headerlink" title="透明层的工作方式"></a>透明层的工作方式</h2><p>Quartz的透明层类似于许多流行的图形应用中的层。层是独立的实体。Quartz维护为每个上下文维护一个透明层栈，并且透明层是可以嵌套的。但由于层通常是栈的一部分，所以我们不能单独操作它们。</p>
<p>我们通过调用函数CGContextBeginTransparencyLayer来开始一个透明层，该函数需要两个参数：图形上下文与CFDictionary对象。字典中包含我们所提供的指定层额外信息的选项，但由于Quartz 2D API中没有使用字典，所以我们传递一个NULL。在调用这个函数后，图形状态参数保持不变，除了alpha值[默认设置为1]、阴影[默认关闭]、混合模式[默认设置为normal]、及其它影响最终组合的参数。</p>
<p>在开始透明层操作后，我们可以绘制任何想显示在层上的对象。指定上下文中的绘制操作将被当成一个组合对象绘制到一个透明背景上。这个背景被当作一个独立于图形上下文的目标缓存。</p>
<p>当绘制完成后，我们调用函数CGContextEndTransparencyLayer。Quartz将结合对象放入上下文，并使用上下文的全局alpha值、阴影状态及裁减区域作用于组合对象。</p>
<h2 id="在透明层中进行绘制"><a href="#在透明层中进行绘制" class="headerlink" title="在透明层中进行绘制"></a>在透明层中进行绘制</h2><p>在透明层中绘制需要三步：</p>
<ol>
<li>调用函数CGContextBeginTransparencyLayer</li>
<li>在透明层中绘制需要组合的对象</li>
<li>调用函数CGContextEndTransparencyLayer</li>
</ol>
<p>图9-3显示了在透明层中绘制三个矩形，其中将这三个矩形当成一个整体来渲染阴影。</p>
<p><strong>Figure 9-3  Three rectangles painted to a transparency layer</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/trans_code.gif" alt="image"></p>
<p>代码清单9-1显示了如何利用透明层生成图9-3所示的矩形。</p>
<p><strong>Listing 9-1  Painting to a transparency layer</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDrawTransparencyLayer</span> <span class="params">(CGContext myContext, <span class="keyword">float</span> wd,<span class="keyword">float</span> ht)</span></span></div><div class="line">&#123;</div><div class="line">    CGSize myShadowOffset = CGSizeMake (<span class="number">10</span>, <span class="number">-20</span>);</div><div class="line">    CGContextSetShadow (myContext, myShadowOffset, <span class="number">10</span>);   </div><div class="line">    CGContextBeginTransparencyLayer (myContext, <span class="literal">NULL</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// Your drawing code here</span></div><div class="line">    CGContextSetRGBFillColor (myContext, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</div><div class="line">    CGContextFillRect (myContext, CGRectMake (wd/<span class="number">3</span>+ <span class="number">50</span>,ht/<span class="number">2</span> ,wd/<span class="number">4</span>,ht/<span class="number">4</span>));</div><div class="line">    CGContextSetRGBFillColor (myContext, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</div><div class="line">    CGContextFillRect (myContext, CGRectMake (wd/<span class="number">3</span><span class="number">-50</span>,ht/<span class="number">2</span><span class="number">-100</span>,wd/<span class="number">4</span>,ht/<span class="number">4</span>));</div><div class="line">    CGContextSetRGBFillColor (myContext, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</div><div class="line">    CGContextFillRect (myContext, CGRectMake (wd/<span class="number">3</span>,ht/<span class="number">2</span><span class="number">-50</span>,wd/<span class="number">4</span>,ht/<span class="number">4</span>));</div><div class="line">    CGContextEndTransparencyLayer (myContext);</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/12/10/quartz2d-8/" itemprop="url">
                  Quartz 2D编程指南之八：渐变
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-12-10T09:00:26+08:00" content="2014-12-10">
              2014-12-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Quartz提供了两个不透明数据odgago创建渐变：CGShadingRef和CGGradientRef。我们可以使用任何一个来创建轴向(axial)或径向(radial)渐变。一个渐变是从一个颜色到另外一种颜色的填充。</p>
<p>一个轴向渐变(也称为线性渐变)沿着由两个端点连接的轴线渐变。所有位于垂直于轴线的某条线上的点都具有相同的颜色值。</p>
<p>一个径向渐变也是沿着两个端点连接的轴线渐变，不过路径通常由两个圆来定义。</p>
<p>本章提供了一些我们使用Quartz能够创建的轴向和径向渐变的类型的例子，并比较绘制渐变的两种方法，然后演示了如何使用每种不透明数据类型来创建渐变。</p>
<h2 id="轴向和径向渐变实例"><a href="#轴向和径向渐变实例" class="headerlink" title="轴向和径向渐变实例"></a>轴向和径向渐变实例</h2><p>Quartz函数提供了一个丰富的功能来创建渐变效果。这一部分显示了一些我们能达到的效果。图8-1中的轴向渐变由橙色向黄色渐变。在这个例子中，渐变轴相对于原点倾斜了45度角。</p>
<p><strong>Figure 8-1  An axial gradient along a 45 degree axis</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/two_color_gradient.jpg" alt="image"></p>
<p>Quartz也允许我们指定一系列的颜色和位置值，以沿着轴来创建更复杂的轴向渐变，如图8-2所示。起始点的颜色值是红色，结束点的颜色是紫罗兰色。同时，在轴上有五个位置，它们的颜色值分别被设置为橙、黄、绿、蓝和靛蓝。我们可以把它看成沿着同一轴线的六段连续的线性渐变。虽然这里的轴线与图8-1是一样的，但这不是必须的。轴线的角度由我们提供的两个端点定义。</p>
<p><strong>Figure 8-2  An axial gradient created with seven locations and colors</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/rainbow_gradient.jpg" alt="image"></p>
<p>图8-3显示了一个径向渐变，它从一个小的明亮的红色圆渐变到一个大小黑色的圆。</p>
<p><strong>Figure 8-3  A radial gradient that varies between two circles</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/cylinder6.gif" alt="image"></p>
<p>使用Quartz，我们不局限于创建颜色值改变的渐变；我们可以只修改alpha值，或者创建alpha值与其它颜色组件一起改变的渐变。图8-4显示了一个渐变，其红、绿、蓝组件的值是不变的，但alpha值从1.0渐变到0.1。</p>
<p>注意：如果我们使用alpha值来改变一个渐变，则在绘制一个PDF内容时我们不能捕获这个渐变。因此，这样的渐变无法打印。如果需要绘制一个渐变到PDF，则需要让alpha值为1.0。</p>
<p><strong>Figure 8-4  A radial gradient created by varying only the alpha component</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/alpha_only.jpg" alt="image"></p>
<p>我们可以把一个圆放置到一个径向渐变中来创建各种形状。如果一个圆是另一个的一部分或者完全在另一个的外面，则Quartz创建了圆锥和一个圆柱。径向渐变的一个通常用法就是创建一个球体阴影，如图8-5所示。在这种情况下，一个单一的点(半径为0的圆)位于一个大圆以内。</p>
<p><strong>Figure 8-5  A radial gradient that varies between a point and a circle</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/shaded_sphere.gif" alt="image"></p>
<p>我们可以像图8-6一样通过内嵌几个径向渐变来创建更复杂的效果。它使用同心圆来创建图形中的各环形部分。</p>
<p><strong>Figure 8-6  Nested radial gradients</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/torus.gif" alt="image"></p>
<h2 id="CGShading和CGGradient对象的对比"><a href="#CGShading和CGGradient对象的对比" class="headerlink" title="CGShading和CGGradient对象的对比"></a>CGShading和CGGradient对象的对比</h2><p>我们有两个对象类型用于创建渐变，你可能想知道哪一个更好用。本节就来回答这个问题。</p>
<p>CGShadingRef这个不透明数据类型给我们更多的控制权，以确定如何计算每个端点的颜色。在我们创建CGShading对象之前，我们必须创建一个CGFunction对象(CGFunctionRef)，这个对象定义了一个用于计算渐变颜色的函数。写一个自定义的函数让我们能够创建平滑的渐变，如图8-3，8-3和8-5及更多非传统的效果，如图8-12所示。</p>
<p>当创建一个CGShading对象时，我们指定其是轴向还是径向。除了计算函数外，我们还需要提供一个颜色空间、起始点和结束点或者是半径，这取决于是绘制轴向还是径向渐变。在绘制时，我们只是简单地传递CGShading对象及绘制上下文给CGContextDrawShading函数。Quartz为渐变上的每个点调用渐变计算函数。</p>
<p>一个CGGradient对象是CGShading对象的子集，其更易于使用。CGGradientRef不透明类型易于作用，因为Quartz在渐变的每一个顶点上计算颜色值。我们不需要提供一个渐变计算函数。当创建一个渐变对象时，我们提供一个位置和颜色的数组。Quartz使用对应的颜色值来计算每个梯度的渐变，。我们可以使用单一的起始与结束点来设置一个渐变对象，如图8-1所示，或者提供一组端点来创建一个类似于图8-2的的效果。使用CGShading对象可以提供多于两个位置的能力。</p>
<p>当我们创建一个CGGradient对象时，我们需要设置一个颜色空间、位置、和每个位置对应的颜色值。当使用一个渐变对象绘制上下文时，我们指定Quartz是绘制一个轴向还是径向渐变。在绘制时，我们指定开始结束点或半径，这取决于我们是绘制轴向还是径向渐变。而CGShading的几何形状是在创建时定义的，而不是绘制时。</p>
<p>表8-1总结了两种不透明数据类型之间的区别。</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/quartz-2d-table8-1.png?raw=true" alt="image"></p>
<h2 id="扩展渐变端点外部的颜色"><a href="#扩展渐变端点外部的颜色" class="headerlink" title="扩展渐变端点外部的颜色"></a>扩展渐变端点外部的颜色</h2><p>当我们创建一个渐变时，我们可以选择使用纯色来填充渐变端点外部的空间。Quartz使用使用渐变边界上的颜色作为填充颜色。我们可以扩展渐变起点、终点或两端的颜色。我们可以扩展使用CGShading对象或CGGradient对象创建的轴向或径向渐变。</p>
<p>图8-7演示了一个轴向渐变，它扩展了起点和终点两侧的区域。图片中的线段显示了渐变的轴线。我们可以看到，填充颜色与起点和终点的颜色是对应的。</p>
<p><strong>Figure 8-7  Extending an axial gradient</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/extend_axial2.gif" alt="image"></p>
<p>图8-8对比了一个未使用扩展的径向渐变和一个在起点和终点两侧使用扩展的径向渐变。Quartz获取了起点和终点的颜色值，并使用这边纯色值来扩展立面。</p>
<p><strong>Figure 8-8  Extending a radial gradient</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/extend_radial.gif" alt="image"></p>
<h2 id="使用CGGradient对象"><a href="#使用CGGradient对象" class="headerlink" title="使用CGGradient对象"></a>使用CGGradient对象</h2><p>一个CGGradient对象是一个渐变的抽象定义–它简单地指定了颜色值和位置，但没有指定几何形状。我们可以在轴向和径向几何形状中使用这个对象。作为一个抽象定义，CGGradient对象可能比CGShading对象更容易重用。没有将几何形状存储在CGGradient对象中，这样允许我们使用相同的颜色方案来绘制不同的几何图形，而不需要为多个图形创建多个CGGradient对象。</p>
<p>因为Quartz为我们计算渐变，使用一个CGGradient对象来创建和绘制一个渐变则更直接，只需要以下几步：</p>
<ol>
<li>创建一个CGGradient对象，提供一个颜色空间，一个饱含两个或更多颜色组件的数组，一个包含两个或多个位置的数组，和两个数组中元素的个数。</li>
<li>调用CGContextDrawLinearGradient或CGContextDrawRadialGradient函数并提供一个上下文、一个CGGradient对象、绘制选项和开始结束几何图形来绘制渐变。</li>
<li>当不再需要时释放CGGradient对象。</li>
</ol>
<p>一个位置是一个值区间在0.0到1.0之间的CGFloat值，它指定了沿着渐变的轴线的标准化距离。值0.0指定的轴线的起点，1.0指定了轴线的终点。其它的值指定了一个距离的比例。最低限度情况下，Quartz使用两个位置值。如果我们传递NULL值作为位置数组参数，则Quartz使用0作为第一个位置，1作为第二个位置。</p>
<p>每个颜色的颜色组件的数目取决于颜色空间。对于离屏绘制，我们使用一个RGB颜色空间。因为Quartz使用alpha来绘制，每个离屏颜色都有四个组件–红、绿、蓝和alpha。所以，对于离屏绘制，我们提供的颜色组件数组的元素的数目必须是位置数目的4倍。Quartz的RGBA颜色组件可以在0.0到1.0之间改变。</p>
<p>代码清单8-1是创建一个CGGradient对象的代码片断。在声明了必须的变量后，代码设置了位置和颜色组件数组。然后创建了一个通用的RGB颜色空间。(在iOS中，不管RGB颜色空间是否可用，我们都应该调用CGColorSpaceCreateDeviceRGB)。然后，它传递必要的参数到CGGradientCreateWithColorComponents函数。我们同样可以使用CGGradientCreateWithColors，如果我们的程序设置了CGColor对象，这是一种便捷的方法。</p>
<p><strong>Listing 8-1  Creating a CGGradient object</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">CGGradientRef myGradient;</div><div class="line">CGColorSpaceRef myColorspace;</div><div class="line"><span class="keyword">size_t</span> num_locations = <span class="number">2</span>;</div><div class="line">CGFloat locations[<span class="number">2</span>] = &#123; <span class="number">0.0</span>, <span class="number">1.0</span> &#125;;</div><div class="line">CGFloat components[<span class="number">8</span>] = &#123; <span class="number">1.0</span>, <span class="number">0.5</span>, <span class="number">0.4</span>, <span class="number">1.0</span>,  <span class="comment">// Start color</span></div><div class="line">                          <span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.3</span>, <span class="number">1.0</span> &#125;; <span class="comment">// End color</span></div><div class="line"> </div><div class="line">myColorspace = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);</div><div class="line">myGradient = CGGradientCreateWithColorComponents (myColorspace, components,</div><div class="line">                          locations, num_locations);</div></pre></td></tr></table></figure>
<p>在创建了CGGradient对象后，我们可以使用它来绘制一个轴向或线性渐变。代码清单8-2声明并设置了线性渐变的起始点然后绘制渐变。图8-1显示了结果。代码没有演示如何获取CGContext对象。</p>
<p><strong>Listing 8-2  Painting an axial gradient using a CGGradient object</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CGPoint myStartPoint, myEndPoint;</div><div class="line">myStartPoint.x = <span class="number">0.0</span>;</div><div class="line">myStartPoint.y = <span class="number">0.0</span>;</div><div class="line">myEndPoint.x = <span class="number">1.0</span>;</div><div class="line">myEndPoint.y = <span class="number">1.0</span>;</div><div class="line">CGContextDrawLinearGradient (myContext, myGradient, myStartPoint, myEndPoint, <span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>代码清单8-3使用代码清单8-1中创建的CGGradient对象来绘制图8-9中径向渐变。这个例子同时也演示了使用纯色来填充渐变的扩展区域。</p>
<p><strong>Listing 8-3  Painting a radial gradient using a CGGradient object</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">CGPoint myStartPoint, myEndPoint;</div><div class="line">CGFloat myStartRadius, myEndRadius;</div><div class="line">myStartPoint.x = <span class="number">0.15</span>;</div><div class="line">myStartPoint.y = <span class="number">0.15</span>;</div><div class="line">myEndPoint.x = <span class="number">0.5</span>;</div><div class="line">myEndPoint.y = <span class="number">0.5</span>;</div><div class="line">myStartRadius = <span class="number">0.1</span>;</div><div class="line">myEndRadius = <span class="number">0.25</span>;</div><div class="line">CGContextDrawRadialGradient (myContext, myGradient, myStartPoint,</div><div class="line">                         myStartRadius, myEndPoint, myEndRadius,</div><div class="line">                         kCGGradientDrawsAfterEndLocation);</div></pre></td></tr></table></figure>
<p><strong>Figure 8-9  A radial gradient painted using a CGGradient object</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/radial_cggradient.jpg" alt="image"></p>
<p>图8-4中的径向渐变使用代码清单8-4中的变量来创建。</p>
<p><strong>Listing 8-4  The variables used to create a radial gradient by varying alpha</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">CGPoint myStartPoint, myEndPoint;</div><div class="line">CGFloat myStartRadius, myEndRadius;</div><div class="line">myStartPoint.x = <span class="number">0.2</span>;</div><div class="line">myStartPoint.y = <span class="number">0.5</span>;</div><div class="line">myEndPoint.x = <span class="number">0.65</span>;</div><div class="line">myEndPoint.y = <span class="number">0.5</span>;</div><div class="line">myStartRadius = <span class="number">0.1</span>;</div><div class="line">myEndRadius = <span class="number">0.25</span>;</div><div class="line"><span class="keyword">size_t</span> num_locations = <span class="number">2</span>;</div><div class="line">CGFloat locations[<span class="number">2</span>] = &#123; <span class="number">0</span>, <span class="number">1.0</span> &#125;;</div><div class="line">CGFloat components[<span class="number">8</span>] = &#123; <span class="number">0.95</span>, <span class="number">0.3</span>, <span class="number">0.4</span>, <span class="number">1.0</span>,</div><div class="line">                          <span class="number">0.95</span>, <span class="number">0.3</span>, <span class="number">0.4</span>, <span class="number">0.1</span> &#125;;</div></pre></td></tr></table></figure>
<p>代码清单8-5显示了用于创建图8-10中的灰色渐变的变量，其中有3个位置。</p>
<p><strong>Listing 8-5  The variables used to create a gray gradient</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">size_t</span> num_locations = <span class="number">3</span>;</div><div class="line">CGFloat locations[<span class="number">3</span>] = &#123; <span class="number">0.0</span>, <span class="number">0.5</span>, <span class="number">1.0</span>&#125;;</div><div class="line">CGFloat components[<span class="number">12</span>] = &#123;  <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>,</div><div class="line">                            <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">1.0</span>,</div><div class="line">                            <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span> &#125;;</div></pre></td></tr></table></figure>
<p><strong>Figure 8-10  An axial gradient with three locations</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/gray_gradient_3.jpg" alt="image"></p>
<h2 id="使用CGShading对象"><a href="#使用CGShading对象" class="headerlink" title="使用CGShading对象"></a>使用CGShading对象</h2><p>我们通过调用函数CGShadingCreateAxial或CGShadingCreateRadial创建一个CGShading对象来设置一个渐变，调用这些函数需要提供以下参数：</p>
<ol>
<li>CGColorSpace对象：颜色空间</li>
<li>起始点和终点。对于轴向渐变，有轴线的起始点和终点的坐标。对于径向渐变，有起始圆和终点圆中心的坐标。</li>
<li>用于定义渐变区域的圆的起始半径与终止半径。</li>
<li>一个CGFunction对象，可以通过CGFunctionCreate函数来获取。这个回调例程必须返回绘制到特定点的颜色值。</li>
<li>一个布尔值，用于指定是否使用纯色来绘制起始点与终点的扩展区域。</li>
</ol>
<p>我们提供给CGShading创建函数的CGFunction对象包含一个回调结构体，及Quartz需要实现这个回调的所有信息。也许设置CGShasing对象的最棘手的部分是创建CGFunction对象。当我们调用CGFunctionCreate函数时，我们提供以下参数： </p>
<ol>
<li>指向回调所需要的数据的指针</li>
<li>回调的输入值的个数。Quartz要求回调携带一个输入值。</li>
<li>一个浮点数的数组。Quartz只会提供数组中的一个元素给回调函数。一个转入值的范围是0(渐变的开始点的颜色)到1(渐变的结束点的颜色)。</li>
<li>回调提供的输出值的数目。对于每一个输入值，我们的回调必须为每个颜色组件提供一个值，以及一个alpha值来指定透明度。颜色组件值由Quartz提供的颜色空间来解释，并会提供给CGShading创建函数。例如，如果我们使用RGB颜色空间，则我们提供值4作为输出值(R,G,B,A)的数目。</li>
<li>一个浮点数的数组，用于指定每个颜色组件的值及alpha值。</li>
<li>一个回调数据结构，包含结构体的版本(设置为0)、生成颜色组件值的回调、一个可选的用于释放回调中info参数表示的数据。该回调类似于以下格式：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">myCalculateShadingValues</span> <span class="params">(<span class="keyword">void</span> *info, <span class="keyword">const</span> CGFloat *in, CGFloat *out)</span></span></div></pre></td></tr></table></figure>
<p>在创建CGShading对象后，如果需要我们可以设置额外的裁减操作。然后调用CGContextDrawShading函数来使用渐变来绘制上下文的裁减区域。当调用这个函数时，Quartz调用回调函数来获取从起点到终点这个范围内的颜色值。</p>
<p>当不再需要CGShading对象时，我们调用CGShadingRelease来释放它。</p>
<p>下面我们将一步步地通过代码来看看如何使用CGShading对象来绘制渐变。</p>
<h3 id="使用CGShading对象绘制一个轴向渐变"><a href="#使用CGShading对象绘制一个轴向渐变" class="headerlink" title="使用CGShading对象绘制一个轴向渐变"></a>使用CGShading对象绘制一个轴向渐变</h3><p>绘制轴向和径向渐变的步骤是差不多的。这个例子演示了如何使用一个CGShading对象来绘制一个轴向渐变，并在图形上下文中绘制一个半圆形的裁减路径，然后将渐变绘制到裁减区域来达到图8-11的效果。</p>
<p><strong>Figure 8-11  An axial gradient that is clipped and painted</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/axial_shading_arc.gif" alt="image"></p>
<p>为了绘制图中的轴向渐变，需要按以下步骤来处理：</p>
<ol>
<li>设置CGFunction对象来计算颜色值</li>
<li>创建轴向渐变的CGShading对象</li>
<li>裁减上下文</li>
<li>使用CGShading对象来绘制轴向渐变</li>
<li>释放对象</li>
</ol>
<h4 id="设置CGFunction对象来计算颜色值"><a href="#设置CGFunction对象来计算颜色值" class="headerlink" title="设置CGFunction对象来计算颜色值"></a>设置CGFunction对象来计算颜色值</h4><p>我们可以以我们想要的方式来计算颜色值，我们的颜色计算函数包含以下三个参数：</p>
<ol>
<li>void *info：这个值可以为NULL或者是一个指向传递给CGShading创建函数的数据。</li>
<li>const CGFloat *in：Quartz传递in数组给回调。数组中的值必须在为CGFunction对象定义的输入值范围内。例如，输入范围是0到1；看代码清单8-7</li>
<li>CGFloat *out：我们的回调函数传递out数组给Quartz。它包含用于颜色空间中每个颜色组件的元素及一个alpha值。输出值应该在CGFunction对象中定义的输出值的范围内，例如，输出范围是0到1；看代码清单8-7。</li>
</ol>
<p>更多关于参数的信息可以查看CGFunctionEvaluateCallback。</p>
<p>代码清单8-6演示了一个函数，它通过将一个常数数组中的值乘以输入值来计算颜色组件值。因为输入值在0到1之间，所以输入值位于黑色(对于RGB来说值为0, 0, 0)和紫色(1, 0, 0.5)之间。注意最后一个组件通常设置为1，表示颜色总是完全不透明的。</p>
<p><strong>Listing 8-6  Computing color component values</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myCalculateShadingValues</span> <span class="params">(<span class="keyword">void</span> *info,</span></span></div><div class="line">                            <span class="keyword">const</span> CGFloat *in,</div><div class="line">                            CGFloat *out)</div><div class="line">&#123;</div><div class="line">    CGFloat v;</div><div class="line">    <span class="keyword">size_t</span> k, components;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> CGFloat c[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">.5</span>, <span class="number">0</span> &#125;;</div><div class="line"> </div><div class="line">    components = (<span class="keyword">size_t</span>)info;</div><div class="line"> </div><div class="line">    v = *in;</div><div class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; components <span class="number">-1</span>; k++)</div><div class="line">        *out++ = c[k] * v;</div><div class="line">     *out++ = <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在写完回调计算颜色值后，我们将其打包以作为CGFunction对象的一部分。代码清单显示了一个函数，它创建了一个包含代码清单8-6中的回调函数的CGFunction对象。</p>
<p><strong>Listing 8-7  Creating a CGFunction object</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> CGFunctionRef <span class="title">myGetFunction</span> <span class="params">(CGColorSpaceRef colorspace)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">size_t</span> numComponents;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> CGFloat input_value_range [<span class="number">2</span>] = &#123; <span class="number">0</span>, <span class="number">1</span> &#125;;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> CGFloat output_value_ranges [<span class="number">8</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span> &#125;;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> CGFunctionCallbacks callbacks = &#123; <span class="number">0</span>,</div><div class="line">                                &amp;myCalculateShadingValues,</div><div class="line">                                <span class="literal">NULL</span> &#125;;</div><div class="line"> </div><div class="line">    numComponents = <span class="number">1</span> + CGColorSpaceGetNumberOfComponents (colorspace);</div><div class="line">    <span class="keyword">return</span> CGFunctionCreate ((<span class="keyword">void</span> *) numComponents,</div><div class="line">                                <span class="number">1</span>, </div><div class="line">                                input_value_range, </div><div class="line">                                numComponents, </div><div class="line">                                output_value_ranges, </div><div class="line">                                &amp;callbacks);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="创建一个轴向渐变的CGShading对象"><a href="#创建一个轴向渐变的CGShading对象" class="headerlink" title="创建一个轴向渐变的CGShading对象"></a>创建一个轴向渐变的CGShading对象</h4><p>为了创建一个CGShading对象，我们调用CGShadingCreateAxial函数，如代码清单8-8所示。我们传递一个颜色空间，开始点和结束点，一个CGFunction对象，和一个用于指定是否填充渐变的开始点和结束点扩展的布尔值。</p>
<p><strong>Listing 8-8  Creating a CGShading object for an axial gradient</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">CGPoint     startPoint,</div><div class="line">            endPoint;</div><div class="line">CGFunctionRef myFunctionObject;</div><div class="line">CGShadingRef myShading;</div><div class="line"> </div><div class="line">startPoint = CGPointMake(<span class="number">0</span>,<span class="number">0.5</span>);</div><div class="line">endPoint = CGPointMake(<span class="number">1</span>,<span class="number">0.5</span>);</div><div class="line">colorspace = CGColorSpaceCreateDeviceRGB();</div><div class="line">myFunctionObject = myGetFunction (colorspace);</div><div class="line"> </div><div class="line">myShading = CGShadingCreateAxial (colorspace,</div><div class="line">                        startPoint, endPoint,</div><div class="line">                        myFunctionObject,</div><div class="line">                        <span class="literal">false</span>, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<h4 id="裁减上下文"><a href="#裁减上下文" class="headerlink" title="裁减上下文"></a>裁减上下文</h4><p>当绘制一个渐变时，Quartz填充当前上下文。绘制一个渐变与操作颜色和模式不同，后者是用于描边或填充一个路径对象。因此，如果要我们的渐变出现在一个特定形状中，我们需要裁减上下文。代码清单8-9的代码添加了一个半圆形到当前上下文，以便渐变绘制到这个裁减区域，如图8-11。</p>
<p>如果我们仔细看，会发现代码绘制的是一个半圆，而图中显示的是一个半椭圆形。为什么呢？我们会看到，当我们查看后面完整的绘制代码时，上下文被缩放了。稍后会详细说明。虽然我们不需要使用缩放或裁减，这些在Quartz 2D中的选项可以帮助我们达到有趣的效果。</p>
<p><strong>Listing 8-9  Adding a semicircle clip to the graphics context</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CGContextBeginPath (myContext);</div><div class="line">CGContextAddArc (myContext, <span class="number">.5</span>, <span class="number">.5</span>, <span class="number">.3</span>, <span class="number">0</span>,</div><div class="line">               my_convert_to_radians (<span class="number">180</span>), <span class="number">0</span>);</div><div class="line">CGContextClosePath (myContext);</div><div class="line">CGContextClip (myContext);</div></pre></td></tr></table></figure>
<h4 id="使用CGShading对象来绘制轴向渐变"><a href="#使用CGShading对象来绘制轴向渐变" class="headerlink" title="使用CGShading对象来绘制轴向渐变"></a>使用CGShading对象来绘制轴向渐变</h4><p>调用函数CGContextDrawShading使用CGShading对象为指定的颜色渐变来填充当前上下文：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CGContextDrawShading (myContext, myShading);</div></pre></td></tr></table></figure>
<h4 id="释放对象"><a href="#释放对象" class="headerlink" title="释放对象"></a>释放对象</h4><p>当我们不再需要CGShading对象时，可以调用函数CGShadingRelease来释放它。我们需要同时释放CGColorSpace对象和CGFunction对象，如代码清单8-10所示：</p>
<p><strong>Listing 8-10  Releasing objects</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CGShadingRelease (myShading);</div><div class="line">CGColorSpaceRelease (colorspace);</div><div class="line">CGFunctionRelease (myFunctionObject);</div></pre></td></tr></table></figure>
<h4 id="使用CGShading对象绘制轴向渐变的完整例程"><a href="#使用CGShading对象绘制轴向渐变的完整例程" class="headerlink" title="使用CGShading对象绘制轴向渐变的完整例程"></a>使用CGShading对象绘制轴向渐变的完整例程</h4><p>代码清单8-11显示了绘制一个轴向渐变的完整例程，使用8-7中的CGFunction对象和8-6中的回调函数。</p>
<p><strong>Listing 8-11  Painting an axial gradient using a CGShading object</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPaintAxialShading</span> <span class="params">(CGContextRef myContext,</span></span></div><div class="line">                            CGRect bounds)</div><div class="line">&#123;</div><div class="line">    CGPoint     startPoint,</div><div class="line">                endPoint;</div><div class="line">    CGAffineTransform myTransform;</div><div class="line">    CGFloat width = bounds.size.width;</div><div class="line">    CGFloat height = bounds.size.height;</div><div class="line"> </div><div class="line"> </div><div class="line">    startPoint = CGPointMake(<span class="number">0</span>,<span class="number">0.5</span>); </div><div class="line">    endPoint = CGPointMake(<span class="number">1</span>,<span class="number">0.5</span>);</div><div class="line"> </div><div class="line">    colorspace = CGColorSpaceCreateDeviceRGB();</div><div class="line">    myShadingFunction = myGetFunction(colorspace);</div><div class="line"> </div><div class="line">    shading = CGShadingCreateAxial (colorspace, </div><div class="line">                                 startPoint, endPoint,</div><div class="line">                                 myShadingFunction,</div><div class="line">                                 <span class="literal">false</span>, <span class="literal">false</span>);</div><div class="line"> </div><div class="line">    myTransform = CGAffineTransformMakeScale (width, height);</div><div class="line">    CGContextConcatCTM (myContext, myTransform);</div><div class="line">    CGContextSaveGState (myContext);</div><div class="line"> </div><div class="line">    CGContextClipToRect (myContext, CGRectMake(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>));</div><div class="line">    CGContextSetRGBFillColor (myContext, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</div><div class="line">    CGContextFillRect (myContext, CGRectMake(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>));</div><div class="line"> </div><div class="line">    CGContextBeginPath (myContext);</div><div class="line">    CGContextAddArc (myContext, <span class="number">.5</span>, <span class="number">.5</span>, <span class="number">.3</span>, <span class="number">0</span>,</div><div class="line">                        my_convert_to_radians (<span class="number">180</span>), <span class="number">0</span>);</div><div class="line">    CGContextClosePath (myContext);</div><div class="line">    CGContextClip (myContext);</div><div class="line"> </div><div class="line">    CGContextDrawShading (myContext, shading);</div><div class="line">    CGColorSpaceRelease (colorspace);</div><div class="line">    CGShadingRelease (shading);</div><div class="line">    CGFunctionRelease (myShadingFunction);</div><div class="line"> </div><div class="line">    CGContextRestoreGState (myContext); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用CGShading对象绘制一个径向渐变"><a href="#使用CGShading对象绘制一个径向渐变" class="headerlink" title="使用CGShading对象绘制一个径向渐变"></a>使用CGShading对象绘制一个径向渐变</h3><p>这个例子演示了如何使用CGShading对象来生成如图8-12所示的输出</p>
<p><strong>Figure 8-12  A radial gradient created using a CGShading object</strong></p>
<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/radial_shading.gif" alt="image"></p>
<p>为了绘制一个径向渐变，我们需要按以下步骤来处理：</p>
<ol>
<li>设置CGFunction对象来计算颜色值</li>
<li>创建径向渐变的CGShading对象</li>
<li>使用CGShading对象来绘制径向渐变</li>
<li>释放对象</li>
</ol>
<h4 id="设置CGFunction对象来计算颜色值-1"><a href="#设置CGFunction对象来计算颜色值-1" class="headerlink" title="设置CGFunction对象来计算颜色值"></a>设置CGFunction对象来计算颜色值</h4><p>计算径向渐变和轴向渐变颜色值的函数没有什么区别。事实上，我们可以依照上面的轴向的”设置CGFunction对象来计算颜色值”。代码清单8-12用于计算颜色，使用颜色按正弦变化。图8-12与图8-11的结果非常不同。虽然颜色输出值不同，代码清单8-12的代码与8-6中的函数遵循相同的原型。每个函数获取一个输入值并计算N个值，即颜色空间的每个颜色组件加一个alpha值。</p>
<p><strong>Listing 8-12  Computing color component values</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">myCalculateShadingValues</span> <span class="params">(<span class="keyword">void</span> *info,</span></span></div><div class="line">                                <span class="keyword">const</span> CGFloat *in,</div><div class="line">                                CGFloat *out)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">size_t</span> k, components;</div><div class="line">    <span class="keyword">double</span> frequency[<span class="number">4</span>] = &#123; <span class="number">55</span>, <span class="number">220</span>, <span class="number">110</span>, <span class="number">0</span> &#125;;</div><div class="line">    components = (<span class="keyword">size_t</span>)info;</div><div class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; components - <span class="number">1</span>; k++)</div><div class="line">        *out++ = (<span class="number">1</span> + <span class="built_in">sin</span>(*in * frequency[k]))/<span class="number">2</span>;</div><div class="line">     *out++ = <span class="number">1</span>; <span class="comment">// alpha</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在写完颜色计算函数后调用它，我们需要创建一个CGFunction对象，如在轴向中”设置CGFunction对象来计算颜色值”所描述的一样。</p>
<h4 id="创建径向渐变的CGShading对象"><a href="#创建径向渐变的CGShading对象" class="headerlink" title="创建径向渐变的CGShading对象"></a>创建径向渐变的CGShading对象</h4><p>为了创建一个CGShading对象或者一个径向渐变，我们调用CGShadingCreateRadial函数，如代码清单8-13所求，传递一个颜色空间、开始点和结束点，开始半径和结束半径，一个CGFunction对象，和一个用于指定是否填充渐变的开始点和结束点扩展的布尔值。</p>
<p><strong>Listing 8-13  Creating a CGShading object for a radial gradient</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">CGPoint startPoint, endPoint;</div><div class="line">CGFloat startRadius, endRadius;</div><div class="line"> </div><div class="line">startPoint = CGPointMake(<span class="number">0.25</span>,<span class="number">0.3</span>);</div><div class="line">startRadius = <span class="number">.1</span>;</div><div class="line">endPoint = CGPointMake(<span class="number">.7</span>,<span class="number">0.7</span>);</div><div class="line">endRadius = <span class="number">.25</span>;</div><div class="line">colorspace = CGColorSpaceCreateDeviceRGB();</div><div class="line">myShadingFunction = myGetFunction (colorspace);</div><div class="line">CGShadingCreateRadial (colorspace,</div><div class="line">               startPoint,</div><div class="line">               startRadius,</div><div class="line">               endPoint,</div><div class="line">               endRadius,</div><div class="line">               myShadingFunction,</div><div class="line">               <span class="literal">false</span>,</div><div class="line">               <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<h4 id="使用CGShading对象来绘制径向渐变"><a href="#使用CGShading对象来绘制径向渐变" class="headerlink" title="使用CGShading对象来绘制径向渐变"></a>使用CGShading对象来绘制径向渐变</h4><p>调用函数CGContextDrawShading使用CGShading对象为指定的颜色渐变来填充当前上下文：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CGContextDrawShading (myContext, myShading);</div></pre></td></tr></table></figure>
<p>注意我们使用相同的函数来绘制渐变，而不管它是轴向还是径向。</p>
<h4 id="释放对象-1"><a href="#释放对象-1" class="headerlink" title="释放对象"></a>释放对象</h4><p>当我们不再需要CGShading对象时，可以调用函数CGShadingRelease来释放它。我们需要同时释放CGColorSpace对象和CGFunction对象，如代码清单8-14所示：</p>
<p><strong>Listing 8-10  Releasing objects</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CGShadingRelease (myShading);</div><div class="line">CGColorSpaceRelease (colorspace);</div><div class="line">CGFunctionRelease (myFunctionObject);</div></pre></td></tr></table></figure>
<h4 id="使用CGShading对象绘制径向渐变的完整例程"><a href="#使用CGShading对象绘制径向渐变的完整例程" class="headerlink" title="使用CGShading对象绘制径向渐变的完整例程"></a>使用CGShading对象绘制径向渐变的完整例程</h4><p>代码清单8-15显示了绘制一个轴径向渐变的完整例程，使用8-7中的CGFunction对象和8-12中的回调函数。</p>
<p><strong>Listing 8-15  A routine that paints a radial gradient using a CGShading object</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPaintRadialShading</span> <span class="params">(CGContextRef myContext,</span></span></div><div class="line">                            CGRect bounds);</div><div class="line">&#123;</div><div class="line">    CGPoint startPoint,</div><div class="line">            endPoint;</div><div class="line">    CGFloat startRadius,</div><div class="line">            endRadius;</div><div class="line">    CGAffineTransform myTransform;</div><div class="line">    CGFloat width = bounds.size.width;</div><div class="line">    CGFloat height = bounds.size.height;</div><div class="line"> </div><div class="line">    startPoint = CGPointMake(<span class="number">0.25</span>,<span class="number">0.3</span>); </div><div class="line">    startRadius = <span class="number">.1</span>;  </div><div class="line">    endPoint = CGPointMake(<span class="number">.7</span>,<span class="number">0.7</span>); </div><div class="line">    endRadius = <span class="number">.25</span>; </div><div class="line"> </div><div class="line">    colorspace = CGColorSpaceCreateDeviceRGB(); </div><div class="line">    myShadingFunction = myGetFunction (colorspace);</div><div class="line"> </div><div class="line">    shading = CGShadingCreateRadial (colorspace, </div><div class="line">                            startPoint, startRadius,</div><div class="line">                            endPoint, endRadius,</div><div class="line">                            myShadingFunction,</div><div class="line">                            <span class="literal">false</span>, <span class="literal">false</span>);</div><div class="line"> </div><div class="line">    myTransform = CGAffineTransformMakeScale (width, height); </div><div class="line">    CGContextConcatCTM (myContext, myTransform); </div><div class="line">    CGContextSaveGState (myContext); </div><div class="line"> </div><div class="line">    CGContextClipToRect (myContext, CGRectMake(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>)); </div><div class="line">    CGContextSetRGBFillColor (myContext, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</div><div class="line">    CGContextFillRect (myContext, CGRectMake(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>));</div><div class="line"> </div><div class="line">    CGContextDrawShading (myContext, shading); </div><div class="line">    CGColorSpaceRelease (colorspace); </div><div class="line">    CGShadingRelease (shading);</div><div class="line">    CGFunctionRelease (myShadingFunction);</div><div class="line"> </div><div class="line">    CGContextRestoreGState (myContext); </div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/12/05/quartz2d-7/" itemprop="url">
                  Quartz 2D编程指南之七：阴影
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-12-05T21:47:51+08:00" content="2014-12-05">
              2014-12-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>阴影是绘制在一个图形对象下的且有一定偏移的图片，它用于模拟光源照射到图形对象上所形成的阴影效果，如果7-1所示。文本也可以有阴影。阴影可以让一幅图像看上去是立体的或者是浮动的。</p>
<p><strong>Figure 7-1  A shadow</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/angle.gif" alt="image"></p>
<p>阴影有三个属性：</p>
<ol>
<li>x偏移值，用于指定阴影相对于图片在水平方向上的偏移值。</li>
<li>y偏移值，用于指定阴影相对于图片在竖直方向上的偏移值。</li>
<li>模糊(blur)值，用于指定图像是有一个硬边(hard edge，如图7-2左边图片所示)，还是一个漫射边(diffuse edge，如图7-1右边图片所示)</li>
</ol>
<p>本章将描述阴影是如何工作的及如何用Quartz 2D API来创建阴影。</p>
<p><strong>Figure 7-2  A shadow with no blur and another with a soft edge</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/blur_value.gif" alt="image"></p>
<h2 id="阴影是如何工作的"><a href="#阴影是如何工作的" class="headerlink" title="阴影是如何工作的"></a>阴影是如何工作的</h2><p>Quartz中的阴影是图形状态的一部分。我们可以调用函数CGContextSetShadow来创建，并传入一个图形上下文、偏移值及模糊值。阴影被设置后，任何绘制的对象都有一个阴影，且该阴影在设备RGB颜色空间中呈现出黑色的且alpha值为1/3。换句话说，阴影是用RGBA值{0, 0, 0, 1.0/3.0}设置的。</p>
<p>我们可以调用函数CGContextSetShadowWithColor来设置彩色阴影，并传递一个图形上下文、 偏移值、模糊值有CGColor颜色对象。颜色值依赖于颜色空间。</p>
<p>如何在调用CGContextSetShadow或CGContextSetShadowWithColor之前保存了图形状态，我们可以通过恢复图形状态来关闭阴影。我们也可以通过设置阴影颜色为NULL来关闭阴影。</p>
<h2 id="基于图形上下文的阴影绘制惯例"><a href="#基于图形上下文的阴影绘制惯例" class="headerlink" title="基于图形上下文的阴影绘制惯例"></a>基于图形上下文的阴影绘制惯例</h2><p>偏移值指定了阴影相对于相关图像的位置。这些偏移值由图形上下文来描述，并用于计算阴影的位置：</p>
<ol>
<li>一个正值的x偏移量指定阴影位于图形对象的右侧。</li>
<li>在Mac OS X中，正值的y指定阴影位于图形对象的上边，这与Quartz 2D默认的坐标值匹配。</li>
<li>在iOS中，如果我们用Quartz 2D API来创建PDF或者位图图形上下文，则正值的y指定阴影位于图形对象的上边。</li>
<li>在iOS中，如果图形上下文是由UIKit创建的，则正值的y指定阴影位于图形对象的下边。这与UIKit坐标系统相匹配。</li>
<li>阴影绘制惯例不受CTM影响</li>
</ol>
<h2 id="绘制阴影"><a href="#绘制阴影" class="headerlink" title="绘制阴影"></a>绘制阴影</h2><p>按照如下步骤来绘制阴影</p>
<ol>
<li>保存图形状态</li>
<li>调用函数CGContextSetShadow，传递相应的值</li>
<li>使用阴影绘制所有的对象</li>
<li>恢复图形状态</li>
</ol>
<p>按照如下步骤来绘制彩色阴影</p>
<ol>
<li>保存图形状态</li>
<li>创建一个CGColorSpace对象，确保Quartz能正确地解析阴影颜色</li>
<li>创建一个CGColor对象来指定阴影的颜色</li>
<li>调用CGContextSetShadowWithColor，并传递相应的值</li>
<li>使用阴影绘制所有的对象</li>
<li>恢复图形状态</li>
</ol>
<p>图7-3显示了两个带有阴影的矩形，其中一个是彩色阴影。</p>
<p><strong>Figure 7-3  A colored shadow and a gray shadow</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/code_shadows.gif" alt="image"></p>
<p>列表清单显示了如何创建图7-3中的图像。</p>
<p><strong>Listing 7-1  A function that sets up shadows</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDrawWithShadows</span> <span class="params">(CGContextRef myContext, <span class="keyword">float</span> wd, <span class="keyword">float</span> ht)</span></span>;</div><div class="line">&#123;</div><div class="line">    CGSize          myShadowOffset = CGSizeMake (<span class="number">-15</span>,  <span class="number">20</span>);</div><div class="line">    <span class="keyword">float</span>           myColorValues[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">.6</span>&#125;;</div><div class="line">    CGColorRef      myColor;</div><div class="line">    CGColorSpaceRef myColorSpace;</div><div class="line">    </div><div class="line">    CGContextSaveGState(myContext);</div><div class="line">    </div><div class="line">    CGContextSetShadow (myContext, myShadowOffset, <span class="number">5</span>); </div><div class="line">    </div><div class="line">    <span class="comment">// Your drawing code here</span></div><div class="line">    CGContextSetRGBFillColor (myContext, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</div><div class="line">    CGContextFillRect (myContext, CGRectMake (wd/<span class="number">3</span> + <span class="number">75</span>, ht/<span class="number">2</span> , wd/<span class="number">4</span>, ht/<span class="number">4</span>));</div><div class="line">    </div><div class="line">    myColorSpace = CGColorSpaceCreateDeviceRGB ();</div><div class="line">    myColor = CGColorCreate (myColorSpace, myColorValues);</div><div class="line">    CGContextSetShadowWithColor (myContext, myShadowOffset, <span class="number">5</span>, myColor);</div><div class="line">    </div><div class="line">    <span class="comment">// Your drawing code here</span></div><div class="line">    CGContextSetRGBFillColor (myContext, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</div><div class="line">    CGContextFillRect (myContext, CGRectMake (wd/<span class="number">3</span><span class="number">-75</span>,ht/<span class="number">2</span><span class="number">-100</span>,wd/<span class="number">4</span>,ht/<span class="number">4</span>));</div><div class="line">    </div><div class="line">    CGColorRelease (myColor);</div><div class="line">    CGColorSpaceRelease (myColorSpace); </div><div class="line">    </div><div class="line">    CGContextRestoreGState(myContext);</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/12/05/quartz2d-6/" itemprop="url">
                  Quartz 2D编程指南之六：模式(Pattern)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-12-05T16:35:04+08:00" content="2014-12-05">
              2014-12-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>模式(Pattern)是绘制操作的一个序列，这些绘制操作可以重复地绘制到一个图形上下文上。我们可以像使用颜色一样使用这些模式。当我们使用pattern来绘制时，Quartz将Page分割成模式单元格的集合，其中每个单元格的大小不是模式图片的大小，并使用我们提供的回调函数来绘制这些单元格。图6-1演示了一个绘制到window图形上下文的模式。</p>
<p><strong>Figure 6-1  A pattern drawn to a window</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/patterned_window.gif" alt="image"></p>
<h2 id="模式的骨架-Anatomy"><a href="#模式的骨架-Anatomy" class="headerlink" title="模式的骨架(Anatomy)"></a>模式的骨架(Anatomy)</h2><p>模式单元格是模式的基础组件。图6-1中的模式的单元格如图6-2所示。其中黑色边框不是模式单元格的一部分；之所以画出来是为了显示模式单元格的边界。</p>
<p><strong>Figure 6-2  A pattern cell</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/pattern_cell_wborder.gif" alt="image"></p>
<p>该模式单元格的大小包含四个带颜色的矩形以及这些矩形上部及右侧的白色区域，如图6-3所示。每个模式单元格的黑色边框不是单元格的一部分；画出来只是为是标明单元格的边界。当我们创建一个模式单元格时，我们需要定义单元格的边界并在这个范围内进行绘制。</p>
<p><strong>Figure 6-3  Pattern cells with black rectangles drawn to show the bounds of each cell</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/pattern_parts_1.gif" alt="image"></p>
<p>我们可以指定水平和竖直方向上两个单元格之间的间距。图6-3所绘制的单元格是相互紧挨着的。而图6-4在两个方向上都指定了单元格之间的间距。我们可以为两个方向指定不同的间距。我们亦可以指定间距为负数，这样单元格便会重叠。</p>
<p><strong>Figure 6-4  Spacing between pattern cells</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/pattern_part_2.gif" alt="image"></p>
<p>当我们绘制一个模式单元格时，Quartz使用<strong>模式空间(pattern space)</strong>作为坐标系统。模式空间是一个抽象空间，它会使用我们创建模式时指定的变换矩阵(pattern matrix)来映射到默认用户空间。</p>
<blockquote>
<p>注意：模式空间与用户空间是分开的。未转换的模式空间映射到基础的用户空间(未转换的)，而不管当前转换矩阵(CTM)。当我们在模式空间上应用转换时，Quartz只将转换应用于模式空间。</p>
</blockquote>
<p>如果我们不想要Quartz来转换模式单元格，我们可以指定单位矩阵。然而，我们可以使用转换矩阵来达到有趣的效果。图6-5显示了缩放6-2中的模式单元格的效果。图6-6旋转了这些单元格。图6-7则平移了这些单元格。    </p>
<p><strong>Figure 6-5  A scaled pattern cell</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/pattern_halfbyonehalf.gif" alt="image"></p>
<p><strong>Figure 6-6  A rotated pattern cell</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/pattern_2PIdiv6.gif" alt="image"><br><strong>Figure 6-7  A translated pattern cell</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/pattern_5_5_translate.gif" alt="image"></p>
<h2 id="着色模式-Colored-Patterns-和模板模式-Stencil-Patterns"><a href="#着色模式-Colored-Patterns-和模板模式-Stencil-Patterns" class="headerlink" title="着色模式(Colored Patterns)和模板模式(Stencil Patterns)"></a>着色模式(Colored Patterns)和模板模式(Stencil Patterns)</h2><p>着色模式有与其相关的固有颜色。如果修改了创建模式单元格的颜色，则模式也便失去了意义。图6-8中显示的苏格兰格子就是着色模式的一个例子。着色模式中的颜色是模式单元格创建流程的一部分，而不是绘制流程的一部分。</p>
<p><strong>Figure 6-8  A colored pattern has inherent color</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/tartan.gif" alt="image"></p>
<p>而其它模式只限定了形状，因此可以认为是模板模式(或者是非着色模式、甚至可以作为图像蒙板)。图6-9中展示的红色和黑色星星就是使用相同的模式单元格。单元格由一个五角星组成。当定义模式单元格时，没有与之相关的颜色。颜色值是在绘制过程中指定的，而不是创建过程的一部分。</p>
<p><strong>Figure 6-9  A stencil pattern does not have inherent color</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/star_patterns.gif" alt="image"></p>
<p>在Quartz 2D中，我们可以创建这两种模式。</p>
<h2 id="平铺-Tiling"><a href="#平铺-Tiling" class="headerlink" title="平铺(Tiling)"></a>平铺(Tiling)</h2><p>平铺(Tiling)是将模式单元格绘制到页面(Page)的某个部分的过程。当Quartz将模式渲染到一个设备时，Quartz可能需要调整模式以适应设备空间。即，在用户空间定义的模式单元格在渲染到设备时可能无法精确匹配，这是由用户空间单元和设备像素之间的差异导致的。</p>
<p>Quartz有三个平铺选项，以在必要时调整模式：</p>
<ol>
<li>没有失真(no distortion): 以细微调整模式单元格之间的间距为代价，但通常不超过一个设备像素。</li>
<li>最小的失真的恒定间距：设定单元格之间的间距，以细微调整单元大小为代价，但通常不超过一个设备像素。</li>
<li>恒定间距：设定单元格之间间距，以调整单元格大小为代价，以求尽快的平铺</li>
</ol>
<h2 id="模式如何工作"><a href="#模式如何工作" class="headerlink" title="模式如何工作"></a>模式如何工作</h2><p>模式操作类似于颜色，我们设置一个填充或描边(stroke)模式，然后调用绘制函数。Quartz使用我们设置的模式作为“涂料”。例如，如果我们要使用纯色绘制一个填充的的矩形，我们首先调用函数(如CGContextSetFillColor)来设置填充颜色。然后调用函数CGContextFillRect以使用我们指定的颜色来填充矩形。为了绘制一个模式，颜色调用函数CGContextSetFillPattern来设置指定的模式。绘制颜色和绘制模式的不同之处在于我们必须先定义一个模式。我们为函数CGContextSetFillPattern提供模式和颜色信息。我们将在下面的绘制着色模式和绘制模板模式章节看到如何创建、设置和绘制模式。</p>
<p>这里有个例子说明Quartz在幕后是如何绘制一个模式的。当我们填充或描边一个模式时，Quartz会按照以下指令来绘制每一个模式单元格：</p>
<ol>
<li>保存图形状态</li>
<li>将当前转换矩阵应用到原始的模式单元格上</li>
<li>连接CTM与模式矩阵</li>
<li>裁剪模式单元格的边界矩形</li>
<li>调用绘制回调函数来绘制单元格</li>
<li>恢复图形状态</li>
</ol>
<p>Quartz会执行所有平铺操作，重复绘制模式单元格到绘制空间，直到渲染满整个空间。我们可以填充和描边一个模式。模式单元格可以是指定的任何大小。如果我们想要看到模式，我们需要确保模式单元格与绘制空间匹配。例如，如果我们的模式单元格是8*10个单位的，而我们用这个模式来描边一个只有2个单位的直线，则这个模式单元格将会被裁剪。这种情况下，我们可能无法辨认出我们的模式。</p>
<h2 id="绘制着色模式"><a href="#绘制着色模式" class="headerlink" title="绘制着色模式"></a>绘制着色模式</h2><p>绘制着色模式需要执行以下五步操作：</p>
<ol>
<li>写一个绘制着色模式单元格的回调函数</li>
<li>设置着色模式的颜色空间</li>
<li>设置着色模式的骨架(Anatomy)</li>
<li>指定着色模式作为填充或描边模式</li>
<li>使用着色模式绘制</li>
</ol>
<p>绘制模板模式也是类似这几步。两者之间的区别在于如何设置颜色信息。</p>
<h3 id="写一个绘制着色模式单元格的回调函数"><a href="#写一个绘制着色模式单元格的回调函数" class="headerlink" title="写一个绘制着色模式单元格的回调函数"></a>写一个绘制着色模式单元格的回调函数</h3><p>一个模式单元格看起来是什么样的完全取决于我们。在这个例子中，代码清单6-1绘制了图6-2所示的模式单元格。</p>
<p><strong>Listing 6-1  A drawing callback that draws a colored pattern cell</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> H_PATTERN_SIZE 16</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> V_PATTERN_SIZE 18</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDrawColoredPattern</span> <span class="params">(<span class="keyword">void</span> *info, CGContextRef myContext)</span></span></div><div class="line">&#123;</div><div class="line">    CGFloat subunit = <span class="number">5</span>; </div><div class="line"> </div><div class="line"> 	CGSize size = &#123;subunit, subunit&#125;;</div><div class="line"> 	CGPoint point1 = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;, point2 = &#123;subunit, subunit&#125;, point3 = &#123;<span class="number">0</span>,subunit&#125;, point4 = &#123;subunit,<span class="number">0</span>&#125;;</div><div class="line">    CGRect myRect1 = &#123;point1, size&#125;, myRect2 = &#123;point2, size&#125;, myRect3 = &#123;point3, size&#125;, myRect4 = &#123;point4, size&#125;;</div><div class="line">    </div><div class="line">    CGContextSetRGBFillColor (myContext, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0.5</span>);</div><div class="line">    CGContextFillRect (myContext, myRect1);</div><div class="line">    CGContextSetRGBFillColor (myContext, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</div><div class="line">    CGContextFillRect (myContext, myRect2);</div><div class="line">    CGContextSetRGBFillColor (myContext, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0.5</span>);</div><div class="line">    CGContextFillRect (myContext, myRect3);</div><div class="line">    CGContextSetRGBFillColor (myContext, <span class="number">.5</span>, <span class="number">0</span>, <span class="number">.5</span>, <span class="number">0.5</span>);</div><div class="line">    CGContextFillRect (myContext, myRect4);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>模式单元格绘制函数是类似于下面这种格式的一个回调函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*CGPatternDrawPatternCallback)</span> <span class="params">(</span></span></div><div class="line">                        <span class="keyword">void</span> *info,</div><div class="line">                        CGContextRef context</div><div class="line">);</div></pre></td></tr></table></figure>
<p>我们可以随意命名我们的回调函数。代码清单6-1中命名为MyDrawColoredPattern。这个回调函数带有两个参数：</p>
<ol>
<li>info: 一个指向模式相关数据的指针。这个参数是可选的，可以传递NULL。传递给回调的数据与后面创建模式的数据是一样的。</li>
<li>context: 绘制模式单元格的图形上下文</li>
</ol>
<p>代码清单6-1中绘制的模式单元格是随意的。以下是一些关于绘制代码的重要信息：</p>
<ol>
<li>需要声明模式大小。在绘制时我们需要记住模式大小。在这个例子中，大小是全局声明的，绘制函数没有具体提到大小，除了在注释中。然后，我们将模式大小指定给Quartz 2D。</li>
<li>绘制函数后面是由CGPatternDrawPatternCallback回调函数类型定义定义的原型</li>
<li>代码中执行的绘制设置了颜色，让其成为一个着色模式。</li>
</ol>
<h3 id="设置着色模式的颜色空间"><a href="#设置着色模式的颜色空间" class="headerlink" title="设置着色模式的颜色空间"></a>设置着色模式的颜色空间</h3><p>代码清单6-1中的代码使用颜色来绘制模式单元格。我们必须设置基本的模式颜色空间为NULL，以确保Quartz使用绘制路径指定的颜色来绘制，如代码清单6-2所示。</p>
<p><strong>Listing 6-2  Creating a base pattern color space</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">CGColorSpaceRef patternSpace;</div><div class="line"> </div><div class="line"><span class="comment">// 创建模式颜色空间，并传递NULL作为参数</span></div><div class="line">patternSpace = CGColorSpaceCreatePattern (<span class="literal">NULL</span>);</div><div class="line">	</div><div class="line"><span class="comment">// 在模式颜色空间中设置填充颜色</span></div><div class="line">CGContextSetFillColorSpace (myContext, patternSpace);</div><div class="line">	</div><div class="line"><span class="comment">// 释放模式颜色空间</span></div><div class="line">CGColorSpaceRelease (patternSpace);</div></pre></td></tr></table></figure>
<h3 id="设置着色模式的骨架"><a href="#设置着色模式的骨架" class="headerlink" title="设置着色模式的骨架"></a>设置着色模式的骨架</h3><p>一个模式的骨架基本信息保存在CGPattern对象中。我们调用CGPatternCreate函数来创建一个CGPattern对象，其原型如代码清单6-3所示：</p>
<p><strong>Listing 6-3  The CGPatternCreate function prototype</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CGPatternRef CGPatternCreate (  void *info,</div><div class="line">                                CGRect bounds,</div><div class="line">                                CGAffineTransform matrix,</div><div class="line">                                CGFloat xStep,</div><div class="line">                                CGFloat yStep,</div><div class="line">                                CGPatternTiling tiling,</div><div class="line">                                bool isColored,</div><div class="line">                                const CGPatternCallbacks *callbacks );</div></pre></td></tr></table></figure>
<p>其中，</p>
<ol>
<li>info：是一个指针，指向我们要传递给绘制回调函数的数据</li>
<li>bound：指定模式单元格的大小</li>
<li>matrix：指定模式矩阵，它将模式坐标系统映射到图形上下文的默认坐标系统。如果希望两个坐标系统是一样的，则可以使用单位矩阵。</li>
<li>xStep, yStep：指定单元格之间的水平和竖直间距。</li>
<li>tiling：平铺模式，可以是kCGPatternTilingNoDistortion、kCGPatternTilingConstantSpacingMinimalDistortion、kCGPatternTilingConstantSpacing</li>
<li>isColored：指定模式单元格是着色模式(true)还是模板模式(false)</li>
<li>callbacks：是一个指向CGPatternCallbacks结构体的指针，则定义如下：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> CGPatternCallbacks</div><div class="line">&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> version;</div><div class="line">    CGPatternDrawPatternCallback drawPattern;</div><div class="line">    CGPatternReleaseInfoCallback releaseInfo;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我们可以设置version为0。drawPattern是指向绘制回调的指针。releaseInfo是指向一个回调函数，该回调在释放CGPattern对象时被调用，以释放存储在我们传递给绘制回调的info参数中的数据。如果在这个参数中没有传递任何数据，则设置该域为NULL。</p>
<h3 id="指定着色模式作为填充或描边模式"><a href="#指定着色模式作为填充或描边模式" class="headerlink" title="指定着色模式作为填充或描边模式"></a>指定着色模式作为填充或描边模式</h3><p>我们可以调用CGContextSetFillPattern或者CGContextSetStrokePattern函数来使用模式进行填充或描边。Quartz可以将模式用于任何填充或描边流程。</p>
<p>这两个函数包含以下几个参数：</p>
<ol>
<li>图形上下文</li>
<li>先前创建的CGPattern对象</li>
<li>颜色组件的数组</li>
</ol>
<p>虽然着色模式提供了自己的颜色，我们仍然需要传递一个单一的alpha值来告诉Quartz在绘制时着色模式的透明度。alpha值的范围在0到1中。可以如以下代码来设置着色模式的透明度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CGFloat alpha = <span class="number">1</span>;</div><div class="line"> </div><div class="line">CGContextSetFillPattern (myContext, myPattern, &amp;alpha);</div></pre></td></tr></table></figure>
<h3 id="使用颜色模式绘制"><a href="#使用颜色模式绘制" class="headerlink" title="使用颜色模式绘制"></a>使用颜色模式绘制</h3><p>在完成前面的步骤之后，我们就可以调用Quartz 2D函数来绘制了。我们的模式被当作“涂料”。例如，可以调用CGContextStrokePath, CGContextFillPath, CGContextFillRect或其它函数来绘制。</p>
<h3 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h3><p>代码清单6-4包含一个绘制着色模式的函数。这个函数包含了前面讨论的所有步骤。</p>
<p><strong>Listing 6-4  A function that paints a colored pattern</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyColoredPatternPainting</span> <span class="params">(CGContextRef myContext,</span></span></div><div class="line">                 CGRect rect)</div><div class="line">&#123;</div><div class="line">    CGPatternRef    pattern;</div><div class="line">    CGColorSpaceRef patternSpace;</div><div class="line">    CGFloat         alpha = <span class="number">1</span>,</div><div class="line">                    width, height;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span>    CGPatternCallbacks callbacks = &#123;<span class="number">0</span>, </div><div class="line">                                        &amp;MyDrawPattern,</div><div class="line">                                        <span class="literal">NULL</span>&#125;;</div><div class="line"> </div><div class="line">    CGContextSaveGState (myContext);</div><div class="line">    patternSpace = CGColorSpaceCreatePattern (<span class="literal">NULL</span>);</div><div class="line">    CGContextSetFillColorSpace (myContext, patternSpace);</div><div class="line">    CGColorSpaceRelease (patternSpace);</div><div class="line"> </div><div class="line">    pattern = CGPatternCreate (<span class="literal">NULL</span>, </div><div class="line">                    CGRectMake (<span class="number">0</span>, <span class="number">0</span>, H_PSIZE, V_PSIZE),</div><div class="line">                    CGAffineTransformMake (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>),</div><div class="line">                    H_PATTERN_SIZE, </div><div class="line">                    V_PATTERN_SIZE, </div><div class="line">                    kCGPatternTilingConstantSpacing,</div><div class="line">                    <span class="literal">true</span>, </div><div class="line">                    &amp;callbacks);</div><div class="line"> </div><div class="line">    CGContextSetFillPattern (myContext, pattern, &amp;alpha);</div><div class="line">    CGPatternRelease (pattern);</div><div class="line">    CGContextFillRect (myContext, rect);</div><div class="line">    CGContextRestoreGState (myContext);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="绘制模板模式"><a href="#绘制模板模式" class="headerlink" title="绘制模板模式"></a>绘制模板模式</h2><p>与绘制着色模式类似，绘制模板模式也有5个步骤：</p>
<ol>
<li>写一个绘制模板模式单元格的回调函数</li>
<li>设置模板模式的颜色空间</li>
<li>设置模板模式的骨架(Anatomy)</li>
<li>指定模板模式作为填充或描边模式</li>
<li>使用模板模式绘制</li>
</ol>
<p>绘制模板模式与绘制着色模式的区别在于设置颜色信息。</p>
<h3 id="写一个绘制模板模式单元格的回调函数"><a href="#写一个绘制模板模式单元格的回调函数" class="headerlink" title="写一个绘制模板模式单元格的回调函数"></a>写一个绘制模板模式单元格的回调函数</h3><p>绘制模板模式单元格的回调与前面描述的绘制颜色模式单元格类似。不同的是绘制模式单元格回调不需要指定颜色值。图6-10中显示的模式单元格即没有从绘制回调中获取颜色。</p>
<p><strong>Figure 6-10  A stencil pattern cell</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/star_stencil.gif" alt="image"></p>
<p>代码清单6-5绘制了图6-10中的模式单元格。可以看到代码只是简单地创建并填充了一个路径，而没有设置颜色。</p>
<p><strong>Listing 6-5  A drawing callback that draws a stencil pattern cell</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PSIZE 16    <span class="comment">// size of the pattern cell</span></span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MyDrawStencilStar</span> <span class="params">(<span class="keyword">void</span> *info, CGContextRef myContext)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> k;</div><div class="line">    <span class="keyword">double</span> r, theta;</div><div class="line"> </div><div class="line">    r = <span class="number">0.8</span> * PSIZE / <span class="number">2</span>;</div><div class="line">    theta = <span class="number">2</span> * M_PI * (<span class="number">2.0</span> / <span class="number">5.0</span>); <span class="comment">// 144 degrees</span></div><div class="line"> </div><div class="line">    CGContextTranslateCTM (myContext, PSIZE/<span class="number">2</span>, PSIZE/<span class="number">2</span>);</div><div class="line"> </div><div class="line">    CGContextMoveToPoint(myContext, <span class="number">0</span>, r);</div><div class="line">    <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt; <span class="number">5</span>; k++) &#123;</div><div class="line">        CGContextAddLineToPoint (myContext,</div><div class="line">                    r * <span class="built_in">sin</span>(k * theta),</div><div class="line">                    r * <span class="built_in">cos</span>(k * theta));</div><div class="line">    &#125;</div><div class="line">    CGContextClosePath(myContext);</div><div class="line">    CGContextFillPath(myContext);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="设置模板模式的颜色空间"><a href="#设置模板模式的颜色空间" class="headerlink" title="设置模板模式的颜色空间"></a>设置模板模式的颜色空间</h3><p>模板模式要求我们设置一个模式颜色空间用于Quartz的绘制，如代码清单6-6所示。</p>
<p><strong>Listing 6-6  Code that creates a pattern color space for a stencil pattern</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">CGPatternRef pattern;</div><div class="line">CGColorSpaceRef baseSpace;</div><div class="line">CGColorSpaceRef patternSpace;</div><div class="line"></div><div class="line"><span class="comment">// 创建一个通用RGB颜色空间。 </span></div><div class="line">baseSpace = CGColorSpaceCreateWithName (kCGColorSpaceGenericRGB);</div><div class="line">	</div><div class="line"><span class="comment">// 创建一个模式颜色空间。该颜色空间指定如何表示模式的颜色。后面要设置模式的颜色时，必须使用这个颜色空间来进行设置</span></div><div class="line">patternSpace = CGColorSpaceCreatePattern (baseSpace);</div><div class="line">	</div><div class="line"><span class="comment">// 设置颜色空间来在填充模式时使用</span></div><div class="line">CGContextSetFillColorSpace (myContext, patternSpace);</div><div class="line">	</div><div class="line"><span class="comment">// 释放模式颜色空间</span></div><div class="line">CGColorSpaceRelease(patternSpace);</div><div class="line">	</div><div class="line"><span class="comment">// 释放基础颜色空间</span></div><div class="line">CGColorSpaceRelease(baseSpace);</div></pre></td></tr></table></figure>
<h3 id="设置模板模式的骨架-Anatomy"><a href="#设置模板模式的骨架-Anatomy" class="headerlink" title="设置模板模式的骨架(Anatomy)"></a>设置模板模式的骨架(Anatomy)</h3><p>这一步与上面设置着色模式是一样的，不同的是isColored参数需要传递false。</p>
<h3 id="指定模板模式作为填充或描边模式"><a href="#指定模板模式作为填充或描边模式" class="headerlink" title="指定模板模式作为填充或描边模式"></a>指定模板模式作为填充或描边模式</h3><p>我们可以调用CGContextSetFillPattern或者CGContextSetStrokePattern函数来使用模式进行填充或描边。Quartz可以将模式用于任何填充或描边流程。</p>
<p>这两个函数包含以下几个参数：</p>
<ol>
<li>图形上下文</li>
<li>先前创建的CGPattern对象</li>
<li>颜色组件的数组</li>
</ol>
<p>由于模板模式在绘制回调中不提供颜色值，所以我们必须传递一个颜色给填充或描边函数来告诉Quartz使用什么颜色。代码清单6-7显示了为模板模式设置颜色的例子。</p>
<p><strong>Listing 6-7  Code that sets opacity for a colored pattern</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> CGFloat color[<span class="number">4</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0.5</span> &#125;; <span class="comment">//cyan, 50% transparent</span></div><div class="line">CGContextSetFillPattern (myContext, myPattern, color);</div></pre></td></tr></table></figure>
<h3 id="使用模板模式绘制"><a href="#使用模板模式绘制" class="headerlink" title="使用模板模式绘制"></a>使用模板模式绘制</h3><p>在完成前面的步骤之后，我们就可以调用Quartz 2D函数来绘制了。我们的模式被当作“涂料”。例如，可以调用CGContextStrokePath, CGContextFillPath, CGContextFillRect或其它函数来绘制。</p>
<h3 id="完整示例-1"><a href="#完整示例-1" class="headerlink" title="完整示例"></a>完整示例</h3><p>代码清单6-8包含一个绘制模板模式的函数。这个函数包含了前面讨论的所有步骤。</p>
<p><strong>Listing 6-8  A function that paints a stencil pattern</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PSIZE 16</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyStencilPatternPainting</span> <span class="params">(CGContextRef myContext,</span></span></div><div class="line">                                <span class="keyword">const</span> Rect *windowRect)</div><div class="line">&#123;</div><div class="line">    CGPatternRef pattern;</div><div class="line">    CGColorSpaceRef baseSpace;</div><div class="line">    CGColorSpaceRef patternSpace;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> CGFloat color[<span class="number">4</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span> &#125;;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> CGPatternCallbacks callbacks = &#123;<span class="number">0</span>, &amp;drawStar, <span class="literal">NULL</span>&#125;;</div><div class="line"> </div><div class="line">    baseSpace = CGColorSpaceCreateDeviceRGB ();</div><div class="line">    patternSpace = CGColorSpaceCreatePattern (baseSpace);</div><div class="line">    CGContextSetFillColorSpace (myContext, patternSpace);</div><div class="line">    CGColorSpaceRelease (patternSpace);</div><div class="line">    CGColorSpaceRelease (baseSpace);</div><div class="line">    pattern = CGPatternCreate(<span class="literal">NULL</span>, CGRectMake(<span class="number">0</span>, <span class="number">0</span>, PSIZE, PSIZE),</div><div class="line">                  CGAffineTransformIdentity, PSIZE, PSIZE,</div><div class="line">                  kCGPatternTilingConstantSpacing,</div><div class="line">                  <span class="literal">false</span>, &amp;callbacks);</div><div class="line">    CGContextSetFillPattern (myContext, pattern, color);</div><div class="line">    CGPatternRelease (pattern);</div><div class="line">    CGContextFillRect (myContext,CGRectMake (<span class="number">0</span>,<span class="number">0</span>,PSIZE*<span class="number">20</span>,PSIZE*<span class="number">20</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="南峰子" />
          <p class="site-author-name" itemprop="name">南峰子</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">84</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">南峰子</span>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1000523916'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1000523916%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
  </script>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  
  

  <div style="display: none;">
    <script src="http://s95.cnzz.com/z_stat.php?id=1000523916&web_id=1000523916" language="JavaScript"></script>
  </div>




</body>
</html>

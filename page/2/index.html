<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="南峰子的技术博客">
<meta property="og:url" content="http://southpeak.github.io/page/2/index.html">
<meta property="og:site_name" content="南峰子的技术博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="南峰子的技术博客">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://southpeak.github.io/page/2/"/>

  <title> 南峰子的技术博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-68856508-1', 'auto');
  ga('send', 'pageview');
</script>







  <div style="display: none;">
    <script src="http://s95.cnzz.com/z_stat.php?id=1000523916&web_id=1000523916" language="JavaScript"></script>
  </div>





  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">南峰子的技术博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">攀登，一步一个脚印，方能知其乐</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-techset">
          <a href="/categories/techset" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-fighter-jet"></i> <br />
            
            知识小集
          </a>
        </li>
      
        
        <li class="menu-item menu-item-swift">
          <a href="/categories/swift" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-space-shuttle"></i> <br />
            
            Swift
          </a>
        </li>
      
        
        <li class="menu-item menu-item-objectivec">
          <a href="/categories/objectivec" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-taxi"></i> <br />
            
            Objective-C
          </a>
        </li>
      
        
        <li class="menu-item menu-item-cocoa">
          <a href="/categories/cocoa" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-subway"></i> <br />
            
            Cocoa
          </a>
        </li>
      
        
        <li class="menu-item menu-item-translate">
          <a href="/categories/translate" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-rocket"></i> <br />
            
            翻译
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sourcecode">
          <a href="/categories/sourcecode" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-train"></i> <br />
            
            源码分析
          </a>
        </li>
      
        
        <li class="menu-item menu-item-something">
          <a href="/categories/something" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-bicycle"></i> <br />
            
            杂项
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/09/23/sourcecode-mmtweenanimation/" itemprop="url">
                  MMTweenAnimation实现分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-09-23T20:18:24+08:00" content="2015-09-23">
              2015-09-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/sourcecode/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先来个效果图吧：</p>
<p><img src="https://raw.githubusercontent.com/adad184/MMTweenAnimation/master/Images/2.gif" alt="image"></p>
<p>这是<code>MMTweenAnimation</code>库实现的一个弹跳动画。<code>MMTweenAnimation</code>基于Facebook的<code>pop</code>动画库，它提供了10套自定义的动画曲线，分别是：<code>Back</code>、<code>Bounce</code>、<code>Circ</code>、<code>Cubic</code>、<code>Elastic</code>、<code>Expo</code>、<code>Quad</code>、<code>Quart</code>、<code>Quint</code>、<code>Sine</code>。具体的效果可以参考<a href="https://github.com/adad184/MMTweenAnimation" target="_blank" rel="external">MMTweenAnimation</a>。</p>
<p>在这里，我们主要来<code>MMTweenAnimation</code>的具体实现及使用。</p>
<p>我们知道，动画实际上是许多帧静止的画面，以一定的速度连续播放，由于肉眼视觉残象产生的错觉，因此我们感觉画面是活动的。这就是动画的基本原理。所以，我们要做的就是按一定的速率去播放帧，在每一帧中计算曲线的路径，并将其绘制到界面上。这主要涉及到曲线的插值算法。</p>
<h3 id="主要部件"><a href="#主要部件" class="headerlink" title="主要部件"></a>主要部件</h3><p><code>MMTweenAnimation</code>的主体类主要有两个：<code>MMTweenAnimation</code>和<code>MMTweenFunction</code>。<code>MMTweenFunction</code>类主要定义各种插值算法，<code>MMTweenAnimation</code>主要是实现动画操作。</p>
<h4 id="MMTweenFunction类"><a href="#MMTweenFunction类" class="headerlink" title="MMTweenFunction类"></a>MMTweenFunction类</h4><p><code>MMTweenFunction</code>类主要是实现各种插值算法。这些插值算法分别10类，即上面列出的10套动画。而每套根据不同的缓动方式，又分为<code>EaseIn</code>、<code>EaseOut</code>、<code>EaseInOut</code>三种，因此<code>MMTweenAnimation</code>库实际上是实现了30种动画。每个插值算法都实现为一个闭包函数，其定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typealias MMTweenFunctionBlock = (t: <span class="built_in">CFTimeInterval</span>,            <span class="comment">// 当前时间与起始时间的差值</span></div><div class="line">                                  b: Double,                    <span class="comment">// 起点</span></div><div class="line">                                  c: Double,                    <span class="comment">// 起点与终点的差值</span></div><div class="line">                                  d: <span class="built_in">CFTimeInterval</span>) -&gt; Double  <span class="comment">// 动画持续时间</span></div></pre></td></tr></table></figure>
<p>而每个动画的插值都是根据数学公式算法出来的，我们以图例中的<code>Bounce-EaseOut</code>动画为例，其实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">let bounceOut: MMTweenFunctionBlock = &#123; (t, b, c, d) -&gt; Double <span class="keyword">in</span></div><div class="line">    let k: Double = <span class="number">2.75</span></div><div class="line">    var t1 = t / d</div><div class="line">    <span class="keyword">if</span> t1 &lt; (<span class="number">1</span> / k) &#123;</div><div class="line">        <span class="keyword">return</span> c * (<span class="number">7.5625</span> * t1 * t1) + b</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> t1 &lt; (<span class="number">2</span> / k) &#123;</div><div class="line">        t1 -= <span class="number">1.5</span> / k</div><div class="line">        <span class="keyword">return</span> c * (<span class="number">7.5625</span> * t1 * t1 + <span class="number">0.75</span>) + b</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> t1 &lt; (<span class="number">2.5</span> / k) &#123;</div><div class="line">        t1 -= <span class="number">2.25</span> / k</div><div class="line">        <span class="keyword">return</span> c * (<span class="number">7.5625</span> * t1 * t1 + <span class="number">0.9375</span>) + b</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        t1 -= <span class="number">2.625</span> / k</div><div class="line">        <span class="keyword">return</span> c * (<span class="number">7.5625</span> * t1 * t1 + <span class="number">0.984375</span>) + b</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>计算出来的插值将会用于计算当前帧的终点值。</p>
<h4 id="MMTweenAnimation类"><a href="#MMTweenAnimation类" class="headerlink" title="MMTweenAnimation类"></a>MMTweenAnimation类</h4><p><code>MMTweenAnimation</code>是实现动画的主体类。这个类继承自<code>pop</code>的<code>POPCustomAnimation</code>，<code>POPCustomAnimation</code> 直接继承自<code>PopAnimation</code>类，用于创建自定义动画的基类，它基本上是一个 <code>display link</code>的方便的转换，来在动画的每一个<code>tick</code>的回调<code>block</code>中驱动自定义的动画。</p>
<p><code>MMTweenAnimation</code>定义了几个基本属性，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> MMTweenAnimation: POPCustomAnimation &#123;</div><div class="line">    var animationBlock: MMTweenAnimationBlock?          <span class="comment">// 动画回调</span></div><div class="line">    var fromValue: [<span class="built_in">CGFloat</span>]?                           <span class="comment">// 起点数组</span></div><div class="line">    var toValue: [<span class="built_in">CGFloat</span>]?                             <span class="comment">// 终点数组</span></div><div class="line">    var duration: Double = <span class="number">0.3</span>                          <span class="comment">// 动画时长</span></div><div class="line"></div><div class="line">    <span class="comment">// ......</span></div><div class="line">    var functionBlock: MMTweenFunctionBlock?			<span class="comment">// 动画插值Block</span></div><div class="line">    <span class="comment">// ......</span></div><div class="line"></div><div class="line">    <span class="comment">// ......</span></div><div class="line">    var functionType: MMTweenFunctionType				<span class="comment">// 动画插值类型</span></div><div class="line">    <span class="comment">// ......</span></div><div class="line"></div><div class="line">    <span class="comment">// ......</span></div><div class="line">    var easingType: MMTweenEasingType					<span class="comment">// 动画缓动类型</span></div><div class="line">    <span class="comment">// ......</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而<code>MMTweenAnimation</code>类最关键的是定义它的回调<code>block</code>。<code>MMTweenAnimation</code>类定义了一个类方法<code>animation()</code>，在这个方法中，通过调用从父类继承来的便捷初始化方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public convenience init!(block: POPCustomAnimationBlock!)</div></pre></td></tr></table></figure>
<p>来创建一个<code>MMTweenAnimation</code>对象。其实现如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> func animation() -&gt; MMTweenAnimation? &#123;</div><div class="line"></div><div class="line">        let tweaner: MMTweenAnimation = MMTweenAnimation &#123; (target, animation) -&gt; Bool <span class="keyword">in</span></div><div class="line"></div><div class="line">            let anim: MMTweenAnimation = animation as! MMTweenAnimation</div><div class="line"></div><div class="line">            let t = animation.currentTime - animation.beginTime <span class="comment">// 当前时间与起始时间的差值</span></div><div class="line">            let d = anim.duration</div><div class="line"></div><div class="line">            assert(anim.fromValue!.count == anim.toValue!.count, <span class="string">"fromValue.count != toValue.count"</span>)</div><div class="line"></div><div class="line">            <span class="keyword">if</span> t &lt; d &#123;      <span class="comment">// 确保在动画持续时间类才处理</span></div><div class="line">                var values: [<span class="built_in">CGFloat</span>] = [<span class="built_in">CGFloat</span>]()</div><div class="line"></div><div class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0.</span>.&lt;anim.fromValue!.count &#123;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> let functionBlock = anim.functionBlock &#123;     <span class="comment">// 计算插值</span></div><div class="line">                        values.append(<span class="built_in">CGFloat</span>(functionBlock(t: t, b: Double(anim.fromValue![i]), c: Double(anim.toValue![i]) - Double(anim.fromValue![i]), d: d)))</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> let animationBlock = anim.animationBlock &#123;   <span class="comment">// 动画回调，以实现绘制操作</span></div><div class="line">                    animationBlock(time: t, duration: d, values: values, target: target, animation: anim)</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> tweaner</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>其中动画回调的定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typealias MMTweenAnimationBlock = (time: <span class="built_in">CFTimeInterval</span>, duration: <span class="built_in">CFTimeInterval</span>, values: [<span class="built_in">CGFloat</span>], target: AnyObject, animation: MMTweenAnimation) -&gt; Void</div></pre></td></tr></table></figure>
<p>以上两个类便是<code>MMTweenAnimation</code>的主要部件。</p>
<h3 id="动画示例"><a href="#动画示例" class="headerlink" title="动画示例"></a>动画示例</h3><p>有了主要部件，我们就来看看怎么去使用它。<code>MMTweenAnimation</code>给了一个示例，其效果就是开头的图例。为此，<code>MMTweenAnimation</code>定义了类<code>MMPaintView</code>，这个类的主要目的就是绘制上面的曲线，其主要操作如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">func addDot(point: <span class="built_in">CGPoint</span>) &#123;</div><div class="line">    __dots.append(point)</div><div class="line">    <span class="comment">// __path = __interpolateCGPointsWithHermite(__dots)</span></div><div class="line">    __path = __interpolateCGPointsWithCatmullRom(__dots)</div><div class="line">    setNeedsDisplay()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法首先是将参数中的点(即每一帧计算出来的终点值)添加到对象的<code>__dots</code>数组中，然后再通过<code>__interpolateCGPointsWithCatmullRom</code>方法创建一条<code>Bezier</code>曲线，最后调用<code>setNeedsDisplay()</code>来重新绘制曲线。</p>
<p>我们先来看看这个点是如何获取到的。在<code>MMAnimationController</code>类，我们定义动画对象时，设置了其动画回调，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">__anim!.animationBlock = &#123; [unowned <span class="keyword">self</span>] (diff: <span class="built_in">CFTimeInterval</span>, duration: <span class="built_in">CFTimeInterval</span>, values: [<span class="built_in">CGFloat</span>], target: AnyObject, animation: MMTweenAnimation) -&gt; Void <span class="keyword">in</span></div><div class="line">    let value: <span class="built_in">CGFloat</span> = values[<span class="number">0</span>]          <span class="comment">// 获取当前时间结束点的值</span></div><div class="line"></div><div class="line">    <span class="keyword">self</span>.__dummy!.center = <span class="built_in">CGPoint</span>(x: <span class="keyword">self</span>.__dummy!.center.x, y: value)     <span class="comment">// 计算小红点的中心位置</span></div><div class="line">    <span class="keyword">self</span>.__ball!.center = <span class="built_in">CGPoint</span>(x: <span class="number">50.0</span> + (<span class="built_in">CGRectGetWidth</span>(<span class="built_in">UIScreen</span>.mainScreen().bounds) - <span class="number">150.0</span>) * <span class="built_in">CGFloat</span>(diff / duration), y: value)</div><div class="line"></div><div class="line">    <span class="keyword">self</span>.__paintView!.addDot(<span class="keyword">self</span>.__ball!.center)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个动画回调获取当前时间结束点的值，用于设置小红点的中心位置，同时将这个中心位置的值丢给<code>MMPaintView</code>对象去生成<code>Bezier</code>曲线。</p>
<h3 id="动画渲染操作执行的时间点"><a href="#动画渲染操作执行的时间点" class="headerlink" title="动画渲染操作执行的时间点"></a>动画渲染操作执行的时间点</h3><p>知道了<code>MMTweenAnimation</code>库的主要部件，我们现在来看看动画是如何被驱动的。我们在<code>MMTweenAnimation</code>类的<code>animation()</code>方法中，在动画回调的起始位置打个断点，运行一下程序，看看调用栈，如下所示：</p>
<p><img src="https://raw.githubusercontent.com/southpeak/Blog-images/master/MMTweenAnimation-stack.png" alt="image"></p>
<p>可以看到在<code>Run Loop</code>中执行了一个观察者回调，在这个回调中调用了<code>POPAnimator</code>对象的<code>_scheduleProcessPendingList</code>方法的一个<code>block</code>回调，一直追溯到我们的动画操作。也就是说，是在<code>Run Loop</code>的某个时刻执行了一次动画的渲染。</p>
<p>我们再从代码入手，来看看动画执行代码是什么时候添加到Run Loop中的。在<code>MMAnimationController</code>的<code>viewDidAppear</code>方法中，有如下调用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__dummy!.pop_addAnimation(__anim, forKey: <span class="string">"center"</span>)</div></pre></td></tr></table></figure>
<p>其中<code>pop_addAnimation</code>方法是<code>POPAnimator</code>类中定义的。顺着代码，我们最终可以找到<code>_scheduleProcessPendingList</code>的定义，其实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)_scheduleProcessPendingList</div><div class="line">&#123;</div><div class="line">  <span class="comment">// ......</span></div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!_pendingListObserver) &#123;</div><div class="line">    __<span class="keyword">weak</span> POPAnimator *weakSelf = <span class="keyword">self</span>;</div><div class="line">	</div><div class="line">    <span class="comment">// 添加Run Loop监听器</span></div><div class="line">    _pendingListObserver = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(kCFAllocatorDefault, kCFRunLoopBeforeWaiting | kCFRunLoopExit, <span class="literal">false</span>, POPAnimationApplyRunLoopOrder, ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</div><div class="line">      [weakSelf _processPendingList];</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (_pendingListObserver) &#123;</div><div class="line">      <span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetMain</span>(), _pendingListObserver,  kCFRunLoopCommonModes);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// ......</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到在这个方法中创建了一个<code>Run Loop</code>的观察者，这个观察者在<code>Run Loop</code>的<code>kCFRunLoopBeforeWaiting</code>或<code>kCFRunLoopExit</code>阶段时会执行监听回调处理函数。回调函数中调用了<code>_processPendingList</code>方法，然后从调用栈里面可以看到，一直会执行到<code>MMTweenAnimation</code>的动画闭包中，即我们打断点的地方。</p>
<p>OK，动画渲染时间点找着了，那整个流程就可以完整拼接起来了。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><code>MMTweenAnimation</code>的实现并不复杂，只要了解了动画的基本原理和其中的插值算法，再加上一些<code>pop</code>动画的基础知识，基本上就OK了。要想做出很牛B的动画，还是需要大量的数学知识。其实在<code>MMTweenAnimation</code>库中，除了那10套插值算法外，在<code>MMPaintView</code>类中，计算<code>Bezier</code>的控制点时，还用到了Catmull-Rom样条与Hermite样条，大家有兴趣可以研究一下。</p>
<p><code>MMTweenAnimation</code>初始源码是<code>Objective-C</code>实现的，我将它用<code>Swift</code>重写了一遍，并放在github上，地址是<a href="https://github.com/southpeak/Swift/tree/master/Animation/MMTweenAnimation-Swift" target="_blank" rel="external">MMTweenAnimation-Swift</a>，有兴趣可以看一下。</p>
<p>本想放在知识小集中，但由于篇幅稍长，所以独立成篇。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://github.com/adad184/MMTweenAnimation" target="_blank" rel="external">MMTweenAnimation</a></li>
<li><a href="http://objccn.io/issue-12-6/" target="_blank" rel="external">交互式动画</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/09/14/app-transport-security-ats/" itemprop="url">
                  App Transport Security(ATS)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-09-14T19:47:32+08:00" content="2015-09-14">
              2015-09-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/something/" itemprop="url" rel="index">
                    <span itemprop="name">杂项</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近下载<code>iOS 9 GM</code>版，然后跑了下我们的应用，发现有些网络请求失效了。先前在<code>WWDC 2015</code>上了解到<code>iOS 9</code>将要求网络请求使用<code>HTTPS</code>协议，但一直没有在<code>iOS 9 beta</code>版上跑过。现在这个问题突显出来了，所以搜了一些博文研究了一下。</p>
<p>我们知道，<code>Apple</code>在安全及用户隐私方面做了很多工作，包括沙盒机制、代码签名、禁用私有API等。而在今年6月份的<code>WWDC 2015</code>上，<code>Apple</code>又提出了<code>App Transport Security(ATS)</code>的概念。这一特性的主要意图是为我们的<code>App</code>与服务器之间提供一种安全的通信方式，以防止中间人窃听、篡改传输的数据。这一特性在<code>iOS 9+</code>和<code>OS X 10.11+</code>中是默认的支持项。这一概念的提出，也将意味着<code>Apple</code>将会慢慢转向支持<code>HTTPS</code>，而可能放弃<code>HTTP</code>。</p>
<h2 id="App-Transport-Security技术要求"><a href="#App-Transport-Security技术要求" class="headerlink" title="App Transport Security技术要求"></a>App Transport Security技术要求</h2><p>我们先来看看<code>ATS</code>的技术要求（参考<a href="https://developer.apple.com/library/prerelease/ios/technotes/App-Transport-Security-Technote/" target="_blank" rel="external">App Transport Security Technote</a>）：</p>
<ul>
<li>The server must support at least Transport Layer Security (TLS) protocol version 1.2.</li>
<li>Connection ciphers are limited to those that provide forward secrecy (see the list of ciphers below.)</li>
<li>Certificates must be signed using a SHA256 or better signature hash algorithm, with either a 2048 bit or greater RSA key or a 256 bit or greater Elliptic-Curve (ECC) key.</li>
</ul>
<p>可以看到服务端必须支持<code>TLS 1.2</code>或以上版本；必须使用支持前向保密的密码；证书必须使用<code>SHA-256</code>或者更好的签名<code>hash</code>算法来签名，如果证书无效，则会导致连接失败。</p>
<p><code>Apple</code>认为这是目前保证通信安全性的最佳实践，特别是使用<code>TLS 1.2</code>和前向保密。当然，相信<code>Apple</code>也会与时俱进，不断的修正<code>ATS</code>，以保证网络通信的安全性。</p>
<h2 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h2><p>在<code>iOS 9+</code>和<code>OS X 10.11+</code>中，如果我们的<code>App</code>使用了<code>NSURLConnection</code>、<code>CFURL</code> 或者<code>NSURLSession</code>相关的<code>API</code>来进行数据通信的话，则默认是通过<code>ATS</code>的方式来传输数据。在此配置下，如果我们使用<code>HTTP</code>来进行通信，则会导致请求失败，并报以下错误：</p>
<blockquote>
<p>The resource could not be loaded because the App Transport Security policy requires the use of a secure connection.</p>
</blockquote>
<p>这样意味着如果使用<code>ATS</code>，将无法支持<code>HTTP</code>协议（我们测试了一下，由于我们的登录服务是使用<code>HTTP</code>协议，目前在<code>iOS 9</code>下已无法正常登录）。相信目前还有大量的应用是通过HTTP协议来访问服务器的。而要让所有的应用都转向支持<code>HTTPS</code>，显然是一件费时费力的事（与今年年头所有应用必须支持64位<code>ARM</code>不同，那次只是在客户端层面，而<code>ATS</code>涉及到服务端，影响面更大）。所以苹果提供了一种兼容方案，下面我们就来看看如何处理。</p>
<h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><p>考虑到现实因素，我们可能并不想使用默认配置，或者至少需要一个过渡时期。为此，<code>Apple</code>允许我们在<code>Info.plist</code>文件中来自行配置以修改默认设置(<code>Exceptions</code>)，下表是一些键值及对应的类型和说明：</p>
<table>
<thead>
<tr>
<th>键</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NSAppTransportSecurity</td>
<td>Dictionary</td>
<td>配置ATS的顶层键值</td>
</tr>
<tr>
<td>NSAllowsArbitraryLoads</td>
<td>Boolean</td>
<td>这是一个开关键，设置不在NSExceptionDomains列表中的其它域ATS特性。默认值是NO，如果设置为YES，则会关闭其它域的ATS特性。</td>
</tr>
<tr>
<td>NSExceptionDomains</td>
<td>Dictionary</td>
<td>特定域列表</td>
</tr>
<tr>
<td><domain-name-for-exception-as-string></domain-name-for-exception-as-string></td>
<td>Dictionary</td>
<td>需要自定义配置的域名，键是对应的域名，如www.apple.com</td>
</tr>
<tr>
<td>NSExceptionMinimumTLSVersion</td>
<td>String</td>
<td>指定域所需要的TLS的最低版本。有效值包括：TLSv1.0、TLSv1.1、TLSv1.2。默认值是TLSv1.2</td>
</tr>
<tr>
<td>NSExceptionRequiresForwardSecrecy</td>
<td>Boolean</td>
<td>指定域是否需要支持前向保密。默认值是YES</td>
</tr>
<tr>
<td>NSExceptionAllowsInsecureHTTPLoads</td>
<td>Boolean</td>
<td>指定域的请求是否允许使用不安全的HTTP。使用这个键来访问没有证书，或者证书是自签名、过期或主机名不匹配的证书。默认值为NO，表示需要使用HTTPS。</td>
</tr>
<tr>
<td>NSIncludesSubdomains</td>
<td>Boolean</td>
<td>指定自定义的值是否应用到域的所有子域中。默认值是NO</td>
</tr>
<tr>
<td>NSThirdPartyExceptionMinimumTLSVersion</td>
<td>String</td>
<td>类似于NSExceptionMinimumTLSVersion键，只不过指定的是应用本身无法控制的第三方组件的域所需要的TLS的最低版本。</td>
</tr>
<tr>
<td>NSThirdPartyExceptionRequiresForwardSecrecy</td>
<td>Boolean</td>
<td>同上。指定第三方组件的域是否需要支持前向保密</td>
</tr>
<tr>
<td>NSThirdPartyExceptionAllowsInsecureHTTPLoads</td>
<td>Boolean</td>
<td>同上。指定第三方组件的域的请求是否使用HTTPS</td>
</tr>
</tbody>
</table>
<p>通过设置上面的这些值，就可以精确的配置应用中访问的不同域的<code>ATS</code>特性。如下是<a href="http://www.neglectedpotential.com/2015/06/working-with-apples-application-transport-security/" target="_blank" rel="external">WORKING WITH APPLE’S APP TRANSPORT SECURITY</a>中给出的一个配置示例：</p>
<p><img src="http://neglectedpotential.com/wp-content/uploads/ATSInfoplist.png" alt="image"></p>
<p>另外，在这篇文章中，也为我们例举了几种常见的配置，我们一起来看一下：</p>
<h3 id="Example-A：所有请求均使用ATS"><a href="#Example-A：所有请求均使用ATS" class="headerlink" title="Example A：所有请求均使用ATS"></a>Example A：所有请求均使用ATS</h3><p>这当然是默认配置，只需要我们使用<code>NSURLSession</code>, <code>NSURLConnection</code>或者<code>CFURL</code>来做网络请求。当然只有<code>iOS 9.0+</code>以及<code>OS X 10.11+</code>才支持这一特性。</p>
<h3 id="Example-B：配置部分域不使用ATS"><a href="#Example-B：配置部分域不使用ATS" class="headerlink" title="Example B：配置部分域不使用ATS"></a>Example B：配置部分域不使用ATS</h3><p>如果我们希望部分域的请求不使用<code>ATS</code>，则我们可以将这些域放在<code>NSExceptionDomains</code>列表中来进行配置，以修改这些域的<code>ATS</code>默认配置。如果我们希望指定域及其所有子域都禁用<code>ATS</code>，则设置<code>NSExceptionAllowsInsecureHTTPLoads</code>为YES并将<code>NSIncludesSubdomains</code>设置为YES，如下配置：</p>
<p><img src="http://www.neglectedpotential.com/wp-content/uploads/ExampleB.png" alt="image"></p>
<p>那当然，如果我们不想在指定域完全禁用<code>ATS</code>，则可以设置 <code>NSExceptionRequiresForwardSecrecy</code> 和<code>NSExceptionMinimumTLSVersion</code> 来指定更多的规则。</p>
<h3 id="Example-C：禁用ATS，但部分域使用ATS"><a href="#Example-C：禁用ATS，但部分域使用ATS" class="headerlink" title="Example C：禁用ATS，但部分域使用ATS"></a>Example C：禁用ATS，但部分域使用ATS</h3><p>如果我们想要在应用中禁用<code>ATS</code>特性，则可以设置<code>NSAllowsArbitraryLoads</code>的值为YES，这样所有的请求将不会使用<code>ATS</code>。而如果我们希望部分域使用<code>ATS</code>，则如同<code>Example B</code>中那样来设置指定域的 <code>NSExceptionAllowsInsecureHTTPLoads</code> 的值为NO，这样就要求指定域必须使用ATS来进行数据传输。如下配置：</p>
<p><img src="http://www.neglectedpotential.com/wp-content/uploads/ExampleC.png" alt="image"></p>
<h3 id="Example-D：降级ATS"><a href="#Example-D：降级ATS" class="headerlink" title="Example D：降级ATS"></a>Example D：降级ATS</h3><p>在一些情况下，我们可能需要使用<code>ATS</code>，但可能现实情况并不完全能够支持<code>ATS</code>的最佳实践。比如我们的服务端支持<code>TLS 1.2</code>，但却不支持前向保密。这种情况下，我们可以让指定域支持<code>ATS</code>，但同时禁用前向保密，这种情况下就可以设置<code>NSExceptionRequiresForwardSecrecy</code>为NO。同样，如果我们希望使用前向保密，但可以<code>TLS</code>的版本只是1.1，则我们可以设置 <code>NSExceptionMinimumTLSVersion</code> 的值为<code>TSLv1.1</code>，如下配置：</p>
<p><img src="http://www.neglectedpotential.com/wp-content/uploads/ExampleD.png" alt="image"></p>
<h3 id="Example-E：完全禁用ATS的更友好的方式"><a href="#Example-E：完全禁用ATS的更友好的方式" class="headerlink" title="Example E：完全禁用ATS的更友好的方式"></a>Example E：完全禁用ATS的更友好的方式</h3><p>如果想完全禁用<code>ATS</code>，我们可以在<code>Info.plist</code>中简单的设置<code>NSAllowsArbitraryLoads</code>为YES，如下配置：</p>
<p><img src="http://www.neglectedpotential.com/wp-content/uploads/ExampleE.png" alt="image"></p>
<p>以上几种情况基本上囊括了自定义<code>ATS</code>特性的所有情况。大家可以根据需要来自定义配置。</p>
<h2 id="Certificate-Transparency"><a href="#Certificate-Transparency" class="headerlink" title="Certificate Transparency"></a>Certificate Transparency</h2><p>对于<code>ATS</code>，大部分安全特性都是默认可用的，不过<code>Certificate Transparency</code>是必须配置的。<code>Certificate Transparency</code>的概念在<code>wiki</code>中的解释是：</p>
<blockquote>
<p>Certificate Transparency (CT) is an experimental IETF open standard and open source framework for monitoring and auditing digital certificates. Through a system of certificate logs, monitors, and auditors, certificate transparency allows website users and domain owners to identify mistakenly or maliciously issued certificates and to identify certificate authorities (CAs) that have gone rogue.</p>
</blockquote>
<p>它主要是让web站点的用户和域所有者可以识别出错误的或恶意的证书，以及识别出无效的证书颁发机构。</p>
<p>如果我们的证书支持<code>certificate transparency</code>，那么我们可以设置<code>NSRequiresCertificateTransparency</code>键来启用这一功能。而不如证书不支持<code>certificate transparency</code>，则该功能默认总是关闭的。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>Apple</code>提出<code>App Transport Security</code>这一特性，是为了保证用户数据的安全传输。安全因素始终是网络开发中一个重要的因素，相信会有越来越多的站点会转向<code>HTTPS</code>。而<code>Apple</code>作为业内技术的一个风向标，也会带动这一趋势的发展。所以，还不支持<code>HTTPS</code>的筒子们可以行为起来了。</p>
<p>这篇文章更多的是对App开发文档<a href="https://developer.apple.com/library/prerelease/ios/technotes/App-Transport-Security-Technote/" target="_blank" rel="external">App Transport Security Technote</a>和<a href="http://www.neglectedpotential.com/2015/06/working-with-apples-application-transport-security/" target="_blank" rel="external">WORKING WITH APPLE’S APP TRANSPORT SECURITY</a>两篇文章的整理。<a href="http://weibo.com/luohanchenyilong/" target="_blank" rel="external">iOS程序犭袁</a>在他的<a href="https://github.com/ChenYilong/iOS9AdaptationTips" target="_blank" rel="external">iOS9AdaptationTips</a>一文中有更多有意思的内容，大家可以参考。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://developer.apple.com/library/prerelease/ios/technotes/App-Transport-Security-Technote/" target="_blank" rel="external">App Transport Security Technote</a></li>
<li><a href="http://www.neglectedpotential.com/2015/06/working-with-apples-application-transport-security/" target="_blank" rel="external">WORKING WITH APPLE’S APP TRANSPORT SECURITY</a></li>
<li><a href="https://developer.apple.com/videos/wwdc/2015/?id=711" target="_blank" rel="external">WWDC 2015视频：Networking with NSURLSession</a></li>
<li><a href="http://willowtreeapps.com/blog/app-transport-security/" target="_blank" rel="external">App Transport Security</a></li>
<li><a href="https://github.com/ChenYilong/iOS9AdaptationTips" target="_blank" rel="external">iOS9AdaptationTips</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/08/31/translate-10-things-you-need-to-know-about-cocoa-auto-layout/" itemprop="url">
                  10 Things You Need to Know About Cocoa Auto Layout
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-08-31T22:49:30+08:00" content="2015-08-31">
              2015-08-31
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文由<a href="http://oleb.net/" target="_blank" rel="external">Ole Begemann</a>在<code>2013.3.31</code>发表于其个人博客，地址是<a href="http://oleb.net/blog/2013/03/things-you-need-to-know-about-cocoa-autolayout/" target="_blank" rel="external">10 Things You Need to Know About Cocoa Auto Layout</a></p>
<blockquote>
<p>译注：原文发表的时间有点早，主要是针对<code>Xcode 4.x</code>时代的<code>Auto Layout</code>，特别是第二部分”<code>Interface Builder</code>中的<code>Auto Layout</code>“，所以有些内容已经过时了。不过还是有很多可借鉴的地方。特别感谢<a href="http://weibo.com/u/1438670852" target="_blank" rel="external">@叶孤城</a> 叶大在微博中的分享，以及对译文的校对。</p>
</blockquote>
<p>第一次使用<code>Cocoa Auto Layout</code>时，感觉它与<code>Cocoa</code>开发者所熟知的<code>springs-struts</code>模式有很大的不同。尽管<code>Auto Layout</code>有点复杂，但我发现只需要了解一些基本规则就可以使用它。本文就来列出这些规则。</p>
<h2 id="Auto-Layout通用概念"><a href="#Auto-Layout通用概念" class="headerlink" title="Auto Layout通用概念"></a>Auto Layout通用概念</h2><h3 id="1-经验法则：每个维度至少有两个约束"><a href="#1-经验法则：每个维度至少有两个约束" class="headerlink" title="1.经验法则：每个维度至少有两个约束"></a>1.经验法则：每个维度至少有两个约束</h3><p>在每个维度(水平与竖直)上，一个视图的位置和大小由三个值来定义：头部空间(<code>leading space</code>)，大小和尾部空间(<code>trailing space</code>)<em>[注释1]</em>。一个视图的<code>leading</code>和<code>trailing</code>空间可以相对于父视图来定义，也可以相对于视图层级架构中的兄弟视图来定义。一般来说，我们的布局约束必须满足这两个值，以便计算第三个值(<code>size</code>)。其结果是，一个标准的视图在每个维度上必须至少有两个约束，以明确视图的布局。</p>
<h3 id="2-拥抱固有大小-Intrinsic-Size"><a href="#2-拥抱固有大小-Intrinsic-Size" class="headerlink" title="2.拥抱固有大小(Intrinsic Size)"></a>2.拥抱固有大小(Intrinsic Size)</h3><p>一些控件，如标签和按钮，都有一个所谓的固有大小(<code>Intrinsic Size</code>)。视控件的不同，固有大小可以在水平或竖直或同时两个方向上有效。当一个控件没有明确的宽度和高度约束时，就会使用它的固有大小作为约束。这允许我们在每个方向上只使用一个显式约束就可以创建明确的布局(相对于上面第1条规则)，并让控件可以根据自身的内容来自动调整大小。这是在本地化中创建一个最佳布局的关键。</p>
<h2 id="Interface-Builder中的Auto-Layout"><a href="#Interface-Builder中的Auto-Layout" class="headerlink" title="Interface Builder中的Auto Layout"></a>Interface Builder中的Auto Layout</h2><blockquote>
<p>更新于2014.3.3：当我写这篇文章时，<code>Xcode</code>的版本是4.x。到了<code>Xcode 5</code>时，<code>Interface Builder</code>对<code>Auto Layout</code>的处理已以有了显著的改变，所以下面的一些内容已经不再有效(特别是第3、4条)。<code>Xcode</code>现在允许<code>Interface Builder</code>在创建模棱两可的布局，并在编译时添加<code>missing constraints</code>来明确一个布局。这使得在开发过程中，原型的设计和快速变更来得更加简单。第5、6条在<code>Xcode 5</code>中仍然是有效的。</p>
</blockquote>
<p><code>Interface Builder</code>中的<code>Auto Layout</code>编辑器似乎有自己的想法。理解<code>Xcode</code>的工程师为什么这样设计，可以让我们使用它是不至于太过沮丧。</p>
<p><img src="http://oleb.net/media/interface-builder-constraints-editor-context-menu.png" alt="image"></p>
<p>图1：如果某个约束会导致模棱两可的布局，<code>IB</code>是不允许我们删除它的</p>
<h3 id="3-IB总是不让你创建一个模棱两可的布局"><a href="#3-IB总是不让你创建一个模棱两可的布局" class="headerlink" title="3.IB总是不让你创建一个模棱两可的布局"></a>3.IB总是不让你创建一个模棱两可的布局</h3><p><code>IB</code>的主要目标是保护我们自己。它决不会让我们创建一个模棱两可的布局。这意味着<code>IB</code>在我们将一个视图放到一个布局中时，会自动为我们创建约束。沿着IB的自动引导来放置我们的视图，以帮助<code>IB</code>正确的猜测我们想把视图放哪。</p>
<h3 id="4-在我们删除一个已存在的约束之前，必须创建另外一个约束"><a href="#4-在我们删除一个已存在的约束之前，必须创建另外一个约束" class="headerlink" title="4.在我们删除一个已存在的约束之前，必须创建另外一个约束"></a>4.在我们删除一个已存在的约束之前，必须创建另外一个约束</h3><p>使用<code>Size Inspector</code>来查看一个指定视图的所有约束。当一个约束的<code>Delete</code>菜单项是置灰时，就表示删除这个约束会导致混乱，因此这是不允许的。在删除它之前，我们必须创建至少一个自定义约束来取代它。</p>
<p><img src="http://oleb.net/media/interface-builder-create-constraints-ui.png" alt="image"></p>
<p>图2：创建新的布局约束的<code>IB</code>界面</p>
<p>为了创建一个新的约束，在布局中选择一个或多个视图，然后使用画布右下角的三个不显眼按钮来创建约束。这都是很容易被忽视的。</p>
<h3 id="5-不要显式地调整控件的大小"><a href="#5-不要显式地调整控件的大小" class="headerlink" title="5.不要显式地调整控件的大小"></a>5.不要显式地调整控件的大小</h3><p>尝试不要显式地设置一个控件的大小。只要我们不手动去改变它们的大小，大部分控件都会根据它们的内容来调整自己的大小，并使用固有大小(<code>intrinsic size</code>)来创建一个完美的、内容敏感的布局。这对于需要做本地化的UI尤其重要。一旦我们(无意或有意地)手动调整了控件的大小，<code>IB</code>将创建一个很难摆脱的显式大小约束。为了回归到固有大小，可以使用<code>Editor</code> &gt; <code>Size to Fit Content</code>命令。</p>
<h3 id="6-避免过早优化"><a href="#6-避免过早优化" class="headerlink" title="6.避免过早优化"></a>6.避免过早优化</h3><p>不幸的是，使用<code>Interface Builder</code>来做自动布局将迫使我们更加小心。例如，如果我们发现需要使用一个控件来替换另一个，从布局中删除原始控件可能导致IB自动创建一组新的约束，当我们插入新的控件时，需要再次手动修改这些约束。因此，在我们的布局仍处于不稳定状态时去优化我们的约束，可能并不是一个好主意。更好的是在它更稳定时再去优化它。</p>
<h2 id="代码中的Auto-Layout"><a href="#代码中的Auto-Layout" class="headerlink" title="代码中的Auto Layout"></a>代码中的Auto Layout</h2><p>在<code>Interface Builder</code>中使用<code>Auto Layout</code>中可能很快就会有种挫折感，因此更多的开发者喜欢在代码中使用<code>Auto Layout</code>。</p>
<h3 id="7-忘记Frame吧"><a href="#7-忘记Frame吧" class="headerlink" title="7.忘记Frame吧"></a>7.忘记Frame吧</h3><p>忘记<code>frame</code>属性吧。不要直接设置它。一个视图的<code>frame</code>在自动布局过程中会被自动设置，而不是一个输入结果。我们可以通过改变约束来改变<code>frame</code>。这将强迫我们改变看待<code>UI</code>的方式。不用再去考虑位置和大小了，而是考虑每个视图相对于它的兄弟视图和父视图的位置。这与<code>CSS</code>没有什么不同。</p>
<h3 id="8-别忘了禁用Autoresizing-Masks"><a href="#8-别忘了禁用Autoresizing-Masks" class="headerlink" title="8.别忘了禁用Autoresizing Masks"></a>8.别忘了禁用Autoresizing Masks</h3><p>为了保证代码的向后兼容性，<code>sprints-struts</code>模式仍然是默认的。对于每一个代码创建的需要使用<code>Auto Layout</code>的视图，请调用<code>setTranslatesAutoresizingMaskIntoConstraints:NO</code>。</p>
<h3 id="9-多留意Debugger控制台"><a href="#9-多留意Debugger控制台" class="headerlink" title="9.多留意Debugger控制台"></a>9.多留意Debugger控制台</h3><p>当我们写约束时，应该多留意<code>Debugger</code>控制台。我发现<code>Apple</code>关于模棱两可的约束或未满足的约束的错误日志总是可以帮助我们快速定位问题。这个可以参考<a href="https://developer.apple.com/library/ios/documentation/userexperience/conceptual/AutolayoutPG/ResolvingIssues/ResolvingIssues.html#//apple_ref/doc/uid/TP40010853-CH17-SW14" target="_blank" rel="external">Apple’s debugging tips in the Cocoa Auto Layout Guide</a>。</p>
<h3 id="10-让约束动起来，而不是frame"><a href="#10-让约束动起来，而不是frame" class="headerlink" title="10.让约束动起来，而不是frame"></a>10.让约束动起来，而不是frame</h3><p>在<code>Auto Layout</code>中，我们需要重新考虑动画。我们不再可以简单的动画一个视图的<code>frame</code>了；如果我们这样做了，视图将在动画完成后自动恢复到<code>Auto Layout</code>计算出来的位置和大小上。相反，我们需要直接动画布局的约束。要做到这一点，或者修改已存在的约束（我们可以为<code>IB</code>中创建的约束声明<code>IBOutlet</code>变量），也可以添加一个新的约束，然后在一个动画<code>block</code>中给我们的视图发送<code>layoutIfNeeded</code>消息。</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ol>
<li>在垂直维度，<code>leading</code>和<code>trailing</code>空间分别表示为<code>top</code>和<code>bottom</code>空间。在水平维度，我们可以选择两个方向：“<code>Leading to Trailing</code>” 或者是 “<code>Left to Right</code>”。这两者的不同之处在于，如果本地语言是从右到左的，则”<code>Leading to Trailing</code>”表示的就是”<code>Right to Left</code>”。在大多数时候，我们需要的是“<code>Leading to Trailing</code>”。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/08/15/ios-techset-4/" itemprop="url">
                  iOS知识小集 第4期(2015.08.15)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-08-15T22:21:02+08:00" content="2015-08-15">
              2015-08-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/techset/" itemprop="url" rel="index">
                    <span itemprop="name">知识小集</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>又欠了一屁股债了。积累了一大堆的问题放在那，就是没有整理。不能怪别人，也能怪自己了，犯起懒来，啥事也不想做，连喜爱的户外运动也给拉下了，掐指一算，居然大半年没出去了。然后经常看到老驴子们出去玩耍，回来就是一通的美图，心里那个痒痒啊。</p>
<p>回到正题吧，这次的知识小集知识点不多，还是三个：</p>
<ol>
<li><code>ARC</code>与<code>MRC</code>的性能对比</li>
<li><code>Bitcode</code></li>
<li>在<code>Swift</code>中实现<code>NS_OPTIONS</code></li>
</ol>
<p>篇幅超过了预期，大家慢慢看，如有问题还请指正。</p>
<h2 id="ARC与MRC的性能对比"><a href="#ARC与MRC的性能对比" class="headerlink" title="ARC与MRC的性能对比"></a>ARC与MRC的性能对比</h2><p><code>MRC</code>似乎已经是一个上古时代的话题了，不过我还是绕有兴致的把它翻出来。因为，今天我被一个问题问住了：<code>ARC</code>与<code>MRC</code>的性能方面孰优劣。确实，之前没有对比过。</p>
<p>先来做个测试吧。首先我们需要一个计时辅助函数，我选择使用<code>mach_absolute_time</code>，计算时间差的函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">double subtractTimes(uint64_t endTime, uint64_t startTime) &#123;</div><div class="line"></div><div class="line">    uint64_t difference = endTime - startTime;</div><div class="line">    static double conversion = 0.0;</div><div class="line"></div><div class="line">    if(conversion == 0.0) &#123;</div><div class="line"></div><div class="line">        mach_timebase_info_data_t info;</div><div class="line">        kern_return_t err = mach_timebase_info(&amp;info);                       //Convert the timebaseinto seconds</div><div class="line"></div><div class="line">        if(err == 0)</div><div class="line">            conversion = 1e-9 * (double) info.numer / (double) info.denom;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return conversion * (double)difference;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后定义两个测试类，一个是<code>ARC</code>环境下的，一个是<code>MRC</code>环境下的，分别如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">// Test1.m</div><div class="line">+ (void)test &#123;</div><div class="line"></div><div class="line">    uint64_t start,stop;</div><div class="line"></div><div class="line">    start = mach_absolute_time();</div><div class="line"></div><div class="line">    for (int i = 0; i &lt; 1000000; i++) &#123;</div><div class="line">        NSArray *array = [[NSArray alloc] init];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    stop = mach_absolute_time();</div><div class="line"></div><div class="line">    double diff = subtractTimes(stop, start);</div><div class="line"></div><div class="line">    NSLog(@&quot;ARC total time in seconds = %f\n&quot;, diff);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Test2.m</div><div class="line">// 在target-&gt;Build Phases-&gt;Compile Sources中，添加编译标识-fno-objc-arc</div><div class="line">+ (void)test &#123;</div><div class="line"></div><div class="line">    uint64_t start,stop;</div><div class="line"></div><div class="line">    start = mach_absolute_time();</div><div class="line"></div><div class="line">    for (int i = 0; i &lt; 1000000; i++) &#123;</div><div class="line">        NSArray *array = [[NSArray alloc] init];</div><div class="line">        [array release];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    stop = mach_absolute_time();</div><div class="line"></div><div class="line">    double diff = subtractTimes(stop, start);</div><div class="line"></div><div class="line">    NSLog(@&quot;MRC total time in seconds = %f\n&quot;, diff);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>多运行几组测试，然后挑两组吧来看看，数据如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// A组</div><div class="line">ARC total time in seconds = 0.077761</div><div class="line">MRC total time in seconds = 0.072469</div><div class="line"></div><div class="line">// B组</div><div class="line">ARC total time in seconds = 0.075722</div><div class="line">MRC total time in seconds = 0.101671</div></pre></td></tr></table></figure>
<p>从上面的数据可以看到，<code>ARC</code>与<code>MRC</code>各有快慢的情况。即使上升到统计学的角度，<code>ARC</code>也只是以轻微的优势胜出。看来我的测试姿势不对，并没有证明哪一方占绝对的优势。</p>
<p>嗯，那我们再来看看官方文档是怎么说的吧。在<a href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" target="_blank" rel="external">Transitioning to ARC Release Notes</a>中有这么一段话：</p>
<blockquote>
<p><strong>Is ARC slow?</strong></p>
<p>It depends on what you’re measuring, but generally “no.” The compiler efficiently eliminates many extraneous<code>retain</code>/<code>release</code> calls and much effort has been invested in speeding up the Objective-C runtime in general. In particular, the common “return a retain/autoreleased object” pattern is much faster and does not actually put the object into the autorelease pool, when the caller of the method is ARC code.</p>
<p>One issue to be aware of is that the optimizer is not run in common debug configurations, so expect to see a lot more <code>retain</code>/<code>release</code> traffic at <code>-O0</code> than at <code>-Os</code>.</p>
</blockquote>
<p>再来看看别人的数据吧。<code>Stefan Itterheim</code>在<a href="http://www.learn-cocos2d.com/2013/03/confirmed-arc-slow/" target="_blank" rel="external">Confirmed: Objective-C ARC is slow. Don’t use it! (sarcasm off)</a>一文中给出了大量的测试数据。这篇文章是<code>2013.3.20</code>号发表的。<code>Stefan Itterheim</code>通过他的测试得出一个结论</p>
<blockquote>
<p>ARC is generally faster, and ARC can indeed be slower</p>
</blockquote>
<p>嗯，有些矛盾。不过在文章中，<code>Steffen Itterheim</code>指出大部分情况下，<code>ARC</code>的性能是更好的，这主要得益于一些底层的优化以及<code>autorelease pool</code>的优化，这个从官方文档也能看到。但在一些情况下，<code>ARC</code>确实是更慢，<code>ARC</code>会发送一些额外的<code>retain/release</code>消息，如一些涉及到临时变量的地方，看下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// this is typical MRC code:</div><div class="line">&#123;</div><div class="line">    id object = [array objectAtIndex:0];</div><div class="line">    [object doSomething];</div><div class="line">    [object doAnotherThing];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// this is what ARC does (and what is considered best practice under MRC):</div><div class="line">&#123;</div><div class="line">    id object = [array objectAtIndex:0];</div><div class="line">    [object retain]; // inserted by ARC</div><div class="line">    [object doSomething];</div><div class="line">    [object doAnotherThing];</div><div class="line">    [object release]; // inserted by ARC</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外，在带对象参数的方法中，也有类似的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// this is typical MRC code:</div><div class="line">-(void) someMethod:(id)object</div><div class="line">&#123;</div><div class="line">    [object doSomething];</div><div class="line">    [object doAnotherThing];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// this is what ARC does (and what is considered best practice under MRC):</div><div class="line">-(void) someMethod:(id)object</div><div class="line">&#123;</div><div class="line">    [object retain]; // inserted by ARC</div><div class="line">    [object doSomething];</div><div class="line">    [object doAnotherThing];</div><div class="line">    [object release]; // inserted by ARC</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这些些额外的<code>retain/release</code>操作也成了降低<code>ARC</code>环境下程序性能的罪魁祸首。但实际上，之所以添加这些额外的<code>retain/release</code>操作，是为了保证代码运行的正确性。如果只是在单线程中执行这些操作，可能确实没必要添加这些额外的操作。但一旦涉及以多线程的操作，问题就来了。如上面的方法中，<code>object</code>完全有可能在<code>doSoming</code>和<code>doAnotherThing</code>方法调用之间被释放。为了避免这种情况的发生，便在方法开始处添加了<code>[object retain]</code>，而在方法结束后，添加了<code>[object release]</code>操作。</p>
<p>如果想了解更多关于<code>ARC</code>与<code>MRC</code>性能的讨论，可以阅读一下<a href="http://stackoverflow.com/questions/12527286/are-there-any-concrete-study-of-the-performance-impact-of-using-arc" target="_blank" rel="external">Are there any concrete study of the performance impact of using ARC?</a>与<a href="http://mjtsai.com/blog/2013/09/10/arc-vs-mrc-performance/" target="_blank" rel="external">ARC vs. MRC Performance</a>，在此就不过多的摘抄了。</p>
<p>实际上，即便是<code>ARC</code>的性能不如<code>MRC</code>，我们也应该去使用<code>ARC</code>，因此它给我们带来的好处是不言而喻的。我们不再需要像使用<code>MRC</code>那样，去过多的关注内存问题(虽然内存是必须关注的)，而将更多的时间放在我们真正关心的事情上。如果真的对性能非常关切的话，可以考虑直接用<code>C</code>或<code>C++</code>。反正我是不会再回到<code>MRC</code>时代了。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://stackoverflow.com/questions/12527286/are-there-any-concrete-study-of-the-performance-impact-of-using-arc" target="_blank" rel="external">Are there any concrete study of the performance impact of using ARC?</a></li>
<li><a href="http://mjtsai.com/blog/2013/09/10/arc-vs-mrc-performance/" target="_blank" rel="external">ARC vs. MRC Performance</a></li>
<li><a href="http://www.learn-cocos2d.com/2013/03/confirmed-arc-slow/" target="_blank" rel="external">Confirmed: Objective-C ARC is slow. Don’t use it! (sarcasm off)</a></li>
<li><a href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" target="_blank" rel="external">Transitioning to ARC Release Notes</a></li>
</ol>
<h2 id="Bitcode"><a href="#Bitcode" class="headerlink" title="Bitcode"></a>Bitcode</h2><p>今天试着用<code>Xcode 7 beta 3</code>在真机(<code>iOS 8.3</code>)上运行一下我们的工程，结果发现工程编译不过。看了下问题，报的是以下错误：</p>
<blockquote>
<p>ld: ‘/Users/**/Framework/SDKs/PolymerPay/Library/mobStat/lib**SDK.a(**ForSDK.o)’ does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. for architecture arm64</p>
</blockquote>
<p>得到的信息是我们引入的一个第三方库不包含<code>bitcode</code>。嗯，不知道<code>bitcode</code>是啥，所以就得先看看这货是啥了。</p>
<h3 id="Bitcode是什么？"><a href="#Bitcode是什么？" class="headerlink" title="Bitcode是什么？"></a>Bitcode是什么？</h3><p>找东西嘛，最先想到的当然是先看官方文档了。在<a href="https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html#//apple_ref/doc/uid/TP40012582-CH35" target="_blank" rel="external">App Distribution Guide - App Thinning (iOS, watchOS)</a>一节中，找到了下面这样一个定义：</p>
<blockquote>
<p><em>Bitcode</em> is an intermediate representation of a compiled program. Apps you upload to iTunes Connect that contain bitcode will be compiled and linked on the App Store. Including bitcode will allow Apple to re-optimize your app binary in the future without the need to submit a new version of your app to the store.</p>
</blockquote>
<p>说的是<code>bitcode</code>是被编译程序的一种中间形式的代码。包含<code>bitcode</code>配置的程序将会在<code>App store</code>上被编译和链接。<code>bitcode</code>允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到<code>App store</code>上。</p>
<p>嗯，看着挺高级的啊。</p>
<p>继续看，在<a href="https://developer.apple.com/library/prerelease/ios/documentation/DeveloperTools/Conceptual/WhatsNewXcode/Articles/xcode_7_0.html" target="_blank" rel="external">What’s New in Xcode-New Features in Xcode 7</a>中，还有一段如下的描述</p>
<blockquote>
<p><strong>Bitcode.</strong> When you archive for submission to the App Store, Xcode will compile your app into an intermediate representation. The App Store will then compile the bitcode down into the 64 or 32 bit executables as necessary.</p>
</blockquote>
<p>当我们提交程序到<code>App store</code>上时，<code>Xcode</code>会将程序编译为一个中间表现形式(<code>bitcode</code>)。然后<code>App store</code>会再将这个<code>bitcode</code>编译为可执行的<code>64</code>位或<code>32</code>位程序。</p>
<p>再看看这两段描述都是放在<code>App Thinning</code>(App瘦身)一节中，可以看出其与包的优化有关了。喵大(<a href="http://weibo.com/onevcat" target="_blank" rel="external">@onevcat</a>)在其博客<a href="http://onevcat.com/2015/06/ios9-sdk/" target="_blank" rel="external">开发者所需要知道的 iOS 9 SDK 新特性</a>中也描述了<code>iOS 9</code>中苹果在<code>App</code>瘦身中所做的一些改进，大家可以转场到那去研读一下。</p>
<h3 id="Bitcode配置"><a href="#Bitcode配置" class="headerlink" title="Bitcode配置"></a>Bitcode配置</h3><p>在上面的错误提示中，提到了如何处理我们遇到的问题：</p>
<blockquote>
<p>You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. for architecture arm64</p>
</blockquote>
<p>要么让第三方库支持，要么关闭<code>target</code>的<code>bitcode</code>选项。</p>
<p>实际上在<code>Xcode 7</code>中，我们新建一个<code>iOS</code>程序时，<code>bit code</code>选项默认是设置为<code>YES</code>的。我们可以在<code>”Build Settings”</code>-&gt;<code>”Enable Bitcode”</code>选项中看到这个设置。</p>
<p>不过，我们现在需要考虑的是三个平台：<code>iOS</code>，<code>Mac OS</code>，<code>watchOS</code>。</p>
<ul>
<li>对应<code>iOS</code>，<code>bitcode</code>是可选的。</li>
</ul>
<ul>
<li>对于<code>watchOS</code>，<code>bitcode</code>是必须的。</li>
</ul>
<ul>
<li><code>Mac OS</code>不支持<code>bitcode</code>。</li>
</ul>
<p>如果我们开启了<code>bitcode</code>，在提交包时，下面这个界面也会有个<code>bitcode</code>选项：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/AppDistributionGuide/Art/6_ios_review_dist_profile_submit_2x.png" alt="image"></p>
<blockquote>
<p>盗图，我的应用没办法在这个界面显示<code>bitcode</code>，因为依赖于第三方的库，而这个库不支持<code>bitcode</code>，暂时只能设置<code>ENABLE_BITCODE为NO</code>。</p>
<p>所以，如果我们的工程需要支持<code>bitcode</code>，则必要要求所有的引入的第三方库都支持<code>bitcode</code>。我就只能等着公司那些大哥大姐们啥时候提供一个新包给我们了。</p>
</blockquote>
<h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>如上面所说，<code>bitcode</code>是一种中间代码。<code>LLVM</code>官方文档有介绍这种文件的格式，有兴趣的可以移步<a href="http://llvm.org/docs/BitCodeFormat.html#llvm-bitcode-file-format" target="_blank" rel="external">LLVM Bitcode File Format</a>。</p>
<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html#//apple_ref/doc/uid/TP40012582-CH35" target="_blank" rel="external">App Distribution Guide - App Thinning (iOS, watchOS)</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/DeveloperTools/Conceptual/WhatsNewXcode/Articles/xcode_7_0.html" target="_blank" rel="external">What’s New in Xcode-New Features in Xcode 7</a></li>
<li><a href="http://onevcat.com/2015/06/ios9-sdk/" target="_blank" rel="external">开发者所需要知道的 iOS 9 SDK 新特性</a></li>
<li><a href="http://llvm.org/docs/BitCodeFormat.html#llvm-bitcode-file-format" target="_blank" rel="external">LLVM Bitcode File Format</a></li>
</ol>
<h2 id="在Swift中实现NS-OPTIONS"><a href="#在Swift中实现NS-OPTIONS" class="headerlink" title="在Swift中实现NS_OPTIONS"></a>在Swift中实现NS_OPTIONS</h2><p>从<code>Xcode 4.5</code>以后，我们在<code>Objective-C</code>中使用<code>NS_ENUM</code>和<code>NS_OPTIONS</code>来定义一个枚举，以替代<code>C</code>语言枚举的定义方式。其中<code>NS_ENUM</code>用于定义普通的枚举，<code>NS_OPTIONS</code>用于定义选项类型的枚举。</p>
<p>而到了<code>Swift</code>中，枚举增加了更多的特性。它可以包含原始类型(不再局限于整型)以及相关值。正是由于这些原因，枚举在<code>Swift</code>中得到了更广泛的应用。在<code>Foundation</code>中，<code>Objective-C</code>中的<code>NS_ENUM</code>类型的枚举，都会自动转换成<code>Swift</code>中<code>enum</code>，并且更加精炼。以<code>Collection View</code>的滚动方向为例，在<code>Objective-C</code>中，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSInteger, UICollectionViewScrollDirection) &#123;</div><div class="line">	UICollectionViewScrollDirectionVertical,</div><div class="line">	UICollectionViewScrollDirectionHorizontal</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>而在<code>Swift</code>中，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">enum UICollectionViewScrollDirection : Int &#123;</div><div class="line">	case Vertical</div><div class="line">	case Horizontal</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>精练多了吧，看着舒服多了，还能少码两个字。我们自己定义枚举时，也应该采用这种方式。</p>
<p>不过对于<code>Objective-C</code>中<code>NS_OPTIONS</code>类型的枚举，<code>Swift</code>中的实现似乎就没有那么美好了。</p>
<p>我们再来对比一下<code>UICollectionViewScrollPosition</code>的定义吧，在<code>Objective-C</code>中，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">typedef NS_OPTIONS(NSUInteger, UICollectionViewScrollPosition) &#123;</div><div class="line">    UICollectionViewScrollPositionNone                 = 0,</div><div class="line"></div><div class="line">    // The vertical positions are mutually exclusive to each other, but are bitwise or-able with the horizontal scroll positions.</div><div class="line">    // Combining positions from the same grouping (horizontal or vertical) will result in an NSInvalidArgumentException.</div><div class="line">    UICollectionViewScrollPositionTop                  = 1 &lt;&lt; 0,</div><div class="line">    UICollectionViewScrollPositionCenteredVertically   = 1 &lt;&lt; 1,</div><div class="line">    UICollectionViewScrollPositionBottom               = 1 &lt;&lt; 2,</div><div class="line"></div><div class="line">    // Likewise, the horizontal positions are mutually exclusive to each other.</div><div class="line">    UICollectionViewScrollPositionLeft                 = 1 &lt;&lt; 3,</div><div class="line">    UICollectionViewScrollPositionCenteredHorizontally = 1 &lt;&lt; 4,</div><div class="line">    UICollectionViewScrollPositionRight                = 1 &lt;&lt; 5</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>而在<code>Swift 2.0</code>中，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">struct UICollectionViewScrollPosition : OptionSetType &#123;</div><div class="line">    init(rawValue: UInt)</div><div class="line"></div><div class="line">    static var None: UICollectionViewScrollPosition &#123; get &#125;</div><div class="line"></div><div class="line">    // The vertical positions are mutually exclusive to each other, but are bitwise or-able with the horizontal scroll positions.</div><div class="line">    // Combining positions from the same grouping (horizontal or vertical) will result in an NSInvalidArgumentException.</div><div class="line">    static var Top: UICollectionViewScrollPosition &#123; get &#125;</div><div class="line">    static var CenteredVertically: UICollectionViewScrollPosition &#123; get &#125;</div><div class="line">    static var Bottom: UICollectionViewScrollPosition &#123; get &#125;</div><div class="line"></div><div class="line">    // Likewise, the horizontal positions are mutually exclusive to each other.</div><div class="line">    static var Left: UICollectionViewScrollPosition &#123; get &#125;</div><div class="line">    static var CenteredHorizontally: UICollectionViewScrollPosition &#123; get &#125;</div><div class="line">    static var Right: UICollectionViewScrollPosition &#123; get &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>额，光看代码，不看实现，这也是化简为繁的节奏啊。</p>
<p>为什么要这样做呢？<code>Mattt</code>给了我们如下解释：</p>
<blockquote>
<p>Well, the same integer bitmasking tricks in C don’t work for enumerated types in Swift. An <code>enum</code> represents a type with a closed set of valid options, without a built-in mechanism for representing a conjunction of options for that type. An <code>enum</code> could, ostensibly, define a case for all possible combinations of values, but for <code>n &gt; 3</code>, the combinatorics make this approach untenable.</p>
</blockquote>
<p>意思是<code>Swift</code>不支持<code>C</code>语言中枚举值的整型掩码操作的技巧。在<code>Swift</code>中，一个枚举可以表示一组有效选项的集合，但却没有办法支持这些选项的组合操作(“&amp;”、”|”等)。理论上，一个枚举可以定义选项值的任意组合值，但对于<code>n &gt; 3</code>这种操作，却无法有效的支持。</p>
<p>为了支持类<code>NS_OPTIONS</code>的枚举，<code>Swift 2.0</code>中定义了<code>OptionSetType</code>协议【在<code>Swift 1.2</code>中是使用<code>RawOptionSetType</code>，相比较而言已经改进了不少】，它的声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/// Supplies convenient conformance to `SetAlgebraType` for any type</div><div class="line">/// whose `RawValue` is a `BitwiseOperationsType`.  For example:</div><div class="line">///</div><div class="line">///     struct PackagingOptions : OptionSetType &#123;</div><div class="line">///       let rawValue: Int</div><div class="line">///       init(rawValue: Int) &#123; self.rawValue = rawValue &#125;</div><div class="line">///     </div><div class="line">///       static let Box = PackagingOptions(rawValue: 1)</div><div class="line">///       static let Carton = PackagingOptions(rawValue: 2)</div><div class="line">///       static let Bag = PackagingOptions(rawValue: 4)</div><div class="line">///       static let Satchel = PackagingOptions(rawValue: 8)</div><div class="line">///       static let BoxOrBag: PackagingOptions = [Box, Bag]</div><div class="line">///       static let BoxOrCartonOrBag: PackagingOptions = [Box, Carton, Bag]</div><div class="line">///     &#125;</div><div class="line">///</div><div class="line">/// In the example above, `PackagingOptions.Element` is the same type</div><div class="line">/// as `PackagingOptions`, and instance `a` subsumes instance `b` if</div><div class="line">/// and only if `a.rawValue &amp; b.rawValue == b.rawValue`.</div><div class="line">protocol OptionSetType : SetAlgebraType, RawRepresentable &#123;</div><div class="line"></div><div class="line">    /// An `OptionSet`&apos;s `Element` type is normally `Self`.</div><div class="line">    typealias Element = Self</div><div class="line"></div><div class="line">    /// Convert from a value of `RawValue`, succeeding unconditionally.</div><div class="line">    init(rawValue: Self.RawValue)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从字面上来理解，<code>OptionSetType</code>是选项集合类型，它定义了一些基本操作，包括集合操作(<code>union</code>, <code>intersect</code>, <code>exclusiveOr</code>)、成员管理(<code>contains</code>, <code>insert</code>, <code>remove</code>)、位操作(<code>unionInPlace</code>, <code>intersectInPlace</code>, <code>exclusiveOrInPlace</code>)以及其它的一些基本操作。</p>
<p>作为示例，我们来定义一个表示方向的选项集合，通常我们是定义一个实现<code>OptionSetType</code>协议的结构体，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">struct Directions: OptionSetType &#123;</div><div class="line"></div><div class="line">    var rawValue:Int</div><div class="line">    init(rawValue: Int) &#123;</div><div class="line">        self.rawValue = rawValue</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static let Up: Directions = Directions(rawValue: 1 &lt;&lt; 0)</div><div class="line">    static let Down: Directions = Directions(rawValue: 1 &lt;&lt; 1)</div><div class="line">    static let Left: Directions = Directions(rawValue: 1 &lt;&lt; 2)</div><div class="line">    static let Right: Directions = Directions(rawValue: 1 &lt;&lt; 3)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所需要做的基本上就是这些。然后我们就可以创建<code>Directions</code>的实例了，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let direction: Directions = Directions.Left</div><div class="line">if direction == Directions.Left &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果想同时支持两个方向，则可以如上处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let leftUp: Directions = [Directions.Left, Directions.Up]</div><div class="line">if leftUp.contains(Directions.Left) &amp;&amp; leftUp.contains(Directions.Up) &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果<code>leftUp</code>同时包含<code>Directions.Left</code>和<code>Directions.Up</code>，则返回<code>true</code>。</p>
<p>这里还有另外一种方法来达到这个目的，就是我们在<code>Directions</code>结构体中直接声明声明<code>Left</code>和<code>Up</code>的静态常量，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct Directions: OptionSetType &#123;</div><div class="line"></div><div class="line">    // ...</div><div class="line">    static let LeftUp: Directions = [Directions.Left, Directions.Up]</div><div class="line">    static let RightUp: Directions = [Directions.Right, Directions.Up]</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，我们就可以以如下方式来执行上面的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if leftUp == Directions.LeftUp &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，如果单一选项较多，而要去组合所有的情况，这种方法就显示笨拙了，这种情况下还是推荐使用<code>contains</code>方法。</p>
<p>总体来说，<code>Swift</code>中的对选项的支持没有<code>Objective-C</code>中的<code>NS_OPTIONS</code>来得简洁方便。而且在<code>Swift 1.2</code>的时候，我们还是可以使用”&amp;”和”|”操作符的。下面这段代码在<code>Swift 1.2</code>上是<code>OK</code>的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UIView.animateWithDuration(0.3, delay: 1.0, options: UIViewAnimationOptions.CurveEaseIn | UIViewAnimationOptions.CurveEaseOut, animations: &#123; () -&gt; Void in</div><div class="line">    // ...</div><div class="line">&#125;, completion: nil)</div></pre></td></tr></table></figure>
<p>但到了<code>Swift 2.0</code>时，<code>OptionSetType</code>已经不再支持”&amp;”和”|”操作了，因此，上面这段代码需要修改成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UIView.animateWithDuration(0.3, delay: 1.0, options: [UIViewAnimationOptions.CurveEaseIn, UIViewAnimationOptions.CurveEaseInOut], animations: &#123; () -&gt; Void in</div><div class="line">        // ...</div><div class="line">&#125;, completion: nil)</div></pre></td></tr></table></figure>
<p>不过，慢慢习惯就好。</p>
<h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://nshipster.com/rawoptionsettype/" target="_blank" rel="external">RawOptionSetType</a></li>
<li><a href="http://www.swift-studies.com/blog/2015/6/17/exploring-swift-20-optionsettypes" target="_blank" rel="external">Exploring Swift 2.0 OptionSetTypes</a></li>
<li><a href="http://www.informit.com/articles/article.aspx?p=2420231" target="_blank" rel="external">Notes from WWDC 2015: The Enumerated Delights of Swift 2.0 Option Sets</a>​</li>
<li>《100个Swift开发必备Tip》— Tip 66. Options</li>
</ol>
<h2 id="零碎"><a href="#零碎" class="headerlink" title="零碎"></a>零碎</h2><h3 id="静态分析中”Potential-null-dereference”的处理"><a href="#静态分析中”Potential-null-dereference”的处理" class="headerlink" title="静态分析中”Potential null dereference”的处理"></a>静态分析中”Potential null dereference”的处理</h3><p>我们在写一个方法时，如果希望在方法执行出错时，获取一个<code>NSError</code>对象，我们通常会像下面这样来定义我们的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">+ (NSString )checkStringLength:(NSString *)str error:(NSError **)error &#123;</div><div class="line"></div><div class="line">	if (str.length &lt;= 0) &#123;</div><div class="line">	        *error = [NSError errorWithDomain:@&quot;ErrorDomain&quot; code:-1 userInfo:nil];</div><div class="line">    	return nil;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return str;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码看着没啥问题，至少在语法上是OK的，所以在编译时，编译器并不会报任何警告。</p>
<p>如果我们用以下方式去调用的话，也是一切正常的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSError *error = nil;</div><div class="line">[Test checkStringLength:@&quot;&quot; error:&amp;error];</div></pre></td></tr></table></figure>
<p>不过我们如果就静态分析器来分析一下，发现会在”<code>*error = ...</code>“这行代码处报如下的警告：</p>
<blockquote>
<p>Potential null dereference.  According to coding standards in ‘Creating and Returning NSError Objects’ the parameter may be null</p>
</blockquote>
<p>这句话告诉我们的是这里可能存在空引用。实际上，如果我们像下面这样调用方法的话，程序是会崩溃的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[Test checkStringLength:@&quot;&quot; error:NULL];</div></pre></td></tr></table></figure>
<p>因为此时在方法中，<code>error</code>实际上是<code>NULL</code>，<code>*error</code>这货啥也不是，对它赋值肯定就出错了。</p>
<p>这里正确的姿式是在使用<code>error</code>之前，先判断它是否为<code>NULL</code>，完整的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">+ (NSString )checkStringLength:(NSString *)str error:(NSError **)error &#123;</div><div class="line"></div><div class="line">    if (str.length &lt;= 0) &#123;</div><div class="line"></div><div class="line">        if (error != NULL) &#123;</div><div class="line">            *error = [NSError errorWithDomain:@&quot;ErrorDomain&quot; code:-1 userInfo:nil];</div><div class="line">        &#125;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    return str;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上，对此这种方式的传值，我们始终需要去做非空判断。</p>
<h3 id="Charles支持iOS模拟器"><a href="#Charles支持iOS模拟器" class="headerlink" title="Charles支持iOS模拟器"></a>Charles支持iOS模拟器</h3><p>咬咬牙花了50刀买了一个<code>Charles</code>的<code>License</code>。</p>
<p>今天临时需要在模拟器上跑工程，想抓一下数据包，看一下请求<code>Header</code>里面的信息。工程跑起来时，发现<code>Charles</code>没有抓取到数据。嗯，本着有问题先问<code>stackoverflow</code>的原则，跑到上面搜了一下。找到了这个贴子：<a href="http://stackoverflow.com/questions/25439756/how-to-use-charles-proxy-on-the-xcode-6-ios-8-simulator" target="_blank" rel="external">How to use Charles Proxy on the Xcode 6 (iOS 8) Simulator?</a>。不过我的处理没有他这么麻烦，基本上两步搞定了：</p>
<p>1.在<code>Charles</code>的菜单中选择<code>Help &gt; SSL Proxying &gt; Install Charles Root Certificate in iOS Simulators</code>，直接点击就行。这时候会弹出一个提示框，点击OK就行。</p>
<p>2.如果这时候还不能抓取数据，就重启模拟器。</p>
<p>这样就OK了。在<code>Keychain</code>里面，真机和模拟器的证书是同一个。</p>
<p>至于<code>stackoverflow</code>里面提到的在3.9.3版本上还需要覆盖一个脚本文件，这个没有尝试过，哈哈，我的是最新的3.10.2。</p>
<p>还有个需要注意的是，在抓取模拟器数据时，如果关闭<code>Charles</code>，那么模拟器将无法再请求到网络数据。这时需要重新开启<code>Charles</code>，或者是重启模拟器。另外如果重置了模拟器的设置(<code>Reset Content and Settings…</code>)，<code>Charles</code>也抓取不到模拟器的数据，需要重新来过。</p>
<h4 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a href="http://stackoverflow.com/questions/25439756/how-to-use-charles-proxy-on-the-xcode-6-ios-8-simulator" target="_blank" rel="external">How to use Charles Proxy on the Xcode 6 (iOS 8) Simulator?</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/20/cocoa-uikit-uiapearance/" itemprop="url">
                  UIKit: UIApearance
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-07-20T00:01:05+08:00" content="2015-07-20">
              2015-07-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/cocoa/" itemprop="url" rel="index">
                    <span itemprop="name">Cocoa</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>文章开头先援引一下<code>Mattt Thompson</code>大神在<a href="http://nshipster.com/uiappearance/" target="_blank" rel="external">UIApearance</a>里的一句话吧：</p>
<blockquote>
<p>Users will pay a premium for good-looking software.</p>
</blockquote>
<p>就如同大多数人喜欢看帅哥美女一样，一款<code>App</code>能不能被接受，长得怎样很重要。虽然大家都明白“人不可貌相”这个理，但大多数人其实还是视觉动物。用户体验用户体验，如果都让用户看得不爽了，又何谈用户体验呢？所以…所以…哎，我也只能在这默默地码字了。</p>
<p>在<code>iOS 5</code>以前，我们想去自定义系统控件的外观是一件麻烦的事。如果想统一地改变系统控件的外观，我们可能会想各种办法，如去继承现有的控件类，并在子类中修改，或者甚至于动用<code>method swizzling</code>这样高大上的方法。不过，苹果在<code>iOS 5</code>之后为我们提供了一种新的方法：<code>UIAppearance</code>，让这些事简单了不少。在这里，我们就来总结一下吧。</p>
<h2 id="UIApearance是作用"><a href="#UIApearance是作用" class="headerlink" title="UIApearance是作用"></a>UIApearance是作用</h2><p><code>UIApearance</code>实际上是一个协议，我们可以用它来获取一个类的外观代理(<code>appearance proxy</code>)。为什么说是一个类，而不明确说是一个视图或控件呢？这是因为有些非视图对象(如<code>UIBarButtonItem</code>)也可以实现这个协议，来定义其所包含的视图对象的外观。我们可以给这个类的外观代理发送一个修改消息，来自定义一个类的实例的外观。</p>
<p>我们以系统定义的控件<code>UIButton</code>为例，根据我们的使用方式，可以通过<code>UIAppearance</code>修改整个应用程序中所有<code>UIButton</code>的外观，也可以修改某一特定容器类中所有<code>UIButton</code>的外观(如<code>UIBarButtonItem</code>)。不过需要注意的是，这种修改只会影响到那些执行<code>UIAppearance</code>操作之后添加到我们的视图层级架构中的视图或控件，而不会影响到修改之前就已经添加的对象。因此，如果要修改特定的视图，先确保该视图在使用<code>UIAppearance</code>后才通过<code>addSubview</code>添加到视图层级架构中。</p>
<h2 id="UIAppearance的使用"><a href="#UIAppearance的使用" class="headerlink" title="UIAppearance的使用"></a>UIAppearance的使用</h2><p>如上面所说，有两种方式来自定义对象的外观：针对某一类型的所有实例；针对包含在某一容器类的实例中的某一类型的实例。讲得有点绕，我把文档的原文贴出来吧。</p>
<blockquote>
<p>for all instances, and for instances contained within an instance of a container class.</p>
</blockquote>
<p>为此，<code>UIAppearance</code>声明了两个方法。如果我们想自定义一个类所有实例的外观，则可以使用下面这个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// swift</span></div><div class="line"><span class="keyword">static</span> func appearance() -&gt; Self</div><div class="line"></div><div class="line"><span class="comment">//objc</span></div><div class="line">+ (<span class="keyword">instancetype</span>)appearance</div></pre></td></tr></table></figure>
<p>例如，如果我们想修改<code>UINavigationBar</code>的所有实例的背影颜色和标题外观，则可以如下实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UINavigationBar</span>.appearance().barTintColor = <span class="built_in">UIColor</span>(red: <span class="number">104.0</span>/<span class="number">255.0</span>, green: <span class="number">224.0</span>/<span class="number">255.0</span>, blue: <span class="number">231.0</span>/<span class="number">255.0</span>, alpha: <span class="number">1.0</span>)</div><div class="line">  </div><div class="line"><span class="built_in">UINavigationBar</span>.appearance().titleTextAttributes = [</div><div class="line">    <span class="built_in">NSFontAttributeName</span>: <span class="built_in">UIFont</span>.systemFontOfSize(<span class="number">15.0</span>),</div><div class="line">    <span class="built_in">NSForegroundColorAttributeName</span>: <span class="built_in">UIColor</span>.whiteColor()</div><div class="line">]</div></pre></td></tr></table></figure>
<p>我们也可以指定一类容器，在这个容器中，我们可以自定义一个类的所有实例的外观。我们可以使用下面这个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">instancetype</span>)appearanceWhenContainedIn:(Class&lt;<span class="built_in">UIAppearanceContainer</span>&gt;)ContainerClass, ...</div></pre></td></tr></table></figure>
<p>如，我们想修改导航栏中所有的按钮的外面，则可以如下处理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[[<span class="built_in">UIBarButtonItem</span> appearanceWhenContainedIn:[<span class="built_in">UINavigationBar</span> <span class="keyword">class</span>], <span class="literal">nil</span>]</div><div class="line">   setBackgroundImage:myNavBarButtonBackgroundImage forState:state barMetrics:metrics];</div><div class="line"></div><div class="line">[[<span class="built_in">UIBarButtonItem</span> appearanceWhenContainedIn:[<span class="built_in">UINavigationBar</span> <span class="keyword">class</span>], [<span class="built_in">UIPopoverController</span> <span class="keyword">class</span>], <span class="literal">nil</span>]</div><div class="line">    setBackgroundImage:myPopoverNavBarButtonBackgroundImage forState:state barMetrics:metrics];</div><div class="line"></div><div class="line">[[<span class="built_in">UIBarButtonItem</span> appearanceWhenContainedIn:[<span class="built_in">UIToolbar</span> <span class="keyword">class</span>], <span class="literal">nil</span>]</div><div class="line">    setBackgroundImage:myToolbarButtonBackgroundImage forState:state barMetrics:metrics];</div><div class="line"></div><div class="line">[[<span class="built_in">UIBarButtonItem</span> appearanceWhenContainedIn:[<span class="built_in">UIToolbar</span> <span class="keyword">class</span>], [<span class="built_in">UIPopoverController</span> <span class="keyword">class</span>], <span class="literal">nil</span>]</div><div class="line">    setBackgroundImage:myPopoverToolbarButtonBackgroundImage forState:state barMetrics:metrics];</div></pre></td></tr></table></figure>
<p>注意这个方法的参数是一个可变参数，因此，它可以同时设置多个容器。</p>
<p>我们仔细看文档，发现这个方法没有<code>swift</code>版本，至少我在<code>iOS 8.x</code>的<code>SDK</code>中没有找到对应的方法。呵呵，如果想在<code>iOS 8.x</code>以下的系统用<code>swift</code>来调用<code>appearanceWhenContainedIn</code>，那就乖乖地用混编吧。</p>
<p>不过在<code>iOS 9</code>的<code>SDK</code>中(记录一下，今天是<code>2015.07.18</code>)，又把这个方法给加上了，不过这回参数换成了数组，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@available(iOS <span class="number">9.0</span>, *)</div><div class="line"><span class="keyword">static</span> func appearanceWhenContainedInInstancesOfClasses(containerTypes: [AnyObject.Type]) -&gt; Self</div></pre></td></tr></table></figure>
<p>嗯，这里有个问题，我在<code>Xcode 7.0 beta 3</code>版本上测试<code>swift</code>版本的这个方法时，把将其放在启动方法里面，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 此处会崩溃，提示EXC_BAD_ACCESS</span></div><div class="line">	<span class="keyword">let</span> barButtonItemAppearance = <span class="type">UIBarButtonItem</span>.appearanceWhenContainedInInstancesOfClasses([<span class="type">UINavigationBar</span>.<span class="keyword">self</span>])</div><div class="line"></div><div class="line">	<span class="keyword">let</span> attributes = [</div><div class="line">	    <span class="type">NSFontAttributeName</span>: <span class="type">UIFont</span>.systemFontOfSize(<span class="number">13.0</span>),</div><div class="line">	    <span class="type">NSForegroundColorAttributeName</span>: <span class="type">UIColor</span>.whiteColor()</div><div class="line">	]</div><div class="line"></div><div class="line">	barButtonItemAppearance.setTitleTextAttributes(attributes, forState: .<span class="type">Normal</span>)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>程序崩溃了，在<code>appearanceWhenContainedInInstancesOfClasses</code>这行提示<code>EXC_BAD_ACCESS</code>。既然是内存问题，那就找找吧。我做了如下几个测试：</p>
<p>1.拆分<code>UIBarButtonItem.appearanceWhenContainedInInstancesOfClasses</code>，在其前面加了如下几行代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> appearance = <span class="type">UIBarButtonItem</span>.appearance()</div><div class="line"></div><div class="line"><span class="keyword">let</span> arr: [<span class="type">AnyObject</span>.<span class="type">Type</span>] = [<span class="type">UINavigationBar</span>.<span class="keyword">self</span>, <span class="type">UIToolbar</span>.<span class="keyword">self</span>]</div><div class="line"></div><div class="line"><span class="built_in">print</span>(arr)</div></pre></td></tr></table></figure>
<p>可以看到除了<code>appearanceWhenContainedInInstancesOfClasses</code>自身外，其它几个元素都是没问题的。</p>
<p>2.将这段拷贝到默认的<code>ViewController</code>中，运行。同样崩溃了。</p>
<p>3.在相同环境下(<code>Xcode 7.0 beta 3 + iOS 9.0</code>)，用<code>Objective-C</code>对应的方法试了一下，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</div><div class="line">    </div><div class="line">    [<span class="built_in">UIBarButtonItem</span> appearanceWhenContainedInInstancesOfClasses:@[[<span class="built_in">UINavigationBar</span> <span class="keyword">class</span>]]];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>程序很愉快地跑起来了。</p>
<p>额，我能把这个归结为版本不稳定的缘故么？等到稳定版出来后再研究一下吧。</p>
<h2 id="支持UIAppearance的组件"><a href="#支持UIAppearance的组件" class="headerlink" title="支持UIAppearance的组件"></a>支持UIAppearance的组件</h2><p>从<code>iOS 5.0</code>后，有很多<code>iOS</code>的<code>API</code>都已经支持<code>UIAppearance</code>的代理方法了，<code>Mattt Thompson</code>在<a href="http://nshipster.com/uiappearance/" target="_blank" rel="external">UIApearance</a>中，给我们提供了以下两行脚本代码，可以获取所有支持<code>UI_APPEARANCE_SELECTOR</code>的方法(我们将在下面介绍<code>UI_APPEARANCE_SELECTOR</code>)：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cd /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS*.sdk/System/Library/Frameworks/<span class="built_in">UIKit</span>.framework/Headers</div><div class="line"></div><div class="line">$ grep -H <span class="built_in">UI_APPEARANCE_SELECTOR</span> .<span class="comment">/* | sed 's/ __OSX_AVAILABLE_STARTING(__MAC_NA,__IPHONE_5_0) UI_APPEARANCE_SELECTOR;//'</span></div></pre></td></tr></table></figure>
<p>大家可以试一下，我这里列出部分输出：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">./<span class="built_in">UIActivityIndicatorView</span>.h:<span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) <span class="built_in">UIColor</span> *color <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0) <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</div><div class="line">./<span class="built_in">UIAppearance</span>.h:<span class="comment">/* To participate in the appearance proxy API, tag your appearance property selectors in your header with UI_APPEARANCE_SELECTOR.</span></div><div class="line">./UIAppearance.h:#define UI_APPEARANCE_SELECTOR __attribute__((annotate("ui_appearance_selector")))</div><div class="line">./UIBarButtonItem.h:- (void)setBackgroundImage:(UIImage *)backgroundImage forState:(UIControlState)state barMetrics:(UIBarMetrics)barMetrics NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;</div><div class="line">./UIBarButtonItem.h:- (UIImage *)backgroundImageForState:(UIControlState)state barMetrics:(UIBarMetrics)barMetrics NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;</div><div class="line">./UIBarButtonItem.h:- (void)setBackgroundImage:(UIImage *)backgroundImage forState:(UIControlState)state style:(UIBarButtonItemStyle)style barMetrics:(UIBarMetrics)barMetrics NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;</div><div class="line">./UIBarButtonItem.h:- (UIImage *)backgroundImageForState:(UIControlState)state style:(UIBarButtonItemStyle)style barMetrics:(UIBarMetrics)barMetrics NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;</div><div class="line">./UIBarButtonItem.h:- (void)setBackgroundVerticalPositionAdjustment:(CGFloat)adjustment forBarMetrics:(UIBarMetrics)barMetrics NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR; </div><div class="line">......</div></pre></td></tr></table></figure>
<p>大家还可以在<a href="https://gist.github.com/mattt/5135521" target="_blank" rel="external">这里</a>查看<code>iOS 7.0</code>下的清单。</p>
<h2 id="自定义类实现UIAppearance"><a href="#自定义类实现UIAppearance" class="headerlink" title="自定义类实现UIAppearance"></a>自定义类实现UIAppearance</h2><p>我们可以自定义一个类，并让这个类支持<code>UIAppearance</code>。为此，我们需要做两件事：</p>
<ol>
<li>让我们的类实现<code>UIAppearanceContainer</code>协议</li>
<li>如果是在<code>Objective-C</code>中，则将相关的方法用<code>UI_APPEARANCE_SELECTOR</code>来标记。而在<code>Swift</code>中，需要在对应的属性或方法前面加上<code>dynamic</code>。</li>
</ol>
<p>当然，要让我们的类可以使用<code>appearance</code>(或<code>appearanceWhenContainedInInstancesOfClasses</code>)来获取自己的类，则还需要实现<code>UIAppearance</code>协议。</p>
<p>在这里，我们来定义一个带边框的<code>Label</code>，通过<code>UIAppearance</code>来设置它的默认边框。实际上，<code>UIView</code>已经实现了<code>UIAppearance</code>和<code>UIAppearanceContainer</code>协议。因此，我们在其子类中不再需要显式地去声明实现这两个接口。</p>
<p>我们的Label的声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// RoundLabel.h</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RoundLabel</span> : <span class="title">UILabel</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> borderWidth <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> cornerRadius <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">UIColor</span> *borderColor <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>具体的实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RoundLabel</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> drawRect:rect];</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.layer.borderColor = _borderColor.CGColor;</div><div class="line">    <span class="keyword">self</span>.layer.cornerRadius = _cornerRadius;</div><div class="line">    <span class="keyword">self</span>.layer.borderWidth = _borderWidth;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setBorderWidth:(<span class="built_in">CGFloat</span>)borderWidth &#123;</div><div class="line">    </div><div class="line">    _borderWidth = borderWidth;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setCornerRadius:(<span class="built_in">CGFloat</span>)cornerRadius &#123;</div><div class="line">    </div><div class="line">    _cornerRadius = cornerRadius;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setRectColor:(<span class="built_in">UIColor</span> *)rectColor &#123;</div><div class="line">    </div><div class="line">    _borderColor = rectColor;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>我们在<code>drawRect:</code>设置<code>Label</code>的边框，这样<code>RoundLabel</code>的所有实例就可以使用默认的边框配置属性了。</p>
<p>然后，我们可以在<code>AppDelegate</code>或者其它某个位置来设置<code>RoundLabel</code>的默认配置，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIColor</span> *color = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">104.0</span>/<span class="number">255.0</span> green:<span class="number">224.0</span>/<span class="number">255.0</span> blue:<span class="number">231.0</span>/<span class="number">255.0</span> alpha:<span class="number">1.0</span>f];</div><div class="line"></div><div class="line">[RoundLabel appearance].cornerRadius = <span class="number">5.0</span>f;</div><div class="line">[RoundLabel appearance].borderColor = color;</div><div class="line">[RoundLabel appearance].borderWidth = <span class="number">1.0</span>f;</div></pre></td></tr></table></figure>
<p>当然，我们在使用<code>RoundLabel</code>时，可以根据实际需要再修改这几个属性的值。</p>
<p><code>Swift</code>的实现就简单多了，我们只需要如下处理：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoundLabel</span>: <span class="title">UILabel</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">setBorderColor</span><span class="params">(color: UIColor)</span></span> &#123;</div><div class="line">        layer.borderColor = color.<span class="type">CGColor</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">setBorderWidth</span><span class="params">(width: CGFloat)</span></span> &#123;</div><div class="line">        layer.borderWidth = width</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">setCornerRadius</span><span class="params">(radius: CGFloat)</span></span> &#123;</div><div class="line">        layer.cornerRadius = radius</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>UIAppearanceContainer</code>的官方文档中，有对支持<code>UIAppearance</code>的方法作格式限制，具体要求如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Swift</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">propertyForAxis1</span><span class="params">(axis1: IntegerType, axis2: IntegerType, axisN: IntegerType)</span></span> -&gt; <span class="type">PropertyType</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">setProperty</span><span class="params">(property: PropertyType, forAxis1 axis1: IntegerType, axis2: IntegerType)</span></span></div><div class="line"></div><div class="line"><span class="comment">//objc</span></div><div class="line">- (<span class="type">PropertyType</span>)propertyForAxis1:(<span class="type">IntegerType</span>)axis1 axis2:(<span class="type">IntegerType</span>)axis2 … axisN:(<span class="type">IntegerType</span>)axisN;</div><div class="line">- (void)setProperty:(<span class="type">PropertyType</span>)property forAxis1:(<span class="type">IntegerType</span>)axis1 axis2:(<span class="type">IntegerType</span>)axis2 … axisN:(<span class="type">IntegerType</span>)axisN;</div></pre></td></tr></table></figure>
<p>其中的属性类型可以是<code>iOS</code>的任意类型，包括<code>id</code>, <code>NSInteger</code>, <code>NSUInteger</code>, <code>CGFloat</code>, <code>CGPoint</code>, <code>CGSize</code>, <code>CGRect</code>, <code>UIEdgeInsets</code>或<code>UIOffset</code>。而<code>IntegerType</code>必须是<code>NSInteger</code>或者<code>NSUInteger</code>。如果类型不对，则会抛出异常。</p>
<p>我们可以以<code>UIBarButtonItem</code>为例，它定义了以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">setTitlePositionAdjustment:forBarMetrics:</div><div class="line"></div><div class="line">backButtonBackgroundImageForState:barMetrics:</div><div class="line"></div><div class="line">setBackButtonBackgroundImage:forState:barMetrics:</div></pre></td></tr></table></figure>
<p>这些方法就是满足上面所提到的格式。</p>
<h2 id="Trait-Collection"><a href="#Trait-Collection" class="headerlink" title="Trait Collection"></a>Trait Collection</h2><p>我们查看<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIAppearance_Protocol/" target="_blank" rel="external">UIAppearance</a>的官方文档，可以看到在<code>iOS 8</code>后，这个协议又新增了两个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Swift</span></div><div class="line"><span class="keyword">static</span> func appearanceForTraitCollection(_ trait: <span class="built_in">UITraitCollection</span>) -&gt; Self</div><div class="line"></div><div class="line"><span class="comment">//objc</span></div><div class="line">+ (<span class="keyword">instancetype</span>)appearanceForTraitCollection:(<span class="built_in">UITraitCollection</span> *)trait</div><div class="line">  </div><div class="line">+ (<span class="keyword">instancetype</span>)appearanceForTraitCollection:(<span class="built_in">UITraitCollection</span> *)trait</div><div class="line">                         whenContainedIn:(Class&lt;<span class="built_in">UIAppearanceContainer</span>&gt;)ContainerClass, ...</div></pre></td></tr></table></figure>
<p>这两个方法涉及到<code>Trait Collection</code>，具体的内容我们在此不过多的分析。</p>
<h2 id="一些深入的东西"><a href="#一些深入的东西" class="headerlink" title="一些深入的东西"></a>一些深入的东西</h2><p>了解了怎么去使用<code>UIApearance</code>，现在我们再来了解一下它是怎么运作的。我们跟着<a href="http://petersteinberger.com/blog/2013/uiappearance-for-custom-views/" target="_blank" rel="external">UIAppearance for Custom Views</a>一文的思路来走。</p>
<p>我们在以下实现中打一个断点：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setBorderWidth:(<span class="built_in">CGFloat</span>)borderWidth &#123;</div><div class="line">    </div><div class="line">    _borderWidth = borderWidth;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后运行程序。程序启动时，我们发现虽然在<code>AppDelegate</code>中调用了</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[RoundLabel appearance].borderWidth = <span class="number">1.0</span>f;</div></pre></td></tr></table></figure>
<p>但实际上，此时程序没有到在此断住。我们再进到<code>Label</code>所在的视图控制器，这时程序在断点处停住了。在这里，我们可以看看方法的调用栈。</p>
<p><img src="https://raw.githubusercontent.com/southpeak/Blog-images/master/UIAppearance-Example-01.png" alt="image"></p>
<p>在调用栈里面，我们可以看到<code>_UIAppearance</code>这个东东，我们从<a href="https://github.com/nst/iOS-Runtime-Headers/blob/master/Frameworks/UIKit.framework/_UIAppearance.h" target="_blank" rel="external">iOS-Runtime-Headers</a>可以找到这个类的定义：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_UIAppearance</span> : <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="built_in">NSMutableArray</span> *_appearanceInvocations;</div><div class="line">    <span class="built_in">NSArray</span> *_containerList;</div><div class="line">    _UIAppearanceCustomizableClassInfo *_customizableClassInfo;</div><div class="line">    <span class="built_in">NSMapTable</span> *_invocationSources;</div><div class="line">    <span class="built_in">NSMutableDictionary</span> *_resettableInvocations;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中<a href="https://github.com/nst/iOS-Runtime-Headers/blob/master/Frameworks/UIKit.framework/_UIAppearanceCustomizableClassInfo.h" target="_blank" rel="external">_UIAppearanceCustomizableClassInfo</a>存储的是外观对应的类的信息。我们可以看看这个类的声明：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_UIAppearanceCustomizableClassInfo</span> : <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="built_in">NSString</span> *_appearanceNodeKey;</div><div class="line">    Class _customizableViewClass;</div><div class="line">    Class _guideClass;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> _hash;</div><div class="line">    <span class="built_in">BOOL</span> _isCustomizableViewClassRoot;</div><div class="line">    <span class="built_in">BOOL</span> _isGuideClassRoot;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *_appearanceNodeKey;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) Class _customizableViewClass;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) Class _guideClass;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">unsigned</span> <span class="keyword">int</span> _hash;</div><div class="line"></div><div class="line">+ (<span class="keyword">id</span>)_customizableClassInfoForViewClass:(Class)arg1 withGuideClass:(Class)arg2;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)_appearanceNodeKey;</div><div class="line">- (Class)_customizableViewClass;</div><div class="line">- (Class)_guideClass;</div><div class="line">- (<span class="keyword">unsigned</span> <span class="keyword">int</span>)_hash;</div><div class="line">- (<span class="keyword">id</span>)_superClassInfo;</div><div class="line">- (<span class="keyword">void</span>)dealloc;</div><div class="line">- (<span class="keyword">id</span>)description;</div><div class="line">- (<span class="keyword">unsigned</span> <span class="keyword">int</span>)hash;</div><div class="line">- (<span class="built_in">BOOL</span>)isEqual:(<span class="keyword">id</span>)arg1;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>在<code>_UIAppearance</code>中，还有一个<code>_appearanceInvocations</code>变量，我们可以在<code>Debug</code>中尝试用以下命令来打印出它的信息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">po [[<span class="built_in">NSClassFromString</span>(<span class="string">@"_UIAppearance"</span>) _appearanceForClass:[RoundLabel <span class="keyword">class</span>] withContainerList:<span class="literal">nil</span>] valueForKey:<span class="string">@"_appearanceInvocations"</span>]</div></pre></td></tr></table></figure>
<p>我们可以得到以下的信息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;__NSArrayM <span class="number">0x7fd44a5c1f80</span>&gt;(</div><div class="line">&lt;<span class="built_in">NSInvocation</span>: <span class="number">0x7fd44a5c1d20</span>&gt;</div><div class="line"><span class="keyword">return</span> value: &#123;v&#125; <span class="keyword">void</span></div><div class="line">target: &#123;@&#125; <span class="number">0x10b545ae0</span></div><div class="line">selector: &#123;:&#125; setCornerRadius:</div><div class="line">argument <span class="number">2</span>: &#123;d&#125; <span class="number">0.000000</span></div><div class="line">,</div><div class="line">&lt;<span class="built_in">NSInvocation</span>: <span class="number">0x7fd44a5bf300</span>&gt;</div><div class="line"><span class="keyword">return</span> value: &#123;v&#125; <span class="keyword">void</span></div><div class="line">target: &#123;@&#125; <span class="number">0x10b545ae0</span></div><div class="line">selector: &#123;:&#125; setBorderColor:</div><div class="line">argument <span class="number">2</span>: &#123;@&#125; <span class="number">0x7fd44a5bbb80</span></div><div class="line">,</div><div class="line">&lt;<span class="built_in">NSInvocation</span>: <span class="number">0x7fd44a50b8c0</span>&gt;</div><div class="line"><span class="keyword">return</span> value: &#123;v&#125; <span class="keyword">void</span></div><div class="line">target: &#123;@&#125; <span class="number">0x10b545ae0</span></div><div class="line">selector: &#123;:&#125; setBorderWidth:</div><div class="line">argument <span class="number">2</span>: &#123;d&#125; <span class="number">0.000000</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>可以看到这个数组中存储的实际上是<code>NSInvocation</code>对象，每个对象就是我们在程序中设置的<code>RoundLabel</code>外观的方法信息。</p>
<p>在<code>Peter Steinberger</code>的文章中，有提到当我们设置了一个自定义的外观时，<a href="https://github.com/nst/iOS-Runtime-Headers/blob/master/Frameworks/UIKit.framework/_UIAppearanceRecorder.h" target="_blank" rel="external">_UIAppearanceRecorder</a>会去保存并跟踪这个设置。我们可以看看<code>_UIAppearanceRecorder</code>的声明：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_UIAppearanceRecorder</span> : <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="built_in">NSString</span> *_classNameToRecord;</div><div class="line">    <span class="built_in">NSArray</span> *_containerClassNames;</div><div class="line">    <span class="built_in">NSMutableArray</span> *_customizations;</div><div class="line">    Class _superclassToRecord;</div><div class="line">    <span class="built_in">NSArray</span> *_unarchivedCustomizations;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过有点可惜的是，我没有从这里找到太多的信息。我用<code>runtime</code>检查了一下这个类中的数据，貌似没有太多东西。可能是姿势不对，我把代码和结果贴出来，大家帮我看看。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">Class recorderClass = <span class="built_in">NSClassFromString</span>(<span class="string">@"_UIAppearanceRecorder"</span>);</div><div class="line"></div><div class="line"><span class="keyword">id</span> recorder = [recorderClass performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"_sharedAppearanceRecorderForClass::whenContainedIn:"</span>) withObject:[RoundLabel <span class="keyword">class</span>] withObject:<span class="literal">nil</span>];</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"_UIAppearanceRecorder instance : %@"</span>, recorder);</div><div class="line"></div><div class="line">Ivar *variables = class_copyIvarList(recorderClass, &amp;outCount);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</div><div class="line">    Ivar variable = variables[i];</div><div class="line"></div><div class="line">    <span class="keyword">id</span> value = object_getIvar(recorder, variable);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"variable's name: %s, value: %@"</span>, ivar_getName(variable), value);</div><div class="line">&#125;</div><div class="line"></div><div class="line">free(variables);</div></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">UIAppearanceExample2[7600:381708] _UIAppearanceRecorder instance : &lt;_UIAppearanceRecorder: 0x7fa29a718960&gt;</div><div class="line">UIAppearanceExample2[7600:381708] variable's name: _classNameToRecord, value: RoundLabel</div><div class="line">UIAppearanceExample2[7600:381708] variable's name: _superclassToRecord, value: (null)</div><div class="line">UIAppearanceExample2[7600:381708] variable's name: _containerClassNames, value: (null)</div><div class="line">UIAppearanceExample2[7600:381708] variable's name: _customizations, value: (</div><div class="line">)</div><div class="line">UIAppearanceExample2[7600:381708] variable's name: _unarchivedCustomizations, value: (null)</div></pre></td></tr></table></figure>
<p>我们回过头再来看看<code>_UIAppearance的_appearanceInvocations</code>，我们是否可以这样猜测：<code>UIAppearance</code>是否是通过类似于<code>Swizzling Method</code>这种方式，在运行时去更新视图的默认显示呢？求解。</p>
<h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>这一小篇遗留下了两个问题：</p>
<ol>
<li>在<code>swift</code>中如何正确地使用<code>appearanceWhenContainedInInstancesOfClasses</code>方法？我在<code>stackoverflow</code>中没有找到答案。</li>
<li><code>iOS</code>内部是如何用<code>UIAppearance</code>设置的信息来在运行时替换默认的设置的？</li>
</ol>
<p>如果有答案，还请告知。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>使用<code>UIAppearance</code>，可以让我们方便地去修改一些视图或控件的默认显示。同样，如果我们打算开发一个视图库，也可能会用到相关的内容。我们可以在库的内部自定义一些<code>UIAppearance</code>的规则来代替手动去修改视图外观。这样，库外部就可以方便的通过<code>UIAppearance</code>来整体修改一个类中视图的外观了。</p>
<p>我在<code>github</code>中搜索<code>UIAppearance</code>相关的实例时，找到了<a href="https://github.com/robertwijas/UISS" target="_blank" rel="external">UISS</a>这个开源库，它提供了一种便捷的方式来定义程序的样式。这个库也是基于<code>UIAppearance</code>的。看其介绍，如果我们想自定义一个<code>UIButton</code>的外观，可以使用以下方式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"UIButton"</span>:&#123;</div><div class="line">        <span class="string">"titleColor:normal"</span>:[<span class="string">"white"</span>, <span class="number">0.8</span>],</div><div class="line">        <span class="string">"titleColor:highlighted"</span>:<span class="string">"white"</span>,</div><div class="line">        <span class="string">"backgroundImage:normal"</span>: [<span class="string">"button-background-normal"</span>, [<span class="number">0</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">10</span>]],</div><div class="line">        <span class="string">"backgroundImage:highlighted"</span>: [<span class="string">"button-background-highlighted"</span>, [<span class="number">0</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">10</span>]],</div><div class="line">        <span class="string">"titleEdgeInsets"</span>: [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</div><div class="line">        <span class="string">"UILabel"</span>:&#123;</div><div class="line">            <span class="string">"font"</span>:[<span class="string">"Copperplate-Bold"</span>, <span class="number">18</span>]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看着像<code>JSON</code>吧？</p>
<p>具体的我也还没有看，回头抽空再研究研究这个库。</p>
<p><em>补充：文章中的示例代码已放到<code>github</code>中，可以在<a href="https://github.com/southpeak/iOS-Dev-Examples/tree/master/UIKit/UIApearance" target="_blank" rel="external">这里</a>查看(不保证在<code>iOS 9.0</code>以下能正常进行，嘿嘿)</em></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://nshipster.com/uiappearance/" target="_blank" rel="external">UIApearance</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIAppearance_Protocol/" target="_blank" rel="external">UIAppearance Protocol Reference</a></li>
<li><a href="https://developer.apple.com/library//ios/recipes/UIAppearanceContainer_Protocol/index.html" target="_blank" rel="external">UIAppearanceContainer Protocol Reference</a></li>
<li><a href="http://petersteinberger.com/blog/2013/uiappearance-for-custom-views/" target="_blank" rel="external">UIAppearance for Custom Views</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/06/30/ios-techset-3/" itemprop="url">
                  iOS知识小集 第3期(2015.06.30)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-06-30T00:15:14+08:00" content="2015-06-30">
              2015-06-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/techset/" itemprop="url" rel="index">
                    <span itemprop="name">知识小集</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>Swift2</code>出来了，还是得与时俱进啊，不然就成老古董了。再者它开源了，又有事情要做了。当个程序猿真是累啊，一直在追，可从来没追上，刚有那么点念想了，人家又踩了脚油门。</p>
<p>一个月又要过去了，说好的一月两到三篇的，看来希望也是有点渺茫了。本来想好好整理下僵尸对象的内容，看看时间也不多了，也只好放到后面了。这一期没啥好内容，质量也不高，大家凑合着看吧，有疏漏还请大家指出，我一定好好改正。</p>
<p>这一期主要有三个内容：</p>
<ol>
<li>Tint Color</li>
<li>Build Configurations in Swift</li>
<li>键盘事件</li>
</ol>
<h2 id="Tint-Color"><a href="#Tint-Color" class="headerlink" title="Tint Color"></a>Tint Color</h2><p>在<code>iOS 7</code>后，<code>UIView</code>新增加了一个<code>tintColor</code>属性，这个属性定义了一个非默认的着色颜色值，其值的设置会影响到以视图为根视图的整个视图层次结构。它主要是应用到诸如app图标、导航栏、按钮等一些控件上，以获取一些有意思的视觉效果。</p>
<p><code>tintColor</code>属性的声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var tintColor: UIColor!</div></pre></td></tr></table></figure>
<p>默认情况下，一个视图的<code>tintColor</code>是为<code>nil</code>的，这意味着视图将使用父视图的<code>tint color</code>值。当我们指定了一个视图的<code>tintColor</code>后，这个色值会自动传播到视图层次结构(以当前视图为根视图)中所有的子视图上。如果系统在视图层次结构中没有找到一个非默认的<code>tintColor</code>值，则会使用系统定义的颜色值(蓝色，<code>RGB</code>值为<code>[0,0.478431,1]</code>，我们可以在IB中看到这个颜色)。因此，这个值总是会返回一个颜色值，即我们没有指定它。</p>
<p>与<code>tintColor</code>属性相关的还有个<code>tintAdjustmentMode</code>属性，它是一个枚举值，定义了<code>tint color</code>的调整模式。其声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var tintAdjustmentMode: UIViewTintAdjustmentMode</div></pre></td></tr></table></figure>
<p>枚举UIViewTintAdjustmentMode的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">enum UIViewTintAdjustmentMode : Int &#123;</div><div class="line">    case Automatic			// 视图的着色调整模式与父视图一致</div><div class="line">    case Normal				// 视图的tintColor属性返回完全未修改的视图着色颜色</div><div class="line">    case Dimmed				// 视图的tintColor属性返回一个去饱和度的、变暗的视图着色颜色</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此，当<code>tintAdjustmentMode</code>属性设置为<code>Dimmed</code>时，<code>tintColor</code>的颜色值会自动变暗。而如果我们在视图层次结构中没有找到默认值，则该值默认是<code>Normal</code>。</p>
<p>与<code>tintColor</code>相关的还有一个<code>tintColorDidChange</code>方法，其声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func tintColorDidChange()</div></pre></td></tr></table></figure>
<p>这个方法会在视图的<code>tintColor</code>或<code>tintAdjustmentMode</code>属性改变时自动调用。另外，如果当前视图的父视图的<code>tintColor</code>或<code>tintAdjustmentMode</code>属性改变时，也会调用这个方法。我们可以在这个方法中根据需要去刷新我们的视图。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>接下来我们通过示例来看看<code>tintColor</code>的强大功能(示例盗用了<code>Sam Davies</code>写的一个例子，具体可以查看<a href="https://www.shinobicontrols.com/blog/posts/2013/09/27/ios7-day-by-day-day-6-tint-color" target="_blank" rel="external">iOS7 Day-by-Day :: Day 6 :: Tint Color</a>，我就负责搬砖，用swift实现了一下，代码可以在<a href="https://github.com/southpeak/iOS-Dev-Examples/tree/master/UIKit/UIView/1.%20TintColorExample" target="_blank" rel="external">这里</a>下载)。</p>
<p>先来看看最终效果吧(以下都是盗图，请见谅，太懒了)：</p>
<p><img src="https://www.shinobicontrols.com/media/371241/tint_color_image_1_350x621.jpg" alt="image"></p>
<p>这个界面包含的元素主要有<code>UIButton</code>, <code>UISlider</code>, <code>UIProgressView</code>, <code>UIStepper</code>, <code>UIImageView</code>, <code>ToolBar</code>和一个自定义的子视图<code>CustomView</code>。接下来我们便来看看修改视图的<code>tintColor</code>会对这些控件产生什么样的影响。</p>
<p>在<code>ViewController</code>的<code>viewDidLoad</code>方法中，我们做了如下设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">override func viewDidLoad() &#123;</div><div class="line">	super.viewDidLoad()</div><div class="line"></div><div class="line">    println(&quot;\(self.view.tintAdjustmentMode.rawValue)&quot;)         // 输出：1</div><div class="line">    println(&quot;\(self.view.tintColor)&quot;)                           // 输出：UIDeviceRGBColorSpace 0 0.478431 1 1</div><div class="line"></div><div class="line">    self.view.tintAdjustmentMode = .Normal</div><div class="line">    self.dimTintSwitch?.on = false</div><div class="line"></div><div class="line">    // 加载图片</div><div class="line">    var shinobiHead = UIImage(named: &quot;shinobihead&quot;)</div><div class="line">    // 设置渲染模式</div><div class="line">    shinobiHead = shinobiHead?.imageWithRenderingMode(.AlwaysTemplate)</div><div class="line"></div><div class="line">    self.tintedImageView?.image = shinobiHead</div><div class="line">    self.tintedImageView?.contentMode = .ScaleAspectFit</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，我们尝试打印默认的<code>tintColor</code>和<code>tintAdjustmentMode</code>，分别输出了<code>[UIDeviceRGBColorSpace 0 0.478431 1 1]</code>和<code>1</code>，这是在我们没有对整个视图层次结构设置任何<code>tint color</code>相关的值的情况下的输出。可以看到，虽然我们没有设置<code>tintColor</code>，但它仍然返回了系统的默认值；而<code>tintAdjustmentMode</code>则默认返回<code>Normal</code>的原始值。</p>
<p>接下来，我们显式设置<code>tintAdjustmentMode</code>的值为<code>Normal</code>，同时设置<code>UIImageView</code>的图片及渲染模式。</p>
<p>当我们点击”<code>Change Color</code>“按钮时，会执行以下的事件处理方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@IBAction func changeColorHandler(sender: AnyObject) &#123;</div><div class="line">	let hue = CGFloat(arc4random() % 256) / 256.0</div><div class="line">    let saturation = CGFloat(arc4random() % 128) / 256.0 + 0.5</div><div class="line">    let brightness = CGFloat(arc4random() % 128) / 256.0 + 0.5</div><div class="line"></div><div class="line">    let color = UIColor(hue: hue, saturation: saturation, brightness: brightness, alpha: 1.0)</div><div class="line">    self.view.tintColor = color</div><div class="line">    updateViewConstraints()</div><div class="line">&#125;</div><div class="line"></div><div class="line">private func updateProgressViewTint() &#123;</div><div class="line">    self.progressView?.progressTintColor = self.view.tintColor</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码主要是随机生成一个颜色值，并赋值给<code>self.view</code>的<code>tintColor</code>属性，同时去更新进度条的tintColor值。</p>
<p><em>注：有些控件的特定组成部件的tint color由特定的属性控制，例如进度就有2个tint color：一个用于进度条本身，另一个用于背景。</em></p>
<p>点击”<code>Change Color</code>“按钮，可得到以下效果：</p>
<p><img src="https://www.shinobicontrols.com/media/371246/tint_color_image_2_350x621.jpg" alt="image"></p>
<p>可以看到，我们在示例中并有没手动去设置<code>UIButton</code>, <code>UISlider</code>, <code>UIStepper</code>, <code>UIImageView</code>, <code>ToolBar</code>等子视图的颜色值，但随着<code>self.view</code>的<code>tintColor</code>属性颜色值的变化，这些控件的外观也同时跟着改变。也就是说<code>self.view</code>的<code>tintColor</code>属性颜色值的变化，影响到了以<code>self.view</code>为根视图的整个视图层次结果中所有子视图的外观。</p>
<p>看来<code>tintColor</code>还是很强大的嘛。</p>
<p>在界面中还有个<code>UISwitch</code>，这个是用来开启关闭<code>dim tint</code>的功能，其对应处理方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@IBAction func dimTimtHandler(sender: AnyObject) &#123;</div><div class="line">	if let isOn = self.dimTintSwitch?.on &#123;</div><div class="line"></div><div class="line">        self.view.tintAdjustmentMode = isOn ? .Dimmed : .Normal</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    updateViewConstraints()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当<code>tintAdjustmentMode</code>设置<code>Dimmed</code>时，其实际的效果是整个色值都变暗(此处无图可盗)。</p>
<p>另外，我们在子视图<code>CustomView</code>中重写了<code>tintColorDidChange</code>方法，以监听<code>tintColor</code>的变化，以更新我们的自定义视图，其实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">override func tintColorDidChange() &#123;</div><div class="line">	tintColorLabel.textColor = self.tintColor</div><div class="line">    tintColorBlock.backgroundColor = self.tintColor</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以方框和”<code>Tint color label</code>“颜色是跟着子视图的<code>tintColor</code>来变化的，而子视图的<code>tintColor</code>又是继承自父视图的。</p>
<p>在这个示例中，比较有意思的是还是对图片的处理。对图像的处理比较简单粗暴，对一个像素而言，如果它的<code>alpha</code>值为<code>1</code>的话，就将它的颜色设置为<code>tint color</code>；如果不为<code>1</code>的话，则设置为透明的。示例中的忍者头像就是这么处理的。不过我们需要设置图片的<code>imageWithRenderingMode</code>属性为<code>AlwaysTemplate</code>，这样渲染图片时会将其渲染为一个模板而忽略它的颜色信息，如代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var shinobiHead = UIImage(named: &quot;shinobihead&quot;)</div><div class="line">// 设置渲染模式</div><div class="line">shinobiHead = shinobiHead?.imageWithRenderingMode(.AlwaysTemplate)</div></pre></td></tr></table></figure>
<h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>插个题外话，跟主题关系不大。</p>
<p>在色彩理论(<code>color theory</code>)中，一个<code>tint color</code>是一种颜色与白色的混合。与之类似的是<code>shade color</code>和<code>tone color</code>。<code>shade color</code>是将颜色与黑色混合，<code>tone color</code>是将颜色与灰色混合。它们都是基于<code>Hues</code>色调的。这几个色值的效果如下图所示：</p>
<p><img src="http://www.craftsy.com/blog/wp-content/uploads/2013/04/Screen-Shot-2013-04-30-at-12.46.43-PM.png" alt="image"></p>
<p>一些基础的理论知识可以参考<a href="http://www.craftsy.com/blog/2013/05/hues-tints-tones-and-shades/" target="_blank" rel="external">Hues, Tints, Tones and Shades: What’s the Difference?</a>或更专业的一些文章。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>如果我们想指定整个<code>App</code>的<code>tint color</code>，则可以通过设置<code>window</code>的<code>tint color</code>。这样同一个<code>window</code>下的所有子视图都会继承此<code>tint color</code>。</p>
<p>当弹出一个<code>alert</code>或者<code>action sheet</code>时，<code>iOS7</code>会自动将后面视图的<code>tint color</code>变暗。此时，我们可以在自定义视图中重写<code>tintColorDidChange</code>方法来执行我们想要的操作。</p>
<p>有些复杂控件，可以有多个<code>tint color</code>，不同的<code>tint color</code>控件不同的部分。如上面提到的<code>UIProgressView</code>，又如<code>navigation bars</code>, <code>tab bars</code>, <code>toolbars</code>, <code>search bars</code>, <code>scope bars</code>等，这些控件的背景着色颜色可以使用<code>barTintColor</code>属性来处理。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/instp/UIView/tintColor" target="_blank" rel="external">UIView Class Reference</a></li>
<li><a href="https://www.shinobicontrols.com/blog/posts/2013/09/27/ios7-day-by-day-day-6-tint-color" target="_blank" rel="external">iOS7 Day-by-Day :: Day 6 :: Tint Color</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/TransitionGuide/AppearanceCustomization.html" target="_blank" rel="external">Appearance and Behavior</a></li>
<li><a href="https://en.wikipedia.org/wiki/Tints_and_shades" target="_blank" rel="external">Tints and shades</a></li>
<li><a href="http://www.craftsy.com/blog/2013/05/hues-tints-tones-and-shades/" target="_blank" rel="external">Hues, Tints, Tones and Shades: What’s the Difference?</a></li>
</ol>
<h2 id="Build-Configurations-in-Swift"><a href="#Build-Configurations-in-Swift" class="headerlink" title="Build Configurations in Swift"></a>Build Configurations in Swift</h2><p>在<code>Objective-C</code>中，我们经常使用预处理指令来帮助我们根据不同的平台执行不同的代码，以让我们的代码支持不同的平台，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#if TARGET_OS_IPHONE</div><div class="line">    #define MAS_VIEW UIView	    	    </div><div class="line">#elif TARGET_OS_MAC</div><div class="line">    #define MAS_VIEW NSView</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>在<code>swift</code>中，由于对<code>C</code>语言支持没有<code>Objective-C</code>来得那么友好(暂时不知<code>swift 2</code>到<code>C</code>的支持如何)，所以我们无法像在<code>Objective-C</code>中那样自如而舒坦地使用预处理指令。</p>
<p>不过，<code>swift</code>也提供了自己的方式来支持条件编译，即使用<code>build configurations</code>(构建配置)。<code>Build configurations</code>已经包含了字面量<code>true</code>和<code>false</code>，以及两个平台测试函数<code>os()</code>和<code>arch()</code>。</p>
<p>其中<code>os()</code>用于测试系统类型，可传入的参数包含<code>OSX</code>, <code>iOS</code>, <code>watchOS</code>，所以上面的代码在<code>swift</code>可改成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#if os(iOS)</div><div class="line">    typealias MAS_VIEW = UIView</div><div class="line">#elseif os(OSX)</div><div class="line">    typealias MAS_VIEW = NSView</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p><em>注：在WWDC 2014的<a href="https://developer.apple.com/videos/wwdc/2014/" target="_blank" rel="external">“Sharing code between iOS and OS X”</a>一节(session 233)中，Elizabeth Reid将这种方式称为Shimming</em></p>
<p>遗憾的是，<code>os()</code>只能检测系统类型，而无法检测系统的版本，所以这些工作只能放在运行时去处理。关于如何检测系统的版本,<code>Mattt Thompson</code>老大在它的<a href="http://nshipster.com/swift-system-version-checking/" target="_blank" rel="external">Swift System Version Checking</a>一文中给了我们答案。</p>
<p>我们再来看看<code>arch()</code>。<code>arch()</code>用于测试<code>CPU</code>的架构，可传入的值包括<code>x86_64</code>, <code>arm</code>, <code>arm64</code>, <code>i386</code>。需要注意的是<code>arch(arm)</code>对于<code>ARM 64</code>的设备来说，不会返回<code>true</code>。而<code>arch(i386)</code>在<code>32</code>位的<code>iOS</code>模拟器上编译时会返回<code>true</code>。</p>
<p>如果我们想自定义一些在调试期间使用的编译配置选项，则可以使用-D标识来告诉编译器，具体操作是在<code>&quot;Build Setting&quot;</code>-&gt;<code>&quot;Swift Compiler-Custom Flags&quot;</code>-&gt;<code>&quot;Other Swift Flags&quot;</code>-&gt;<code>&quot;Debug&quot;</code>中添加所需要的配置选项。如我们想添加常用的<code>DEGUB</code>选项，则可以在此加上<code>&quot;-D DEBUG&quot;</code>。这样我们就可以在代码中来执行一些<code>debug</code>与<code>release</code>时不同的操作，如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#if DEBUG</div><div class="line">    let totalSeconds = totalMinutes</div><div class="line">#else</div><div class="line">    let totalSeconds = totalMinutes * 60</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>一个简单的条件编译声明如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#if build configuration</div><div class="line">    statements</div><div class="line">#else</div><div class="line">    statements</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>当然，<code>statements</code>中可以包含<code>0</code>个或多个有效的<code>swift</code>的<code>statements</code>，其中可以包括表达式、语句、和控制流语句。另外，我们也可以使用<code>&amp;&amp;</code>和<code>||</code>操作符来组合多个<code>build configuration</code>，同时，可以使用!操作符来对<code>build configuration</code>取反，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#if build configuration &amp;&amp; !build configuration</div><div class="line">    statements</div><div class="line">#elseif build configuration</div><div class="line">	statements</div><div class="line">#else</div><div class="line">	statements</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>需要注意的是，在<code>swift</code>中，条件编译语句必须在语法上是有效的，因为即使这些代码不会被编译，<code>swift</code>也会对其进行语法检查。</p>
<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://www.giorgiocalderolla.com/cross-platform-swift.html" target="_blank" rel="external">Cross-platform Swift</a></li>
<li><a href="http://stackoverflow.com/questions/24403551/shimming-in-swift" target="_blank" rel="external">Shimming in Swift</a></li>
<li><a href="http://nshipster.com/swift-system-version-checking/" target="_blank" rel="external">Swift System Version Checking</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-XID_21" target="_blank" rel="external">Interacting with C APIs</a></li>
</ol>
<h2 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h2><p>在涉及到表单输入的界面中，我们通常需要监听一些键盘事件，并根据实际需要来执行相应的操作。如，键盘弹起时，要让我们的<code>UIScrollView</code>自动收缩，以能看到整个<code>UIScrollView</code>的内容。为此，在<code>UIWindow.h</code>中定义了如下<code>6</code>个通知常量，来配合键盘在不同时间点的事件处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">UIKeyboardWillShowNotification			// 键盘显示之前</div><div class="line">UIKeyboardDidShowNotification			// 键盘显示完成后</div><div class="line">UIKeyboardWillHideNotification			// 键盘隐藏之前</div><div class="line">UIKeyboardDidHideNotification			// 键盘消息之后</div><div class="line">UIKeyboardWillChangeFrameNotification	// 键盘大小改变之前</div><div class="line">UIKeyboardDidChangeFrameNotification	// 键盘大小改变之后</div></pre></td></tr></table></figure>
<p>这几个通知的<code>object</code>对象都是<code>nil</code>。而<code>userInfo</code>字典都包含了一些键盘的信息，主要是键盘的位置大小信息，我们可以通过使用以下的<code>key</code>来获取字典中对应的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 键盘在动画开始前的frame</div><div class="line">let UIKeyboardFrameBeginUserInfoKey: String</div><div class="line"></div><div class="line">// 键盘在动画线束后的frame</div><div class="line">let UIKeyboardFrameEndUserInfoKey: String</div><div class="line"></div><div class="line">// 键盘的动画曲线</div><div class="line">let UIKeyboardAnimationCurveUserInfoKey: String</div><div class="line"></div><div class="line">// 键盘的动画时间</div><div class="line">let UIKeyboardAnimationDurationUserInfoKey: String</div></pre></td></tr></table></figure>
<p>在此，我感兴趣的是键盘事件的调用顺序和如何获取键盘的大小，以适当的调整视图的大小。</p>
<p>从定义的键盘通知的类型可以看到，实际上我们关注的是三个阶段的键盘的事件：显示、隐藏、大小改变。在此我们设定两个<code>UITextField</code>，它们的键盘类型不同：一个是普通键盘，一个是数字键盘。我们监听所有的键盘事件，并打印相关日志(在此就不贴代码了)，直接看结果。</p>
<p>1) 当我们让<code>textField1</code>获取输入焦点时，打印的日志如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">keyboard will change</div><div class="line">keyboard will show</div><div class="line">keyboard did change</div><div class="line">keyboard did show</div></pre></td></tr></table></figure>
<p>2) 在不隐藏键盘的情况下，让<code>textField2</code>获取焦点，打印的日志如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">keyboard will change</div><div class="line">keyboard will show</div><div class="line">keyboard did change</div><div class="line">keyboard did show</div></pre></td></tr></table></figure>
<p>3) 再收起键盘，打印的日志如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">keyboard will change</div><div class="line">keyboard will hide</div><div class="line">keyboard did change</div><div class="line">keyboard did hide</div></pre></td></tr></table></figure>
<p>从上面的日志可以看出，不管是键盘的显示还是隐藏，都会发送大小改变的通知，而且是在<code>show</code>和<code>hide</code>的对应事件之前。而在大小不同的键盘之间切换时，除了发送<code>change</code>事件外，还会发送<code>show</code>事件(不发送<code>hide</code>事件)。</p>
<p>另外还有两点需要注意的是：</p>
<ol>
<li>如果是在两个大小相同的键盘之间切换，则不会发送任何消息</li>
<li>如果是普通键盘中类似于中英文键盘的切换，只要大小改变了，都会发送一组或多组与上面2)相同流程的消息</li>
</ol>
<p>了解了事件的调用顺序，我们就可以根据自己的需要来决定在哪个消息处理方法中来执行操作。为此，我们需要获取一些有用的信息。这些信息是封装在通知的<code>userInfo</code>中，通过上面常量<code>key</code>来获取相关的值。通常我们关心的是<code>UIKeyboardFrameEndUserInfoKey</code>，来获取动画完成后，键盘的<code>frame</code>，以此来计算我们的<code>scroll view</code>的高度。另外，我们可能希望<code>scroll view</code>高度的变化也是通过动画来过渡的，此时<code>UIKeyboardAnimationCurveUserInfoKey</code>和<code>UIKeyboardAnimationDurationUserInfoKey</code>就有用了。</p>
<p>我们可以通过以下方式来获取这些值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if let dict = notification.userInfo &#123;</div><div class="line">    var animationDuration: NSTimeInterval = 0</div><div class="line">    var animationCurve: UIViewAnimationCurve = .EaseInOut</div><div class="line">    var keyboardEndFrame: CGRect = CGRectZero</div><div class="line"></div><div class="line">    dict[UIKeyboardAnimationCurveUserInfoKey]?.getValue(&amp;animationCurve)</div><div class="line">    dict[UIKeyboardAnimationDurationUserInfoKey]?.getValue(&amp;animationDuration)</div><div class="line">    dict[UIKeyboardFrameEndUserInfoKey]?.getValue(&amp;keyboardEndFrame)</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上，<code>userInfo</code>中还有另外三个值，只不过这几个值从<code>iOS 3.2</code>开始就已经废弃不用了。所以我们不用太关注。</p>
<p>最后说下表单。一个表单界面看着比较简单，但交互和UI总是能想出各种方法来让它变得复杂，而且其实里面设计到的细节还是很多的。像我们金融类的<code>App</code>，通常都会涉及到大量的表单输入，所以如何做好，还是需要花一番心思的。空闲时，打算总结一下，写一篇文章。</p>
<h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIWindow_Class/#//apple_ref/doc/constant_group/Keyboard_Notification_User_Info_Keys" target="_blank" rel="external">UIWindow Class Reference</a></li>
</ol>
<h2 id="零碎"><a href="#零碎" class="headerlink" title="零碎"></a>零碎</h2><h3 id="自定义UIPickerView的行"><a href="#自定义UIPickerView的行" class="headerlink" title="自定义UIPickerView的行"></a>自定义UIPickerView的行</h3><p><code>UIPickerView</code>的主要内容实际上并不多，主要是一个<code>UIPickerView</code>类和对应的<code>UIPickerViewDelegate</code>，<code>UIPickerViewDataSource</code>协议，分别表示代理和数据源。在此不细说这些，只是解答我们遇到的一个小需求。</p>
<p>通常，<code>UIPickerView</code>是可以定义多列内容的，比如年、月、日三列，这些列之间相互不干扰，可以自已滚自己的，不碍别人的事。不过，我们有这么一个需求，也是有三列，但这三列需要一起滚。嗯，这个就需要另行处理了。</p>
<p>在<code>UIPickerViewDelegate</code>中，声明了下面这样一个代理方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (UIView *)pickerView:(UIPickerView *)pickerView</div><div class="line">        viewForRow:(NSInteger)row</div><div class="line">      forComponent:(NSInteger)component</div><div class="line">       reusingView:(UIView *)view</div></pre></td></tr></table></figure>
<p>我们通过这个方法就可以来自定义行的视图。时间不早，废话就不多说了，直接上代码吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (UIView *)pickerView:(UIPickerView *)pickerView viewForRow:(NSInteger)row forComponent:(NSInteger)component reusingView:(UIView *)view &#123;</div><div class="line">    PickerViewCell *pickerCell = (PickerViewCell *)view;</div><div class="line"></div><div class="line">    if (!pickerCell) &#123;</div><div class="line">        NSInteger column = 3;</div><div class="line">        pickerCell = [[PickerViewCell alloc] initWithFrame:(CGRect)&#123;CGPointZero, [UIScreen mainScreen].bounds.size.width, 45.0f&#125; column:column];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    [pickerCell setLabelTexts:@[...]];</div><div class="line"></div><div class="line">    return pickerCell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们定义了一个<code>PickerViewCell</code>视图，里面根据我们的传入的<code>column</code>参数来等分放置<code>column</code>个<code>UILabel</code>，并通过<code>setLabelTexts</code>来设置每个<code>UILabel</code>的文本。当然，我们也可以在<code>PickerViewCell</code>去定义<code>UILabel</code>的外观显示。就是这么简单。</p>
<p>不过，还有个需要注意的就是，虽然看上去是显示了<code>3</code>列，但实际上是按<code>1</code>列来处理的，所以下面的实现应该是返回<code>1</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView &#123;</div><div class="line">    return 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIPickerViewDelegate_Protocol/" target="_blank" rel="external">UIPickerViewDelegate Protocol Reference</a></li>
</ol>
<h3 id="Swift中”-AnyObject-does-not-have-a-member-named-generator”-问题的处理"><a href="#Swift中”-AnyObject-does-not-have-a-member-named-generator”-问题的处理" class="headerlink" title="Swift中”[AnyObject]? does not have a member named generator” 问题的处理"></a>Swift中”[AnyObject]? does not have a member named generator” 问题的处理</h3><p>有个小需求，需要遍历当前导航控制器栈的所有<code>ViewController</code>。<code>UINavigationController</code>类自身的<code>viewControllers</code>属性返回的是一个<code>[AnyObject]!</code>数组，不过由于我的导航控制器本身有可能是<code>nil</code>，所以我获取到的<code>ViewController</code>数组如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var myViewControllers: [AnyObject]? = navigationController?.viewControllers</div></pre></td></tr></table></figure>
<p>获取到的<code>myViewControllers</code>是一个<code>[AnyObject]?</code>可选类型，这时如果我直接去遍历<code>myViewControllers</code>，如下代码所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for controller in myViewControllers &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译器会报错，提示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[AnyObject]? does not have a member named &quot;Generator&quot;</div></pre></td></tr></table></figure>
<p>实际上，不管是<code>[AnyObject]?</code>还是其它的诸如<code>[String]?</code>类型，都会报这个错。其原因是可选类型只是个容器，它与其所包装的值是不同的类型，也就是说<code>[AnyObject]</code>是一个数组类型，但<code>[AnyObject]?</code>并不是数组类型。我们可以迭代一个数组，但不是迭代一个非集合类型。</p>
<p>在<a href="http://stackoverflow.com/questions/26852656/loop-through-anyobject-results-in-does-not-have-a-member-named-generator" target="_blank" rel="external">stackoverflow</a>上有这样一个有趣的比方，我犯懒就直接贴出来了：</p>
<blockquote>
<p>To understand the difference, let me make a real life example: you buy a new TV on ebay, the package is shipped to you, the first thing you do is to check if the package (the optional) is empty (nil). Once you verify that the TV is inside, you have to unwrap it, and put the box aside. You cannot use the TV while it’s in the package. Similarly, an optional is a container: it is not the value it contains, and it doesn’t have the same type. It can be empty, or it can contain a valid value.</p>
</blockquote>
<p>所以，这里的处理应该是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if let controllers = myViewControllers &#123;</div><div class="line">    for controller in controllers &#123;</div><div class="line">        ......</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    </p>
<h4 id="参考-4"><a href="#参考-4" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a href="http://stackoverflow.com/questions/26852656/loop-through-anyobject-results-in-does-not-have-a-member-named-generator" target="_blank" rel="external">Loop through [AnyObject]? results in does not have a member named generator</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/05/31/ios-techset-2/" itemprop="url">
                  iOS知识小集 第2期(2015.05.31)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-05-31T23:50:54+08:00" content="2015-05-31">
              2015-05-31
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/techset/" itemprop="url" rel="index">
                    <span itemprop="name">知识小集</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>换了个厂子，还不到1个月。哎，着实是累啊，基本上是996.5的节奏，只会更多。加班把我快加吐了，但人在江湖，身不由已啊。为了讨口饭吃，命也不要了。谁让咱只是个臭写代码的呢。不过加班是多，只是长得太丑，所有没办法，没时间也得抽时间来学习。不然，饭都没得吃了，还得养家糊口呢。</p>
<p>本期总结的内容不是很多，主要有以下几个问题：</p>
<ol>
<li>使用<code>UIVisualEffectView</code>为视图添加特殊效果</li>
<li><code>Nullability Annotations</code></li>
<li><code>weak</code>的生命周期</li>
</ol>
<h2 id="使用UIVisualEffectView为视图添加特殊效果"><a href="#使用UIVisualEffectView为视图添加特殊效果" class="headerlink" title="使用UIVisualEffectView为视图添加特殊效果"></a>使用UIVisualEffectView为视图添加特殊效果</h2><p>在<code>iOS 8</code>后，苹果开放了不少创建特效的接口，其中就包括创建毛玻璃(<code>blur</code>)的接口。</p>
<p>通常要想创建一个特殊效果(如<code>blur</code>效果)，可以创建一个<code>UIVisualEffectView</code>视图对象，这个对象提供了一种简单的方式来实现复杂的视觉效果。这个可以把这个对象看作是效果的一个容器，实际的效果会影响到该视图对象底下的内容，或者是添加到该视图对象的<code>contentView</code>中的内容。</p>
<p>我们举个例子来看看如果使用<code>UIVisualEffectView</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let bgView: UIImageView = UIImageView(image: UIImage(named: &quot;visual&quot;))</div><div class="line">bgView.frame = self.view.bounds</div><div class="line">self.view.addSubview(bgView)</div><div class="line"></div><div class="line">let blurEffect: UIBlurEffect = UIBlurEffect(style: .Light)</div><div class="line">let blurView: UIVisualEffectView = UIVisualEffectView(effect: blurEffect)</div><div class="line">blurView.frame = CGRectMake(50.0, 50.0, self.view.frame.width - 100.0, 200.0)</div><div class="line">self.view.addSubview(blurView)</div></pre></td></tr></table></figure>
<p>这段代码是在当前视图控制器上添加了一个<code>UIImageView</code>作为背景图。然后在视图的一小部分中使用了<code>blur</code>效果。其效果如下所示：</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/blur%20effect.png?raw=true" alt="image"></p>
<p>我们可以看到<code>UIVisualEffectView</code>还是非常简单的。需要注意是的，不应该直接添加子视图到<code>UIVisualEffectView</code>视图中，而是应该添加到<code>UIVisualEffectView</code>对象的<code>contentView</code>中。</p>
<p>另外，尽量避免将<code>UIVisualEffectView</code>对象的<code>alpha</code>值设置为小于<code>1.0</code>的值，因为创建半透明的视图会导致系统在离屏渲染时去对<code>UIVisualEffectView</code>对象及所有的相关的子视图做混合操作。这不但消耗<code>CPU/GPU</code>，也可能会导致许多效果显示不正确或者根本不显示。</p>
<p>我们在上面看到，初始化一个<code>UIVisualEffectView</code>对象的方法是<code>UIVisualEffectView(effect: blurEffect)</code>，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">init(effect effect: UIVisualEffect)</div></pre></td></tr></table></figure>
<p>这个方法的参数是一个<code>UIVisualEffect</code>对象。我们查看官方文档，可以看到在UIKit中，定义了几个专门用来创建视觉特效的，它们分别是<code>UIVisualEffect</code>、<code>UIBlurEffect</code>和<code>UIVibrancyEffect</code>。它们的继承层次如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSObject</div><div class="line">	| -- UIVisualEffect</div><div class="line">		| -- UIBlurEffect</div><div class="line">		| -- UIVibrancyEffect</div></pre></td></tr></table></figure>
<p><code>UIVisualEffect</code>是一个继承自<code>NSObject</code>的创建视觉效果的基类，然而这个类除了继承自<code>NSObject</code>的属性和方法外，没有提供任何新的属性和方法。其主要目的是用于初始化<code>UIVisualEffectView</code>，在这个初始化方法中可以传入<code>UIBlurEffect</code>或者<code>UIVibrancyEffect</code>对象。</p>
<p>一个<code>UIBlurEffect</code>对象用于将<code>blur</code>(毛玻璃)效果应用于<code>UIVisualEffectView</code>视图下面的内容。如上面的示例所示。不过，这个对象的效果并不影响<code>UIVisualEffectView</code>对象的<code>contentView</code>中的内容。</p>
<p><code>UIBlurEffect</code>主要定义了三种效果，这些效果由枚举<code>UIBlurEffectStyle</code>来确定，该枚举的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">enum UIBlurEffectStyle : Int &#123;</div><div class="line">    case ExtraLight</div><div class="line">    case Light</div><div class="line">    case Dark</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其主要是根据色调(<code>hue</code>)来确定特效视图与底部视图的混合。</p>
<p>与<code>UIBlurEffect</code>不同的是，<code>UIVibrancyEffect</code>主要用于放大和调整<code>UIVisualEffectView</code>视图下面的内容的颜色，同时让<code>UIVisualEffectView</code>的<code>contentView</code>中的内容看起来更加生动。通常<code>UIVibrancyEffect</code>对象是与<code>UIBlurEffect</code>一起使用，主要用于处理在<code>UIBlurEffect</code>特效上的一些显示效果。接上面的代码，我们看看在blur的视图上添加一些新的特效，如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let vibrancyView: UIVisualEffectView = UIVisualEffectView(effect: UIVibrancyEffect(forBlurEffect: blurEffect))</div><div class="line">vibrancyView.setTranslatesAutoresizingMaskIntoConstraints(false)</div><div class="line">blurView.contentView.addSubview(vibrancyView)</div><div class="line"></div><div class="line">var label: UILabel = UILabel()</div><div class="line">label.setTranslatesAutoresizingMaskIntoConstraints(false)</div><div class="line">label.text = &quot;Vibrancy Effect&quot;</div><div class="line">label.font = UIFont(name: &quot;HelveticaNeue-Bold&quot;, size: 30)</div><div class="line">label.textAlignment = .Center</div><div class="line">label.textColor = UIColor.whiteColor()</div><div class="line">vibrancyView.contentView.addSubview(label)</div></pre></td></tr></table></figure>
<p>其效果如下图所示：</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Vibrancy%20effect.png?raw=true" alt="image"></p>
<p><code>vibrancy</code>特效是取决于颜色值的。所有添加到<code>contentView</code>的子视图都必须实现<code>tintColorDidChange</code>方法并更新自己。需要注意的是，我们使用<code>UIVibrancyEffect(forBlurEffect:)</code>方法创建<code>UIVibrancyEffect</code>时，参数<code>blurEffect</code>必须是我们想加效果的那个<code>blurEffect</code>，否则可能不是我们想要的效果。</p>
<p>另外，<code>UIVibrancyEffect</code>还提供了一个类方法<code>notificationCenterVibrancyEffect</code>，其声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class func notificationCenterVibrancyEffect() -&gt; UIVibrancyEffect!</div></pre></td></tr></table></figure>
<p>这个方法创建一个用于通知中心的<code>Today</code>扩展的<code>vibrancy</code>特效。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIVisualEffectView/" target="_blank" rel="external">UIVisualEffectView Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIVisualEffect_class/index.html#//apple_ref/occ/cl/UIVisualEffect" target="_blank" rel="external">UIVisualEffect Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIVisualEffect_class/index.html#//apple_ref/occ/cl/UIVisualEffect" target="_blank" rel="external">UIBlurEffect Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIVibrancyEffect/" target="_blank" rel="external">UIVibrancyEffect Class Reference</a></li>
<li><a href="http://swiftoverload.com/tag/uivisualeffectview/" target="_blank" rel="external">UIVisualEffect – Swift Tutorial</a></li>
<li><a href="http://idrawcode.tumblr.com/post/101925733632/ios-8-uivisualeffect" target="_blank" rel="external">iOS 8: UIVisualEffect</a></li>
</ol>
<h2 id="Pointer-is-missing-a-nullability-type-specifier-nonnull-or-nullable-问题的处理-–-Nullability-Annotations"><a href="#Pointer-is-missing-a-nullability-type-specifier-nonnull-or-nullable-问题的处理-–-Nullability-Annotations" class="headerlink" title="Pointer is missing a nullability type specifier (nonnull or nullable)问题的处理 – Nullability Annotations"></a>Pointer is missing a nullability type specifier (<strong>nonnull or </strong>nullable)问题的处理 – Nullability Annotations</h2><p>最近在用<code>Xcode 6.3</code>写代码，一些涉及到对象的代码会报如下编译器警告：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Pointer is missing a nullability type specifier (_nonnull or _nullable)</div></pre></td></tr></table></figure>
<p>于是<code>google</code>了一下，发现这是<code>Xcode 6.3</code>的一个新特性，即<strong>nullability annotations</strong>。</p>
<h3 id="Nullability-Annotations"><a href="#Nullability-Annotations" class="headerlink" title="Nullability Annotations"></a>Nullability Annotations</h3><p>我们都知道在<code>swift</code>中，可以使用<code>!</code>和<code>?</code>来表示一个对象是<code>optional</code>的还是<code>non-optional</code>，如<code>view?</code>和<code>view!</code>。而在<code>Objective-C</code>中则没有这一区分，<code>view</code>即可表示这个对象是<code>optional</code>，也可表示是<code>non-optional</code>。这样就会造成一个问题：在<code>Swift</code>与<code>Objective-C</code>混编时，<code>Swift</code>编译器并不知道一个<code>Objective-C</code>对象到底是<code>optional</code>还是<code>non-optional</code>，因此这种情况下编译器会隐式地将<code>Objective-C</code>的对象当成是<code>non-optional</code>。</p>
<p>为了解决这个问题，苹果在<code>Xcode 6.3</code>引入了一个<code>Objective-C</code>的新特性：<code>nullability annotations</code>。这一新特性的核心是两个新的类型注释：<strong>__nullable</strong>和<strong>__nonnull</strong>。从字面上我们可以猜到，<strong>__nullable</strong>表示对象可以是<code>NULL</code>或<code>nil</code>，而<strong>__nonnull</strong>表示对象不应该为空。当我们不遵循这一规则时，编译器就会给出警告。</p>
<p>我们来看看以下的实例，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">@interface TestNullabilityClass ()</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSArray * items;</div><div class="line"></div><div class="line">- (id)itemWithName:(NSString * __nonnull)name;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation TestNullabilityClass</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">- (void)testNullability &#123;</div><div class="line">    [self itemWithName:nil];	// 编译器警告：Null passed to a callee that requires a non-null argument</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)itemWithName:(NSString * __nonnull)name &#123;</div><div class="line">    return nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>不过这只是一个警告，程序还是能编译通过并运行。</p>
<p>事实上，在任何可以使用<code>const</code>关键字的地方都可以使用<code>__nullable</code>和<code>__nonnull</code>，不过这两个关键字仅限于使用在指针类型上。而在方法的声明中，我们还可以使用不带下划线的<code>nullable</code>和<code>nonnull</code>，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (nullable id)itemWithName:(NSString * nonnull)name</div></pre></td></tr></table></figure>
<p>在属性声明中，也增加了两个相应的特性，因此上例中的items属性可以如下声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, copy, nonnull) NSArray * items;</div></pre></td></tr></table></figure>
<p>当然也可以用以下这种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, copy) NSArray * __nonnull items;</div></pre></td></tr></table></figure>
<p>推荐使用<code>nonnull</code>这种方式，这样可以让属性声明看起来更清晰。</p>
<h3 id="Nonnull区域设置-Audited-Regions"><a href="#Nonnull区域设置-Audited-Regions" class="headerlink" title="Nonnull区域设置(Audited Regions)"></a>Nonnull区域设置(Audited Regions)</h3><p>如果需要每个属性或每个方法都去指定<code>nonnull</code>和<code>nullable</code>，是一件非常繁琐的事。苹果为了减轻我们的工作量，专门提供了两个宏：<code>NS_ASSUME_NONNULL_BEGIN</code>和<code>NS_ASSUME_NONNULL_END</code>。在这两个宏之间的代码，所有简单指针对象都被假定为<code>nonnull</code>，因此我们只需要去指定那些<code>nullable</code>的指针。如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">NS_ASSUME_NONNULL_BEGIN</div><div class="line"></div><div class="line">@interface TestNullabilityClass ()</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSArray * items;</div><div class="line"></div><div class="line">- (id)itemWithName:(nullable NSString *)name;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">NS_ASSUME_NONNULL_END</div></pre></td></tr></table></figure>
<p>在上面的代码中，<code>items</code>属性默认是<code>non null</code>的，<code>itemWithName:</code>方法的返回值也是<code>non null</code>，而参数是指定为<code>nullable</code>的。</p>
<p>不过，为了安全起见，苹果还制定了几条规则：</p>
<ol>
<li>typedef定义的类型的<code>nullability</code>特性通常依赖于上下文，即使是在<code>Audited Regions</code>中，也不能假定它为<code>nonnull</code>。</li>
<li>复杂的指针类型(如id <em>)必须显示去指定是<code>nonnull</code>还是<code>nullable</code>。例如，指定一个指向nullable对象的<code>nonnull</code>指针，可以使用`”__nullable id </em> __nonnull”`。</li>
<li>我们经常使用的<code>NSError **</code>通常是被假定为一个指向<code>nullable NSError</code>对象的<code>nullable</code>指针。</li>
</ol>
<h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>因为<code>Nullability Annotations</code>是<code>Xcode 6.3</code>新加入的，所以我们需要考虑之前的老代码。实际上，苹果已以帮我们处理好了这种兼容问题，我们可以安全地使用它们：</p>
<ol>
<li>老代码仍然能正常工作，即使对<code>nonnull</code>对象使用了<code>nil</code>也没有问题。</li>
<li>老代码在需要和<code>swift</code>混编时，在新的<code>swift</code>编译器下会给出一个警告。</li>
<li><code>nonnull</code>不会影响性能。事实上，我们仍然可以在运行时去判断我们的对象是否为<code>nil</code>。</li>
</ol>
<p>事实上，我们可以将<code>nonnull/nullable</code>与我们的断言和异常一起看待，其需要处理的问题都是同一个：违反约定是一个程序员的错误。特别是，返回值是我们可控的东西，如果返回值是<code>nonnull</code>的，则我们不应该返回<code>nil</code>，除非是为了向后兼容。</p>
<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://developer.apple.com/swift/blog/?id=25" target="_blank" rel="external">Nullability and Objective-C</a></li>
</ol>
<h2 id="weak的生命周期"><a href="#weak的生命周期" class="headerlink" title="weak的生命周期"></a>weak的生命周期</h2><p>我们都知道<code>weak</code>表示的是一个弱引用，这个引用不会增加对象的引用计数，并且在所指向的对象被释放之后，<code>weak</code>指针会被设置的为<code>nil</code>。<code>weak</code>引用通常是用于处理循环引用的问题，如代理及block的使用中，相对会较多的使用到<code>weak</code>。</p>
<p>之前对weak的实现略有了解，知道它的一个基本的生命周期，但具体是怎么实现的，了解得不是太清晰。今天又翻了翻《Objective-C高级编程》关于<code>__weak</code>的讲解，在此做个笔记。</p>
<p>我们以下面这行代码为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    id __weak obj1 = obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我们初始化一个<code>weak</code>变量时，<code>runtime</code>会调用<code>objc_initWeak</code>函数。这个函数在<code>Clang</code>中的声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id objc_initWeak(id *object, id value);</div></pre></td></tr></table></figure>
<p>其具体实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">id objc_initWeak(id *object, id value)</div><div class="line">&#123;</div><div class="line">    *object = 0;</div><div class="line">    return objc_storeWeak(object, value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>示例代码轮换成编译器的模拟代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">id obj1;</div><div class="line">objc_initWeak(&amp;obj1, obj);</div></pre></td></tr></table></figure>
<p>因此，这里所做的事是先将<code>obj1</code>初始化为<code>0(nil)</code>，然后将<code>obj1</code>的地址及<code>obj</code>作为参数传递给<code>objc_storeWeak</code>函数。</p>
<p><code>objc_initWeak</code>函数有一个前提条件：就是<code>object</code>必须是一个没有被注册为<code>__weak</code>对象的有效指针。而<code>value</code>则可以是<code>null</code>，或者指向一个有效的对象。</p>
<p>如果<code>value</code>是一个空指针或者其指向的对象已经被释放了，则<code>object</code>是<code>zero-initialized</code>的。否则，<code>object</code>将被注册为一个指向<code>value</code>的<code>__weak</code>对象。而这事应该是<code>objc_storeWeak</code>函数干的。<code>objc_storeWeak</code>的函数声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id objc_storeWeak(id *location, id value);</div></pre></td></tr></table></figure>
<p>其具体实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">id objc_storeWeak(id *location, id newObj)</div><div class="line">&#123;</div><div class="line">    id oldObj;</div><div class="line">    SideTable *oldTable;</div><div class="line">    SideTable *newTable;</div><div class="line">    ......</div><div class="line"></div><div class="line">    // Acquire locks for old and new values.</div><div class="line">    // Order by lock address to prevent lock ordering problems. </div><div class="line">    // Retry if the old value changes underneath us.</div><div class="line"> retry:</div><div class="line">    oldObj = *location;</div><div class="line"></div><div class="line">    oldTable = SideTable::tableForPointer(oldObj);</div><div class="line">    newTable = SideTable::tableForPointer(newObj);</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">    if (*location != oldObj) &#123;</div><div class="line">        OSSpinLockUnlock(lock1);</div><div class="line"></div><div class="line">#if SIDE_TABLE_STRIPE &gt; 1</div><div class="line">        if (lock1 != lock2) OSSpinLockUnlock(lock2);</div><div class="line">#endif</div><div class="line">        goto retry;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (oldObj) &#123;</div><div class="line">        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (newObj) &#123;</div><div class="line">        newObj = weak_register_no_lock(&amp;newTable-&gt;weak_table, newObj,location);</div><div class="line">        </div><div class="line">        // weak_register_no_lock returns NULL if weak store should be rejected</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Do not set *location anywhere else. That would introduce a race.</div><div class="line">    *location = newObj;</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">    return newObj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们撇开源码中各种锁操作，来看看这段代码都做了些什么。在此之前，我们先来了解下<code>weak</code>表和<code>SideTable</code>。</p>
<p><code>weak</code>表是一个弱引用表，实现为一个<code>weak_table_t</code>结构体，存储了某个对象相关的的所有的弱引用信息。其定义如下(具体定义在<a href="http://www.opensource.apple.com/source/objc4/objc4-646/runtime/objc-weak.h" target="_blank" rel="external">objc-weak.h</a>中)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct weak_table_t &#123;</div><div class="line">    weak_entry_t *weak_entries;</div><div class="line">    size_t    num_entries;</div><div class="line">    ......</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中<code>weak_entry_t</code>是存储在弱引用表中的一个内部结构体，它负责维护和存储指向一个对象的所有弱引用<code>hash</code>表。其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">struct weak_entry_t &#123;</div><div class="line"></div><div class="line">    DisguisedPtr&lt;objc_object&gt; referent;</div><div class="line">    union &#123;</div><div class="line">        struct &#123;</div><div class="line">            weak_referrer_t *referrers;</div><div class="line">            uintptr_t        out_of_line : 1;</div><div class="line">            ......</div><div class="line">        &#125;;</div><div class="line">        </div><div class="line">        struct &#123;</div><div class="line">            // out_of_line=0 is LSB of one of these (don&apos;t care which)</div><div class="line">            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中<code>referent</code>是被引用的对象，即示例代码中的<code>obj</code>对象。下面的<code>union</code>即存储了所有指向该对象的弱引用。由注释可以看到，当<code>out_of_line</code>等于<code>0</code>时，<code>hash</code>表被一个数组所代替。另外，所有的弱引用对象的地址都是存储在<code>weak_referrer_t</code>指针的地址中。其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef objc_object ** weak_referrer_t;</div></pre></td></tr></table></figure>
<p><code>SideTable</code>是一个用<code>C++</code>实现的类，它的具体定义在<a href="http://opensource.apple.com/source/objc4/objc4-532.2/runtime/NSObject.mm" target="_blank" rel="external">NSObject.mm</a>中，我们来看看它的一些成员变量的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class SideTable &#123;</div><div class="line"></div><div class="line">private:</div><div class="line">    static uint8_t table_buf[SIDE_TABLE_STRIPE * SIDE_TABLE_SIZE];</div><div class="line"></div><div class="line">public:</div><div class="line">    RefcountMap refcnts;</div><div class="line">    weak_table_t weak_table;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>RefcountMap refcnts</code>，大家应该能猜到这个做什么用的吧？看着像是引用计数什么的。哈哈，貌似就是啊，这东东存储了一个对象的引用计数的信息。当然，我们在这里不去探究它，我们关注的是<code>weak_table</code>。这个成员变量指向的就是一个对象的<code>weak</code>表。</p>
<p>了解了<code>weak</code>表和<code>SideTable</code>，让我们再回过头来看看<code>objc_storeWeak</code>。首先是根据<code>weak</code>指针找到其指向的老的对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">oldObj = *location;</div></pre></td></tr></table></figure>
<p>然后获取到与新旧对象相关的SideTable对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">oldTable = SideTable::tableForPointer(oldObj);</div><div class="line">newTable = SideTable::tableForPointer(newObj);</div></pre></td></tr></table></figure>
<p>下面要做的就是在老对象的<code>weak</code>表中移除指向信息，而在新对象的<code>weak</code>表中建立关联信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (oldObj) &#123;</div><div class="line">    weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</div><div class="line">&#125;</div><div class="line">if (newObj) &#123;</div><div class="line">    newObj = weak_register_no_lock(&amp;newTable-&gt;weak_table, newObj,location);</div><div class="line">    // weak_register_no_lock returns NULL if weak store should be rejected</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来让弱引用指针指向新的对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*location = newObj;</div></pre></td></tr></table></figure>
<p>最后会返回这个新对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">return newObj;</div></pre></td></tr></table></figure>
<p><code>objc_storeWeak</code>的基本实现就是这样。当然，在<code>objc_initWeak</code>中调用<code>objc_storeWeak</code>时，老对象是空的，所有不会执行<code>weak_unregister_no_lock</code>操作。</p>
<p>而当<code>weak</code>引用指向的对象被释放时，又是如何去处理<code>weak</code>指针的呢？当释放对象时，其基本流程如下：</p>
<ol>
<li>调用<code>objc_release</code></li>
<li>因为对象的引用计数为<code>0</code>，所以执行<code>dealloc</code></li>
<li>在<code>dealloc</code>中，调用了<code>_objc_rootDealloc</code>函数</li>
<li>在<code>_objc_rootDealloc</code>中，调用了<code>object_dispose</code>函数</li>
<li>调用<code>objc_destructInstance</code></li>
<li>最后调用<code>objc_clear_deallocating</code></li>
</ol>
<p>我们重点关注一下最后一步，<code>objc_clear_deallocating</code>的具体实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">void objc_clear_deallocating(id obj) </div><div class="line">&#123;</div><div class="line">    ......</div><div class="line"></div><div class="line">    SideTable *table = SideTable::tableForPointer(obj);</div><div class="line">    </div><div class="line">    // clear any weak table items</div><div class="line">    // clear extra retain count and deallocating bit</div><div class="line">    // (fixme warn or abort if extra retain count == 0 ?)</div><div class="line">    OSSpinLockLock(&amp;table-&gt;slock);</div><div class="line"></div><div class="line">    if (seen_weak_refs) &#123;</div><div class="line">        arr_clear_deallocating(&amp;table-&gt;weak_table, obj);</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，在这个函数中，首先取出对象对应的<code>SideTable</code>实例，如果这个对象有关联的弱引用，则调用<code>arr_clear_deallocating</code>来清除对象的弱引用信息。我们来看看<code>arr_clear_deallocating</code>具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">PRIVATE_EXTERN void arr_clear_deallocating(weak_table_t *weak_table, id referent) &#123;</div><div class="line">    &#123;</div><div class="line">        weak_entry_t *entry = weak_entry_for_referent(weak_table, referent);</div><div class="line"></div><div class="line">        if (entry == NULL) &#123;</div><div class="line">            ......</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // zero out references</div><div class="line">        for (int i = 0; i &lt; entry-&gt;referrers.num_allocated; ++i) &#123;</div><div class="line"></div><div class="line">            id *referrer = entry-&gt;referrers.refs[i].referrer;</div><div class="line">            </div><div class="line">            if (referrer) &#123;</div><div class="line">                if (*referrer == referent) &#123;</div><div class="line">                    *referrer = nil;</div><div class="line">                &#125;</div><div class="line">                else if (*referrer) &#123;</div><div class="line">                    objc_inform(&quot;_weak variable @ %p holds %p instead of %p\n&quot;, referrer, *referrer, referent);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        weak_entry_remove_no_lock(weak_table, entry);</div><div class="line">        weak_table-&gt;num_weak_refs--;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数首先是找出对象对应的<code>weak_entry_t</code>链表，然后挨个将弱引用置为<code>nil</code>。最后清理对象的记录。</p>
<p>通过上面的描述，我们基本能了解一个<code>weak</code>引用从生到死的过程。从这个流程可以看出，一个<code>weak</code>引用的处理涉及各种查表、添加与删除操作，还是有一定消耗的。所以如果大量使用<code>__weak</code>变量的话，会对性能造成一定的影响。那么，我们应该在什么时候去使用<code>weak</code>呢？《Objective-C高级编程》给我们的建议是只在避免循环引用的时候使用<code>__weak</code>修饰符。</p>
<p>另外，在<code>clang</code>中，还提供了不少关于<code>weak</code>引用的处理函数。如<code>objc_loadWeak</code>,<code>objc_destroyWeak</code>, <code>objc_moveWeak</code>等，我们可以在苹果的开源代码中找到相关的实现。等有时间，我再好好研究研究。</p>
<h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><ol>
<li>《Objective-C高级编程》1.4: __weak修饰符</li>
<li><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html" target="_blank" rel="external">Clang 3.7 documentation - Objective-C Automatic Reference Counting (ARC)</a></li>
<li><a href="http://opensource.apple.com/source/objc4/objc4-532.2/runtime/NSObject.mm" target="_blank" rel="external">apple opensource - NSObject.mm</a></li>
</ol>
<h2 id="零碎"><a href="#零碎" class="headerlink" title="零碎"></a>零碎</h2><h3 id="CAGradientLayer"><a href="#CAGradientLayer" class="headerlink" title="CAGradientLayer"></a>CAGradientLayer</h3><p><code>CAGradientLayer</code>类是用于在其背景色上绘制一个颜色渐变，以填充层的整个形状，包括圆角。这个类继承自<code>CALayer</code>类，使用起来还是很方便的。</p>
<p>与<code>Quartz 2D</code>中的渐变处理类似，一个渐变有一个起始位置(<code>startPoint</code>)和一个结束位置(<code>endPoint</code>)，在这两个位置之间，我们可以指定一组颜色值(<code>colors</code>，元素是<code>CGColorRef</code>对象)，可以是两个，也可以是多个，每个颜色值会对应一个位置(<code>locations</code>)。另外，渐变还分为轴向渐变和径向渐变。</p>
<p>我们写个实例来看看<code>CAGradientLayer</code>的具体使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CAGradientLayer *layer = [CAGradientLayer layer];</div><div class="line">layer.startPoint = (CGPoint)&#123;0.5f, 0.0f&#125;;</div><div class="line">layer.endPoint = (CGPoint)&#123;0.5f, 1.0f&#125;;</div><div class="line">layer.colors = [NSArray arrayWithObjects:(id)[UIColor blueColor].CGColor, (id)[UIColor redColor].CGColor, (id)[UIColor greenColor].CGColor, nil];</div><div class="line">layer.locations = @[@0.0f, @0.6f, @1.0f];</div><div class="line">layer.frame = self.view.layer.bounds;</div><div class="line"></div><div class="line">[self.view.layer insertSublayer:layer atIndex:0];</div></pre></td></tr></table></figure>
<h4 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CAGradientLayer_class/" target="_blank" rel="external">CAGradientLayer Class Reference</a></li>
</ol>
<h3 id="Xcode中Ineligible-Devices的处理"><a href="#Xcode中Ineligible-Devices的处理" class="headerlink" title="Xcode中Ineligible Devices的处理"></a>Xcode中Ineligible Devices的处理</h3><p>换了台新电脑，装了个<code>Xcode 6.3</code>，整了个新证书和<code>profile</code>，然后打开<code>Xcode</code>，连上手机。额，然后发现设备居然被标识为<code>Ineligible Devices</code>，没认出来。情况类似于下图：</p>
<p><img src="http://i.stack.imgur.com/CFOSG.png" alt="image"></p>
<p>电脑是受信任的，证书和<code>profile</code>也都是<code>OK</code>的。试了几次重启<code>Xcode</code>和重新连接手机，无效。设备就是选不了。最后是在<code>Product</code>-&gt;<code>Destination</code>里面才选中这个设备的。不过在工具栏还是不能选择，郁闷，求解。</p>
<h3 id="iOS-7后隐藏UITextField的光标"><a href="#iOS-7后隐藏UITextField的光标" class="headerlink" title="iOS 7后隐藏UITextField的光标"></a>iOS 7后隐藏UITextField的光标</h3><p>新项目只支持<code>iOS 7</code>后，很多事情变得简单多了，就像隐藏<code>UITextField</code>的光标一样，就简单的一句话：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">textFiled.tintColor = [UIColor clearColor];</div></pre></td></tr></table></figure>
<p>通常我们用<code>UIPickerView</code>作为我们的<code>UITextField</code>的<code>inputView</code>时，我们是需要隐藏光标的。当然，如果想换个光标颜色，也是这么处理。</p>
<p>这么处理的有个遗留问题是：通常我们使用<code>UIPickerView</code>作为<code>UITextField</code>的<code>inputView</code>时， 并不希望去执行各种菜单操作(全选、复制、粘帖)，但只是去设置<code>UITextField</code>的<code>tintColor</code>时，我们仍然可以执行这边操作，所以需要加额外的处理。这个问题，我们可以这样处理：在<code>textFieldShouldBeginEditing:</code>中，我们把<code>UITextField</code>的<code>userInteractionEnabled</code>设置为<code>NO</code>，然后在<code>textFieldShouldEndEditing:</code>，将将这个值设置回来。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (BOOL)textFieldShouldBeginEditing:(UITextField *)textField &#123;</div><div class="line">    textField.userInteractionEnabled = NO;</div><div class="line">    return YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)textFieldShouldEndEditing:(UITextField *)textField &#123;</div><div class="line">    textField.userInteractionEnabled = YES;</div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样就<code>OK</code>了。当然这只是我们当前使用的一种处理方式，还有其它的方法，直接<code>google</code>或者<code>stackoverflow</code>吧。</p>
<h3 id="iOS-7后UIAlertView中文字左对齐问题"><a href="#iOS-7后UIAlertView中文字左对齐问题" class="headerlink" title="iOS 7后UIAlertView中文字左对齐问题"></a>iOS 7后UIAlertView中文字左对齐问题</h3><p>在<code>iOS 7</code>之前，如果我们想要让<code>UIAlertView</code>中的文字居左显示的话，可以使用以下这段代码来处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for (UIView *view in alert.subviews) &#123;</div><div class="line">    if([[view class] isSubclassOfClass:[UILabel class]]) &#123;</div><div class="line">       ((UILabel*)view).textAlignment = NSTextAlignmentLeft;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但很遗憾的是，在<code>iOS 7</code>之后，苹果不让我们这么干了。我们去取<code>UIAlertView</code>的<code>subviews</code>时，获得的只是一个空数组，我们没有办法获取到我们想要的<code>label</code>。怎么办？三条路：告诉产品经理和UED说这个实现不了(当然，这个是会被鄙视的，人家会说你能力差)；自己写；找第三方开源代码。嘿嘿，不过由于最近时间紧，所以我决定跟他们说实现不了，哈哈。不过在<code>github</code>上找了一个开源的，<a href="https://github.com/wimagguc/ios-custom-alertview" target="_blank" rel="external">Custom iOS AlertView</a>，<code>star</code>的数量也不少，看来不错，回头好好研究研究。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/05/10/ios-techset-1/" itemprop="url">
                  iOS知识小集 第1期(2015.05.10)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-05-10T22:06:42+08:00" content="2015-05-10">
              2015-05-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/techset/" itemprop="url" rel="index">
                    <span itemprop="name">知识小集</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一直想做这样一个小册子，来记录自己平时开发、阅读博客、看书、代码分析和与人交流中遇到的各种问题。之前有过这样的尝试，但都是无疾而终。不过，每天接触的东西多，有些东西不记下来，忘得也是很快，第二次遇到同样的问题时，还得再查一遍。好记性不如烂笔头，所以又决定重拾此事，时不时回头看看，温故而知新。</p>
<p>这里面的每个问题，不会太长。或是读书笔记，或是摘抄，亦或是验证，每个问题的篇幅争取在六七百字的样子。笔记和摘抄的出处会详细标明。问题的个数不限，凑齐<code>3000</code>字左右就发一篇。争取每月至少发两篇吧，权当是对自己学习的一个整理。</p>
<p>本期主要记录了以下几个问题：</p>
<ol>
<li><code>NSString</code>属性什么时候用<code>copy</code>，什么时候用<code>strong?</code></li>
<li><code>Foundation</code>中的断言处理</li>
<li><code>IBOutletCollection</code></li>
<li><code>NSRecursiveLock</code>递归锁的使用</li>
<li><code>NSHashTable</code></li>
</ol>
<h2 id="NSString属性什么时候用copy，什么时候用strong"><a href="#NSString属性什么时候用copy，什么时候用strong" class="headerlink" title="NSString属性什么时候用copy，什么时候用strong?"></a>NSString属性什么时候用copy，什么时候用strong?</h2><p>我们在声明一个<code>NSString</code>属性时，对于其内存相关特性，通常有两种选择(基于<code>ARC</code>环境)：<code>strong</code>与<code>copy</code>。那这两者有什么区别呢？什么时候该用<code>strong</code>，什么时候该用<code>copy</code>呢？让我们先来看个例子。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>我们定义一个类，并为其声明两个字符串属性，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@interface TestStringClass ()</div><div class="line">@property (nonatomic, strong) NSString *strongString;</div><div class="line">@property (nonatomic, copy) NSString *copyedString;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>上面的代码声明了两个字符串属性，其中一个内存特性是<code>strong</code>，一个是<code>copy</code>。下面我们来看看它们的区别。</p>
<p>首先，我们用一个不可变字符串来为这两个属性赋值，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)test &#123;</div><div class="line">    NSString *string = [NSString stringWithFormat:@&quot;abc&quot;];</div><div class="line">    self.strongString = string;</div><div class="line">    self.copyedString = string;</div><div class="line"></div><div class="line">    NSLog(@&quot;origin string: %p, %p&quot;, string, &amp;string);</div><div class="line">    NSLog(@&quot;strong string: %p, %p&quot;, strongString, &amp;strongString);</div><div class="line">    NSLog(@&quot;copy string: %p, %p&quot;, copyedString, &amp;copyedString);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">origin string: 0x7fe441592e20, 0x7fff57519a48</div><div class="line">strong string: 0x7fe441592e20, 0x7fe44159e1f8</div><div class="line">copy string: 0x7fe441592e20, 0x7fe44159e200</div></pre></td></tr></table></figure>
<p>我们要以看到，这种情况下，不管是<code>strong</code>还是<code>copy</code>属性的对象，其指向的地址都是同一个，即为<code>string</code>指向的地址。如果我们换作<code>MRC</code>环境，打印<code>string</code>的引用计数的话，会看到其引用计数值是<code>3</code>，即<code>strong</code>操作和<code>copy</code>操作都使原字符串对象的引用计数值加了<code>1</code>。</p>
<p>接下来，我们把<code>string</code>由不可变改为可变对象，看看会是什么结果。即将下面这一句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *string = [NSString stringWithFormat:@&quot;abc&quot;];</div></pre></td></tr></table></figure>
<p>改成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSMutableString *string = [NSMutableString stringWithFormat:@&quot;abc&quot;];</div></pre></td></tr></table></figure>
<p>其输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">origin string: 0x7ff5f2e33c90, 0x7fff59937a48</div><div class="line">strong string: 0x7ff5f2e33c90, 0x7ff5f2e2aec8</div><div class="line">copy string: 0x7ff5f2e2aee0, 0x7ff5f2e2aed0</div></pre></td></tr></table></figure>
<p>可以发现，此时<code>copy</code>属性字符串已不再指向<code>string</code>字符串对象，而是深拷贝了<code>string</code>字符串，并让<code>_copyedString</code>对象指向这个字符串。在<code>MRC</code>环境下，打印两者的引用计数，可以看到<code>string</code>对象的引用计数是<code>2</code>，而<code>_copyedString</code>对象的引用计数是<code>1</code>。</p>
<p>此时，我们如果去修改string字符串的话，可以看到：因为_strongString与string是指向同一对象，所以<code>_strongString</code>的值也会跟随着改变(需要注意的是，此时<code>_strongString</code>的类型实际上是<code>NSMutableString</code>，而不是<code>NSString</code>)；而<code>_copyedString</code>是指向另一个对象的，所以并不会改变。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>由于<code>NSMutableString</code>是<code>NSString</code>的子类，所以一个<code>NSString</code>指针可以指向<code>NSMutableString</code>对象，让我们的<code>strongString</code>指针指向一个可变字符串是OK的。</p>
<p>而上面的例子可以看出，当源字符串是<code>NSString</code>时，由于字符串是不可变的，所以，不管是<code>strong</code>还是<code>copy</code>属性的对象，都是指向源对象，<code>copy</code>操作只是做了次<strong>浅拷贝</strong>。</p>
<p>当源字符串是<code>NSMutableString</code>时，<code>strong</code>属性只是增加了源字符串的引用计数，而<code>copy</code>属性则是对源字符串做了次<strong>深拷贝</strong>，产生一个新的对象，且<code>copy</code>属性对象指向这个新的对象。另外需要注意的是，这个<code>copy</code>属性对象的类型始终是<code>NSString</code>，而不是<code>NSMutableString</code>，因此其是不可变的。</p>
<p>这里还有一个性能问题，即在源字符串是<code>NSMutableString</code>，<code>strong</code>是单纯的增加对象的引用计数，而<code>copy</code>操作是执行了一次深拷贝，所以性能上会有所差异。而如果源字符串是<code>NSString</code>时，则没有这个问题。</p>
<p>所以，在声明<code>NSString</code>属性时，到底是选择<code>strong</code>还是<code>copy</code>，可以根据实际情况来定。不过，一般我们将对象声明为<code>NSString</code>时，都不希望它改变，所以大多数情况下，我们建议用<code>copy</code>，以免因可变字符串的修改导致的一些非预期问题。</p>
<p>关于字符串的内存管理，还有些有意思的东西，可以参考<a href="http://blog.cnbluebox.com/blog/2014/04/16/nsstringte-xing-fen-xi-xue-xi/" target="_blank" rel="external">NSString特性分析学习</a>。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://stackoverflow.com/questions/2521468/nsstring-copy-not-copying" target="_blank" rel="external">NSString copy not copying?</a></li>
<li><a href="http://blog.cnbluebox.com/blog/2014/04/16/nsstringte-xing-fen-xi-xue-xi/" target="_blank" rel="external">NSString特性分析学习</a></li>
<li><a href="http://blog.csdn.net/itianyi/article/details/9018567" target="_blank" rel="external">NSString什么时候用copy，什么时候用strong</a></li>
</ol>
<h2 id="Foundation中的断言处理"><a href="#Foundation中的断言处理" class="headerlink" title="Foundation中的断言处理"></a>Foundation中的断言处理</h2><p>经常在看一些第三方库的代码时，或者自己在写一些基础类时，都会用到断言。所以在此总结一下<code>Objective-C</code>中关于断言的一些问题。</p>
<p><code>Foundation</code>中定义了两组断言相关的宏，分别是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSAssert / NSCAssert</div><div class="line">NSParameterAssert / NSCParameterAssert</div></pre></td></tr></table></figure>
<p>这两组宏主要在功能和语义上有所差别，这些区别主要有以下两点：</p>
<ol>
<li>如果我们需要确保方法或函数的输入参数的正确性，则应该在方法(函数)的顶部使用<code>NSParameterAssert / NSCParameterAssert</code>；而在其它情况下，使用<code>NSAssert / NSCAssert</code>。</li>
<li>另一个不同是介于<code>C</code>和<code>Objective-C</code>之间。<code>NSAssert / NSParameterAssert</code>应该用于<code>Objective-C</code>的上下文(方法)中，而<code>NSCAssert / NSCParameterAssert</code>应该用于<code>C</code>的上下文(函数)中。</li>
</ol>
<p>当断言失败时，通常是会抛出一个如下所示的异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*** Terminating app due to uncaught exception &apos;NSInternalInconsistencyException&apos;, reason: &apos;true is not equal to false&apos;</div></pre></td></tr></table></figure>
<p><code>Foundation</code>为了处理断言，专门定义了一个<code>NSAssertionHandler</code>来处理断言的失败情况。<code>NSAssertionHandler</code>对象是自动创建的，用于处理失败的断言。当断言失败时，会传递一个字符串给<code>NSAssertionHandler</code>对象来描述失败的原因。<strong>每个线程都有自己的NSAssertionHandler对象</strong>。当调用时，一个断言处理器会打印包含方法和类(或函数)的错误消息，并引发一个<code>NSInternalInconsistencyException</code>异常。就像上面所看到的一样。</p>
<p>我们很少直接去调用<code>NSAssertionHandler</code>的断言处理方法，通常都是自动调用的。</p>
<p><code>NSAssertionHandler</code>提供的方法并不多，就三个，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 返回与当前线程的NSAssertionHandler对象。</div><div class="line">// 如果当前线程没有相关的断言处理器，则该方法会创建一个并指定给当前线程</div><div class="line">+ (NSAssertionHandler *)currentHandler</div><div class="line"></div><div class="line">// 当NSCAssert或NSCParameterAssert断言失败时，会调用这个方法</div><div class="line">- (void)handleFailureInFunction:(NSString *)functionName file:(NSString *)object lineNumber:(NSInteger)fileName description:(NSString *)line, format,...</div><div class="line"></div><div class="line">// 当NSAssert或NSParameterAssert断言失败时，会调用这个方法</div><div class="line">- (void)handleFailureInMethod:(SEL)selector object:(id)object file:(NSString *)fileName lineNumber:(NSInteger)line description:(NSString *)format, ...</div></pre></td></tr></table></figure>
<p>另外，还定义了一个常量字符串，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString * const NSAssertionHandlerKey;</div></pre></td></tr></table></figure>
<p>主要是用于在线程的<code>threadDictionary</code>字典中获取或设置断言处理器。</p>
<p>关于断言，还需要注意的一点是在<code>Xcode 4.2</code>以后，在<code>release</code>版本中断言是默认关闭的，这是由宏<code>NS_BLOCK_ASSERTIONS</code>来处理的。也就是说，当编译<code>release</code>版本时，所有的断言调用都是无效的。</p>
<p>我们可以自定义一个继承自<code>NSAssertionHandler</code>的断言处理类，来实现一些我们自己的需求。如<code>Mattt Thompson</code>的<a href="http://nshipster.com/nsassertionhandler/" target="_blank" rel="external">NSAssertionHandler</a>实例一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">@interface LoggingAssertionHandler : NSAssertionHandler</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation LoggingAssertionHandler</div><div class="line"></div><div class="line">- (void)handleFailureInMethod:(SEL)selector</div><div class="line">                       object:(id)object</div><div class="line">                         file:(NSString *)fileName</div><div class="line">                   lineNumber:(NSInteger)line</div><div class="line">                  description:(NSString *)format, ...</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;NSAssert Failure: Method %@ for object %@ in %@#%i&quot;, NSStringFromSelector(selector), object, fileName, line);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)handleFailureInFunction:(NSString *)functionName</div><div class="line">                           file:(NSString *)fileName</div><div class="line">                     lineNumber:(NSInteger)line</div><div class="line">                    description:(NSString *)format, ...</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;NSCAssert Failure: Function (%@) in %@#%i&quot;, functionName, fileName, line);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>上面说过，每个线程都有自己的断言处理器。我们可以通过为线程的<code>threadDictionary</code>字典中的<code>NSAssertionHandlerKey</code>指定一个新值，来改变线程的断言处理器。</p>
<p>如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)application</div><div class="line">didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</div><div class="line">&#123;</div><div class="line">  NSAssertionHandler *assertionHandler = [[LoggingAssertionHandler alloc] init];</div><div class="line">  [[[NSThread currentThread] threadDictionary] setValue:assertionHandler</div><div class="line">                                                 forKey:NSAssertionHandlerKey];</div><div class="line">  // ...</div><div class="line">  return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而什么时候应该使用断言呢？通常我们期望程序按照我们的预期去运行时，如调用的参数为空时流程就无法继续下去时，可以使用断言。但另一方面，我们也需要考虑，在这加断言确实是需要的么？我们是否可以通过更多的容错处理来使程序正常运行呢？</p>
<p><code>Matt Thompson</code>在<a href="http://nshipster.com/nsassertionhandler/" target="_blank" rel="external">NSAssertionHandler</a>中的倒数第二段说得挺有意思，在此摘抄一下：</p>
<blockquote>
<p>But if we look deeper into NSAssertionHandler—and indeed, into our own hearts, there are lessons to be learned about our capacity for kindness and compassion; about our ability to forgive others, and to recover from our own missteps. We can’t be right all of the time. We all make mistakes. By accepting limitations in ourselves and others, only then are we able to grow as individuals.</p>
</blockquote>
<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://nshipster.com/nsassertionhandler/" target="_blank" rel="external">NSAssertion​Handler</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAssertionHandler_Class/" target="_blank" rel="external">NSAssertionHandler Class Reference</a></li>
</ol>
<h2 id="IBOutletCollection"><a href="#IBOutletCollection" class="headerlink" title="IBOutletCollection"></a>IBOutletCollection</h2><p>在<code>IB</code>与相关文件做连接时，我们经常会用到两个关键字：<code>IBOutlet</code>和<code>IBAction</code>。经常用<code>xib</code>或<code>storyboard</code>的童鞋应该用这两上关键字非常熟悉了。不过<code>UIKit</code>还提供了另一个伪关键字<strong>IBOutletCollection</strong>，我们使用这个关键字，可以将界面上一组相同的控件连接到同一个数组中。</p>
<p>我们先来看看这个伪关键字的定义，可以从<code>UIKit.framework</code>的头文件<code>UINibDeclarations.h</code>找到如下定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#ifndef IBOutletCollection</div><div class="line">#define IBOutletCollection(ClassName)</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>另外，在<code>Clang</code>源码中，有更安全的定义方式，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define IBOutletCollection(ClassName) attribute((iboutletcollection(ClassName)))</div></pre></td></tr></table></figure>
<p>从上面的定义可以看到，与<code>IBOutlet</code>不同的是，<code>IBOutletCollection</code>带有一个参数，该参数是一个类名。</p>
<p>通常情况下，我们使用一个<code>IBOutletCollection</code>属性时，属性必须是<code>strong</code>的，且类型是<code>NSArray</code>，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (strong, nonatomic) IBOutletCollection(UIScrollView) NSArray *scrollViews;</div></pre></td></tr></table></figure>
<p>假定我们的<code>xib</code>文件中有三个横向的<code>scrollView</code>，我们便可以将这三个<code>scrollView</code>都连接至<code>scrollViews</code>属性，然后在我们的代码中便可以做一些统一处理，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)setupScrollViewImages</div><div class="line">&#123;</div><div class="line">    for (UIScrollView *scrollView in self.scrollViews) &#123;</div><div class="line">        [self.imagesData enumerateObjectsUsingBlock:^(NSString *imageName, NSUInteger idx, BOOL *stop) &#123;</div><div class="line"></div><div class="line">            UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(CGRectGetWidth(scrollView.frame) * idx, 0, CGRectGetWidth(scrollView.frame), CGRectGetHeight(scrollView.frame))];</div><div class="line">            imageView.contentMode = UIViewContentModeScaleAspectFill;</div><div class="line">            imageView.image = [UIImage imageNamed:imageName];</div><div class="line">            [scrollView addSubview:imageView];</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码会影响到三个<code>scrollView</code>。这样做的好处是我们不需要手动通过<code>addObject:</code>方法将<code>scrollView</code>添加到<code>scrollViews</code>中。</p>
<p>不过在使用<code>IBOutletCollection</code>时，需要注意两点：</p>
<ol>
<li><code>IBOutletCollection</code>集合中对象的顺序是不确定的。我们通过调试方法可以看到集合中对象的顺序跟我们连接的顺序是一样的。但是这个顺序可能会因为不同版本的<code>Xcode</code>而有所不同。所以我们不应该试图在代码中去假定这种顺序。</li>
<li>不管<code>IBOutletCollection(ClassName)</code>中的控件是什么，属性的类型始终是<code>NSArray</code>。实际上，我们可以声明是任何类型，如<code>NSSet</code>，<code>NSMutableArray</code>，甚至可以是<code>UIColor</code>，但不管我们在此设置的是什么类，<code>IBOutletCollection</code>属性总是指向一个<code>NSArray</code>数组。</li>
</ol>
<p>关于第二点，我们以上面的<code>scrollViews</code>为例，作如下修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (strong, nonatomic) IBOutletCollection(UIScrollView) NSSet *scrollViews;</div></pre></td></tr></table></figure>
<p>实际上我们在控制台打印这个<code>scrollViews</code>时，结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(lldb) po self.scrollViews</div><div class="line">&lt;__NSArrayI 0x1740573d0&gt;(</div><div class="line">&lt;UIScrollView: 0x12d60d770; frame = (0 0; 320 162); clipsToBounds = YES; autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x1740574f0&gt;; layer = &lt;CALayer: 0x174229480&gt;; contentOffset: &#123;0, 0&#125;; contentSize: &#123;0, 0&#125;&gt;,</div><div class="line">&lt;UIScrollView: 0x12d60dee0; frame = (0 0; 320 161); clipsToBounds = YES; autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x174057790&gt;; layer = &lt;CALayer: 0x1742297c0&gt;; contentOffset: &#123;0, 0&#125;; contentSize: &#123;0, 0&#125;&gt;,</div><div class="line">&lt;UIScrollView: 0x12d60e650; frame = (0 0; 320 163); clipsToBounds = YES; autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x1740579a0&gt;; layer = &lt;CALayer: 0x1742298e0&gt;; contentOffset: &#123;0, 0&#125;; contentSize: &#123;0, 0&#125;&gt;</div><div class="line">)</div></pre></td></tr></table></figure>
<p>可以看到，它指向的是一个<code>NSArray</code>数组。</p>
<p>另外，<code>IBOutletCollection</code>实际上在<code>iOS 4</code>版本中就有了。不过，现在的<code>Objective-C</code>已经支持<code>object literals</code>了，所以定义数组可以直接用<code>@[]</code>，方便了许多。而且<code>object literals</code>方式可以添加不在<code>xib</code>中的用代码定义的视图，所以显得更加灵活。当然，两种方式选择哪一种，就看我们自己的实际需要和喜好了。</p>
<h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://nshipster.com/ibaction-iboutlet-iboutletcollection/" target="_blank" rel="external">IBAction / IBOutlet / IBOutlet​Collection</a></li>
<li><a href="http://www.opensource.apple.com/source/clang/clang-318.0.45/src/tools/clang/test/Index/IBOutletCollection.m" target="_blank" rel="external">IBOutletCollection.m</a></li>
</ol>
<h2 id="NSRecursiveLock递归锁的使用"><a href="#NSRecursiveLock递归锁的使用" class="headerlink" title="NSRecursiveLock递归锁的使用"></a>NSRecursiveLock递归锁的使用</h2><p><code>NSRecursiveLock</code>实际上定义的是一个递归锁，这个锁可以被同一线程多次请求，而不会引起死锁。这主要是用在循环或递归操作中。我们先来看一个示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">NSLock *lock = [[NSLock alloc] init];</div><div class="line"></div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line"></div><div class="line">    static void (^RecursiveMethod)(int);</div><div class="line"></div><div class="line">    RecursiveMethod = ^(int value) &#123;</div><div class="line"></div><div class="line">        [lock lock];</div><div class="line">        if (value &gt; 0) &#123;</div><div class="line"></div><div class="line">            NSLog(@&quot;value = %d&quot;, value);</div><div class="line">            sleep(2);</div><div class="line">            RecursiveMethod(value - 1);</div><div class="line">        &#125;</div><div class="line">        [lock unlock];</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    RecursiveMethod(5);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这段代码是一个典型的死锁情况。在我们的线程中，<code>RecursiveMethod</code>是递归调用的。所以每次进入这个<code>block</code>时，都会去加一次锁，而从第二次开始，由于锁已经被使用了且没有解锁，所以它需要等待锁被解除，这样就导致了死锁，线程被阻塞住了。调试器中会输出如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">value = 5</div><div class="line">* -[NSLock lock]: deadlock (&lt;NSLock: 0x1700ceee0&gt; &apos;(null)&apos;)	* Break on _NSLockError() to debug.</div></pre></td></tr></table></figure>
<p>在这种情况下，我们就可以使用<code>NSRecursiveLock</code>。它可以允许同一线程多次加锁，而不会造成死锁。递归锁会跟踪它被<code>lock</code>的次数。每次成功的<code>lock</code>都必须平衡调用<code>unlock</code>操作。只有所有达到这种平衡，锁最后才能被释放，以供其它线程使用。</p>
<p>所以，对上面的代码进行一下改造，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];</div></pre></td></tr></table></figure>
<p>这样，程序就能正常运行了，其输出如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">value = 5</div><div class="line">value = 4</div><div class="line">value = 3</div><div class="line">value = 2</div><div class="line">value = 1</div></pre></td></tr></table></figure>
<p><code>NSRecursiveLock</code>除了实现<code>NSLocking</code>协议的方法外，还提供了两个方法，分别如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 在给定的时间之前去尝试请求一个锁</div><div class="line">- (BOOL)lockBeforeDate:(NSDate *)limit</div><div class="line"></div><div class="line">// 尝试去请求一个锁，并会立即返回一个布尔值，表示尝试是否成功</div><div class="line">- (BOOL)tryLock</div></pre></td></tr></table></figure>
<p>这两个方法都可以用于在多线程的情况下，去尝试请求一个递归锁，然后根据返回的布尔值，来做相应的处理。如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];</div><div class="line"></div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line"></div><div class="line">    static void (^RecursiveMethod)(int);</div><div class="line"></div><div class="line">    RecursiveMethod = ^(int value) &#123;</div><div class="line"></div><div class="line">        [lock lock];</div><div class="line">        if (value &gt; 0) &#123;</div><div class="line"></div><div class="line">            NSLog(@&quot;value = %d&quot;, value);</div><div class="line">            sleep(2);</div><div class="line">            RecursiveMethod(value - 1);</div><div class="line">        &#125;</div><div class="line">        [lock unlock];</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    RecursiveMethod(5);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line"></div><div class="line">    sleep(2);</div><div class="line">    BOOL flag = [lock lockBeforeDate:[NSDate dateWithTimeIntervalSinceNow:1]];</div><div class="line">    if (flag) &#123;</div><div class="line">        NSLog(@&quot;lock before date&quot;);</div><div class="line"></div><div class="line">        [lock unlock];</div><div class="line">    &#125; else &#123;</div><div class="line">        NSLog(@&quot;fail to lock before date&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在前面的代码中，我们又添加了一段代码，增加一个线程来获取递归锁。我们在第二个线程中尝试去获取递归锁，当然这种情况下是会失败的，输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">value = 5</div><div class="line">value = 4</div><div class="line">fail to lock before date</div><div class="line">value = 3</div><div class="line">value = 2</div><div class="line">value = 1</div></pre></td></tr></table></figure>
<p>另外，<code>NSRecursiveLock</code>还声明了一个<code>name</code>属性，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property(copy) NSString *name</div></pre></td></tr></table></figure>
<p>我们可以使用这个字符串来标识一个锁。<code>Cocoa</code>也会使用这个<code>name</code>作为错误描述信息的一部分。</p>
<h3 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRecursiveLock_Class/" target="_blank" rel="external">NSRecursiveLock Class Reference</a></li>
<li><a href="http://www.tanhao.me/pieces/643.html/" target="_blank" rel="external">Objective-C中不同方式实现锁(二)</a></li>
</ol>
<h2 id="NSHashTable"><a href="#NSHashTable" class="headerlink" title="NSHashTable"></a>NSHashTable</h2><p>在看<code>KVOController</code>的代码时，又看到了<code>NSHashTable</code>这个类，所以就此整理一下。</p>
<p><code>NSHashTable</code>效仿了<code>NSSet(NSMutableSet)</code>，但提供了比<code>NSSet</code>更多的操作选项，尤其是在对弱引用关系的支持上，<code>NSHashTable</code>在对象/内存处理时更加的灵活。相较于<code>NSSet</code>，<code>NSHashTable</code>具有以下特性：</p>
<ol>
<li><code>NSSet(NSMutableSet)</code>持有其元素的强引用，同时这些元素是使用<code>hash</code>值及<code>isEqual:</code>方法来做<code>hash</code>检测及判断是否相等的。</li>
<li><code>NSHashTable</code>是可变的，它没有不可变版本。</li>
<li>它可以持有元素的弱引用，而且在对象被销毁后能正确地将其移除。而这一点在<code>NSSet</code>是做不到的。</li>
<li>它的成员可以在添加时被拷贝。</li>
<li>它的成员可以使用指针来标识是否相等及做<code>hash</code>检测。</li>
<li>它可以包含任意指针，其成员没有限制为对象。我们可以配置一个<code>NSHashTable</code>实例来操作任意的指针，而不仅仅是对象。</li>
</ol>
<p>初始化<code>NSHashTable</code>时，我们可以设置一个初始选项，这个选项确定了这个<code>NSHashTable</code>对象后面所有的行为。这个选项是由<code>NSHashTableOptions</code>枚举来定义的，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">enum &#123;</div><div class="line">    // 默认行为，强引用集合中的对象，等同于NSSet</div><div class="line">    NSHashTableStrongMemory             = 0,</div><div class="line">    </div><div class="line">    // 在将对象添加到集合之前，会拷贝对象</div><div class="line">    NSHashTableCopyIn                   = NSPointerFunctionsCopyIn,</div><div class="line"></div><div class="line">    // 使用移位指针(shifted pointer)来做hash检测及确定两个对象是否相等；</div><div class="line">    // 同时使用description方法来做描述字符串</div><div class="line">    NSHashTableObjectPointerPersonality = NSPointerFunctionsObjectPointerPersonality,</div><div class="line"></div><div class="line">    // 弱引用集合中的对象，且在对象被释放后，会被正确的移除。</div><div class="line">    NSHashTableWeakMemory               = NSPointerFunctionsWeakMemory </div><div class="line">&#125;;</div><div class="line"></div><div class="line">typedef NSUInteger NSHashTableOptions;</div></pre></td></tr></table></figure>
<p>当然，我们还可以使用<code>NSPointerFunctions</code>来初始化，但只有使用<code>NSHashTableOptions</code>定义的这些值，才能确保<code>NSHashTable</code>的各个<code>API</code>可以正确的工作–包括拷贝、归档及快速枚举。</p>
<p>个人认为<code>NSHashTable</code>吸引人的地方在于可以持有元素的弱引用，而且在对象被销毁后能正确地将其移除。我们来写个示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// 具体调用如下</div><div class="line">@implementation TestHashAndMapTableClass &#123;</div><div class="line">    NSMutableDictionary *_dic;</div><div class="line">    NSSet               *_set;</div><div class="line">    NSHashTable         *_hashTable;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)init &#123;</div><div class="line">    self = [super init];</div><div class="line"></div><div class="line">    if (self) &#123;</div><div class="line">        [self testWeakMemory];</div><div class="line">        NSLog(@&quot;hash table [init]: %@&quot;, _hashTable);</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)testWeakMemory &#123;</div><div class="line">    if (!_hashTable) &#123;</div><div class="line">        _hashTable = [NSHashTable weakObjectsHashTable];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    NSObject *obj = [[NSObject alloc] init];</div><div class="line">    [_hashTable addObject:obj];</div><div class="line">    NSLog(@&quot;hash table [testWeakMemory] : %@&quot;, _hashTable);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码的输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">hash table [testWeakMemory] : NSHashTable &#123;</div><div class="line">[6] &lt;NSObject: 0x7fa2b1562670&gt;</div><div class="line">&#125;</div><div class="line">hash table [init]: NSHashTable &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，在离开<code>testWeakMemory</code>方法，<code>obj</code>对象被释放，同时对象在集合中的引用也被安全的删除。</p>
<p>这样看来，<code>NSHashTable</code>似乎比<code>NSSet(NSMutableSet)</code>要好啊。那是不是我们就应用都使用<code>NSHashTable</code>呢？<code>Peter Steinberger</code>在<a href="http://www.objc.io/issue-7/collections.html" target="_blank" rel="external">The Foundation Collection Classes</a>给了我们一组数据，显示在添加对象的操作中，<code>NSHashTable</code>所有的时间差不多是<code>NSMutableSet</code>的<code>2</code>倍，而在其它操作中，性能大体相近。所以，如果我们只需要<code>NSSet</code>的特性，就尽量用<code>NSSet</code>。</p>
<p>另外，<code>Mattt Thompson</code>在<a href="http://nshipster.com/nshashtable-and-nsmaptable/" target="_blank" rel="external">NSHashTable &amp; NSMapTable</a>的结尾也写了段挺有意思的话，在此直接摘抄过来：</p>
<blockquote>
<p>As always, it’s important to remember that programming is not about being clever: always approach a problem from the highest viable level of abstraction. NSSet and NSDictionary are great classes. For 99% of problems, they are undoubtedly the correct tool for the job. If, however, your problem has any of the particular memory management constraints described above, then NSHashTable &amp; NSMapTable may be worth a look.</p>
</blockquote>
<h3 id="参考-4"><a href="#参考-4" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSHashTable_class/" target="_blank" rel="external">NSHashTable Class Reference</a></li>
<li><a href="http://nshipster.com/nshashtable-and-nsmaptable/" target="_blank" rel="external">NSHash​Table &amp; NSMap​Table</a></li>
<li><a href="http://billwang1990.github.io/blog/2014/03/31/nshashtable-and-nsmaptable/" target="_blank" rel="external">NSHashTable &amp; NSMapTable</a></li>
<li><a href="http://www.objc.io/issue-7/collections.html" target="_blank" rel="external">The Foundation Collection Classes</a></li>
</ol>
<h2 id="零碎"><a href="#零碎" class="headerlink" title="零碎"></a>零碎</h2><h3 id="一-“Unknown-class-XXViewController-in-Interface-Builder-file-””-问题处理"><a href="#一-“Unknown-class-XXViewController-in-Interface-Builder-file-””-问题处理" class="headerlink" title="(一) “Unknown class XXViewController in Interface Builder file.”” 问题处理"></a>(一) “Unknown class XXViewController in Interface Builder file.”” 问题处理</h3><p>最近在静态库中写了一个<code>XXViewController</code>类，然后在主工程的<code>xib</code>中，将<code>xib</code>的类指定为<code>XXViewController</code>，程序运行时，报了如下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Unknown class XXViewController in Interface Builder file.</div></pre></td></tr></table></figure>
<p>之前也遇到这个问题，但已记得不太清楚，所以又开始在<code>stackoverflow</code>上找答案。</p>
<p>其实这个问题与<code>Interface Builder</code>无关，最直接的原因还是相关的<code>symbol</code>没有从静态库中加载进来。这种问题的处理就是在<code>Target</code>的<code>&quot;Build Setting&quot;</code>-&gt;<code>&quot;Other Link Flags&quot;</code>中加上<code>&quot;-all_load -ObjC&quot;</code>这两个标识位，这样就OK了。</p>
<h3 id="二-关于Unbalanced-calls-to-begin-end-appearance-transitions-for-…问题的处理"><a href="#二-关于Unbalanced-calls-to-begin-end-appearance-transitions-for-…问题的处理" class="headerlink" title="(二)关于Unbalanced calls to begin/end appearance transitions for …问题的处理"></a>(二)关于Unbalanced calls to begin/end appearance transitions for …问题的处理</h3><p>我们的某个业务有这么一个需求，进入一个列表后需要立马又<code>push</code>一个<code>web</code>页面，做一些活动的推广。在<code>iOS 8</code>上，我们的实现是一切OK的；但到了<code>iOS 7</code>上，就发现这个<code>web</code>页面<code>push</code>不出来了，同时控制台给了一条警告消息，即如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Unbalanced calls to begin/end appearance transitions for ...</div></pre></td></tr></table></figure>
<p>在这种情况下，点击导航栏中的返回按钮时，直接显示一个黑屏。</p>
<p>我们到<code>stackoverflow</code>上查了一下，有这么一段提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">occurs when you try and display a new viewcontroller before the current view controller is finished displaying.</div></pre></td></tr></table></figure>
<p>意思是说在当前视图控制器完成显示之前，又试图去显示一个新的视图控制器。</p>
<p>于是我们去排查代码，果然发现，在<code>viewDidLoad</code>里面去做了次网络请求操作，且请求返回后就去<code>push</code>这个<code>web</code>活动推广页。此时，当前的视图控制器可能并未显示完成(即未完成<code>push</code>操作)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Basically you are trying to push two view controllers onto the stack at almost the same time.</div></pre></td></tr></table></figure>
<p>当几乎同时将两个视图控制器<code>push</code>到当前的导航控制器栈中时，或者同时<code>pop</code>两个不同的视图控制器，就会出现不确定的结果。所以我们应该确保同一时间，对同一个导航控制器栈只有一个操作，即便当前的视图控制器正在动画过程中，也不应该再去<code>push</code>或<code>pop</code>一个新的视图控制器。</p>
<p>所以最后我们把<code>web</code>活动的数据请求放到了<code>viewDidAppear</code>里面，并做了些处理，这样问题就解决了。</p>
<h4 id="参考-5"><a href="#参考-5" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a href="http://stackoverflow.com/questions/9088465/unbalanced-calls-to-begin-end-appearance-transitions-for-detailviewcontroller" target="_blank" rel="external">“Unbalanced calls to begin/end appearance transitions for DetailViewController” when pushing more than one detail view controller</a></li>
<li><a href="http://stackoverflow.com/questions/8563473/unbalanced-calls-to-begin-end-appearance-transitions-for-uitabbarcontroller" target="_blank" rel="external">Unbalanced calls to begin/end appearance transitions for UITabBarController</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/04/23/cocoa-foundation-nskeyvalueobserving/" itemprop="url">
                  Foundation: NSKeyValueObserving(KVO)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-04-23T17:31:16+08:00" content="2015-04-23">
              2015-04-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/cocoa/" itemprop="url" rel="index">
                    <span itemprop="name">Cocoa</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>NSKeyValueObserving</code>非正式协议定义了一种机制，它允许对象去监听其它对象的某个属性的修改。</p>
<p>我们可以监听一个对象的属性，包括简单属性，一对一的关系，和一对多的关系。一对多关系的监听者会被告知集合变更的类型，以及哪些对象参与了变化。</p>
<p><code>NSObject</code>提供了一个<code>NSKeyValueObserving</code>协议的默认实现，它为所有对象提供了一种自动发送修改通知的能力。我们可以通过禁用自动发送通知并使用这个协议提供的方法来手动实现通知的发送，以便更精确地去处理通知。</p>
<p>在这里，我们将通过具体的实例来看看<code>NSKeyValueObserving</code>提供了哪些方法。我们的基础代码如代码清单1所示：</p>
<p><strong>代码清单1：示例基础代码</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark - PersonObject</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PersonObject</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PersonObject</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"keyPath = %@, change = %@, context = %s"</span>, keyPath, change, (<span class="keyword">char</span> *)context);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - BankObject</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BankObject</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">int</span> accountBalance;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *bankCodeEn;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *departments;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>在这段代码中，我们定义一两个类，一个是<code>PersonObject</code>类，这个类的对象在下面将充当观察者的角色。另一个是<code>BankObject</code>类，我们在这个类中定义了三个属性，作为被监听的属性。由于<code>NSObject</code>类已经实现了<code>NSKeyValueObserving</code>协议，所以我们不需要再显式地去让我们的类实现这个协议。</p>
<p>接下来，我们便来看看<code>NSKeyValueObserving</code>协议有哪些功能。</p>
<h2 id="注册-移除观察者"><a href="#注册-移除观察者" class="headerlink" title="注册/移除观察者"></a>注册/移除观察者</h2><p>要让一个对象监听另一个对象的属性的变化，首先需要将这个对象注册为相关属性的观察者，我们可以使用以下方法来实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)anObserver</div><div class="line">         forKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">            options:(<span class="built_in">NSKeyValueObservingOptions</span>)options</div><div class="line">            context:(<span class="keyword">void</span> *)context</div></pre></td></tr></table></figure>
<p>这个方法带有四个参数，描述如下：</p>
<ol>
<li><code>anObserver</code>：观察者对象，这个对象必须实现<code>observeValueForKeyPath:ofObject:change:context:</code>方法，以响应属性的修改通知。</li>
<li><code>keyPath</code>：被监听的属性。这个值不能为nil。</li>
<li><code>options</code>：监听选项，这个值可以是<code>NSKeyValueObservingOptions</code>选项的组合。关于监听选项，我们会在下面介绍。</li>
<li><code>context</code>：任意的额外数据，我们可以将这些数据作为上下文数据，它会传递给观察者对象的<code>observeValueForKeyPath:ofObject:change:context:</code>方法。这个参数的意义在于用于区分同一对象监听同一属性(从属于同一对象)的多个不同的监听。我们将在下面看到。</li>
</ol>
<p>监听选项是由枚举<code>NSKeyValueObservingOptions</code>定义的，是传入<code>-addObserver:forKeyPath:options:context:</code>方法中以确定哪些值将被传到-<code>observeValueForKeyPath:ofObject:change:context:</code>方法中。这个枚举的定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">	<span class="comment">// 提供属性的新值</span></div><div class="line">   	<span class="built_in">NSKeyValueObservingOptionNew</span> = <span class="number">0x01</span>,</div><div class="line">   	</div><div class="line">   	<span class="comment">// 提供属性的旧值</span></div><div class="line">   	<span class="built_in">NSKeyValueObservingOptionOld</span> = <span class="number">0x02</span>,</div><div class="line">   	</div><div class="line">   	<span class="comment">// 如果指定，则在添加观察者的时候立即发送一个通知给观察者，</span></div><div class="line">   	<span class="comment">// 并且是在注册观察者方法返回之前</span></div><div class="line">   	<span class="built_in">NSKeyValueObservingOptionInitial</span> = <span class="number">0x04</span>,</div><div class="line">   	</div><div class="line">   	<span class="comment">// 如果指定，则在每次修改属性时，会在修改通知被发送之前预先发送一条通知给观察者，</span></div><div class="line">   	<span class="comment">// 这与-willChangeValueForKey:被触发的时间是相对应的。</span></div><div class="line">   	<span class="comment">// 这样，在每次修改属性时，实际上是会发送两条通知。</span></div><div class="line">   	<span class="built_in">NSKeyValueObservingOptionPrior</span> = <span class="number">0x08</span> </div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NSUInteger</span> <span class="built_in">NSKeyValueObservingOptions</span>;</div></pre></td></tr></table></figure>
<p>需要注意的是，当设定了<code>NSKeyValueObservingOptionPrior</code>选项时，第一条通知不会包含<code>NSKeyValueChangeNewKey</code>。当观察者自身的KVO需要为自己的某个属性调用<code>-willChange...</code>方法，而这个属性的值又依赖于被观察对象的属性时，我们可以使用这个选项。</p>
<p>另外，在添加观察者时还有两点需要注意的是：</p>
<ol>
<li>调用这个方法时，两个对象(即观察者对象及属性所属的对象)都不会被<code>retain</code>。</li>
<li>可以多次调用这个方法，将同一个对象注册为同一属性的观察者(所有参数可以完全相同)。这时，即便在所有参数一致的情况下，新注册的观察者并不会替换原来观察者，而是会并存。这样，当属性被修改时，两次监听都会响应。</li>
</ol>
<p>对于第2点，我们在代码清单2中来验证一下：</p>
<p><strong>代码清单2：验证多次使用相同参数来添加观察者的实际效果</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">PersonObject *personInstance = [[PersonObject alloc] init];</div><div class="line">BankObject *bankInstance = [[BankObject alloc] init];</div><div class="line"></div><div class="line">[bankInstance addObserver:personInstance forKeyPath:<span class="string">@"accountBalance"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span> context:<span class="literal">NULL</span>];</div><div class="line">[bankInstance addObserver:personInstance forKeyPath:<span class="string">@"accountBalance"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span> context:<span class="literal">NULL</span>];</div><div class="line"></div><div class="line">[bankInstance addObserver:personInstance forKeyPath:<span class="string">@"accountBalance"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="string">"person instance"</span>];</div><div class="line">[bankInstance addObserver:personInstance forKeyPath:<span class="string">@"accountBalance"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="string">"person instance 2"</span>];</div><div class="line"></div><div class="line">bankInstance.accountBalance = <span class="number">10</span>;</div></pre></td></tr></table></figure>
<p>(注，以上代码为在MRC环境下调用，确保<code>personInstance</code>和<code>bankInstance</code>不会被释放。)</p>
<p>这段代码的输出如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">keyPath = accountBalance, change = &#123;</div><div class="line">    kind = <span class="number">1</span>;</div><div class="line">    new = <span class="number">10</span>;</div><div class="line">&#125;, context = person instance <span class="number">2</span></div><div class="line">keyPath = accountBalance, change = &#123;</div><div class="line">    kind = <span class="number">1</span>;</div><div class="line">    new = <span class="number">10</span>;</div><div class="line">&#125;, context = person instance</div><div class="line">keyPath = accountBalance, change = &#123;</div><div class="line">    kind = <span class="number">1</span>;</div><div class="line">    new = <span class="number">10</span>;</div><div class="line">    old = <span class="number">0</span>;</div><div class="line">&#125;, context = (null)</div><div class="line">keyPath = accountBalance, change = &#123;</div><div class="line">    kind = <span class="number">1</span>;</div><div class="line">    new = <span class="number">10</span>;</div><div class="line">    old = <span class="number">0</span>;</div><div class="line">&#125;, context = (null)</div></pre></td></tr></table></figure>
<p>可以看到KVO为每次注册都调用了一次监听处理操作。所以多次调用同样的注册操作会产生多个观察者。另外，多个观察者之间的<code>observeValueForKeyPath:ofObject:change:context:</code>方法调用顺序是按照先进后出的顺序来的(所有的监听信息都是放在一个数组中的，我们将在下面了解到)。</p>
<p>一个良好的实践是在观察者不再需要监听属性变化时，必须调用<code>removeObserver:forKeyPath:</code>或<code>removeObserver:forKeyPath:context:</code>方法来移除观察者，这两个方法的声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)anObserver</div><div class="line">            forKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">            </div><div class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer</div><div class="line">            forKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">               context:(<span class="keyword">void</span> *)context</div></pre></td></tr></table></figure>
<p>这两个方法会根据传入的参数(主要是<code>keyPath</code>和<code>context</code>)来移除观察者。如果<code>observer</code>没有监听<code>keyPath</code>属性，则调用这两个方法会抛出异常。大家可以试一下，程序会果断的崩溃。并报类似于以下的错误：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*** Terminating app due to uncaught exception 'NSRangeException', reason: 'Cannot remove an observer &lt;PersonObject 0x7ff541534e20&gt; for the key path "accountBalance" from &lt;BankObject 0x7ff541528430&gt; because it is not registered as an observer.'</div></pre></td></tr></table></figure>
<p>所以，我们必须确保先注册了观察者，才能调用移除方法。</p>
<p>那如果我们忘记调用移除观察者方法，会怎么样呢？我们来制造一个场景，看看会是什么结果。还是使用上面的代码，只不过这次我们在ARC下来测试：</p>
<p><strong>代码清单3：未移除观察者的影响</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)testKVO &#123;</div><div class="line">    </div><div class="line">    PersonObject *personInstance = [[PersonObject alloc] init];</div><div class="line">    BankObject *bankInstance = [[BankObject alloc] init];</div><div class="line">    </div><div class="line">    [bankInstance addObserver:personInstance forKeyPath:<span class="string">@"accountBalance"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span> context:<span class="literal">NULL</span>];</div><div class="line">    </div><div class="line">    bankInstance.accountBalance = <span class="number">20</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其输出结果如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">keyPath = accountBalance, change = &#123;</div><div class="line">    kind = 1;</div><div class="line">    new = 20;</div><div class="line">    old = 0;</div><div class="line">&#125;, context = (null)</div><div class="line">*** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'An instance 0x7fc88047e7e0 of class BankObject was deallocated while key value observers were still registered with it. Current observation info: &lt;NSKeyValueObservationInfo 0x7fc880770fa0&gt; (</div><div class="line">&lt;NSKeyValueObservance 0x7fc880771850: Observer: 0x7fc8804737a0, Key path: accountBalance, Options: &lt;New: YES, Old: YES, Prior: NO&gt; Context: 0x0, Property: 0x7fc88076edd0&gt;</div><div class="line">)'</div><div class="line">......</div></pre></td></tr></table></figure>
<p>程序在调用一次KVO后，很爽快地崩溃了。给我们的解释是<code>bankInstance</code>被释放了，但KVO中仍然还有关于它的注册信息。实际上，我们上面说过，在添加观察者的时候，观察者对象与被观察属性所属的对象都不会被<code>retain</code>，然而在这些对象被释放后，相关的监听信息却还存在，KVO做的处理是直接让程序崩溃。</p>
<h2 id="处理属性修改通知"><a href="#处理属性修改通知" class="headerlink" title="处理属性修改通知"></a>处理属性修改通知</h2><p>当被监听的属性修改时，KVO会发出一个通知以告知所有监听这个属性的观察者对象。而观察者对象必须实现</p>
<p><code>-observeValueForKeyPath:ofObject:change:context:</code>方法，来对属性修改通知做相应的处理。这个方法的声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">                      ofObject:(<span class="keyword">id</span>)object</div><div class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</div><div class="line">                       context:(<span class="keyword">void</span> *)context</div></pre></td></tr></table></figure>
<p>这个方法有四个参数，描述如下：</p>
<ol>
<li><code>keyPath</code>：即被观察的属性，与参数<code>object</code>相关。</li>
<li><code>object</code>：<code>keyPath</code>所属的对象。</li>
<li><code>change</code>：这是一个字典，它包含了属性被修改的一些信息。这个字典中包含的值会根据我们在添加观察者时设置的<code>options</code>参数的不同而有所不同。</li>
<li><code>context</code>：这个值即是添加观察者时提供的上下文信息。</li>
</ol>
<p>在我们的示例中，这个方法的实现是打印一些基本的信息。如代码清单1所示。</p>
<p>对于第三个参数，我们通常称之为<strong>变化字典(Change Dictionary)</strong>，它记录了被监听属性的变化情况。我们可以通过以下key来获取我们想要的信息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 属性变化的类型，是一个NSNumber对象，包含NSKeyValueChange枚举相关的值</span></div><div class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">NSKeyValueChangeKindKey</span>;</div><div class="line"></div><div class="line"><span class="comment">// 属性的新值。当NSKeyValueChangeKindKey是 NSKeyValueChangeSetting，</span></div><div class="line"><span class="comment">// 且添加观察的方法设置了NSKeyValueObservingOptionNew时，我们能获取到属性的新值。</span></div><div class="line"><span class="comment">// 如果NSKeyValueChangeKindKey是NSKeyValueChangeInsertion或者NSKeyValueChangeReplacement，</span></div><div class="line"><span class="comment">// 且指定了NSKeyValueObservingOptionNew时，则我们能获取到一个NSArray对象，包含被插入的对象或</span></div><div class="line"><span class="comment">// 用于替换其它对象的对象。</span></div><div class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">NSKeyValueChangeNewKey</span>;</div><div class="line"></div><div class="line"><span class="comment">// 属性的旧值。当NSKeyValueChangeKindKey是 NSKeyValueChangeSetting，</span></div><div class="line"><span class="comment">// 且添加观察的方法设置了NSKeyValueObservingOptionOld时，我们能获取到属性的旧值。</span></div><div class="line"><span class="comment">// 如果NSKeyValueChangeKindKey是NSKeyValueChangeRemoval或者NSKeyValueChangeReplacement，</span></div><div class="line"><span class="comment">// 且指定了NSKeyValueObservingOptionOld时，则我们能获取到一个NSArray对象，包含被移除的对象或</span></div><div class="line"><span class="comment">// 被替换的对象。</span></div><div class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">NSKeyValueChangeOldKey</span>;</div><div class="line"></div><div class="line"><span class="comment">// 如果NSKeyValueChangeKindKey的值是NSKeyValueChangeInsertion、NSKeyValueChangeRemoval</span></div><div class="line"><span class="comment">// 或者NSKeyValueChangeReplacement，则这个key对应的值是一个NSIndexSet对象，</span></div><div class="line"><span class="comment">// 包含了被插入、移除或替换的对象的索引</span></div><div class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">NSKeyValueChangeIndexesKey</span>;</div><div class="line"></div><div class="line"><span class="comment">// 当指定了NSKeyValueObservingOptionPrior选项时，在属性被修改的通知发送前，</span></div><div class="line"><span class="comment">// 会先发送一条通知给观察者。我们可以使用NSKeyValueChangeNotificationIsPriorKey</span></div><div class="line"><span class="comment">// 来获取到通知是否是预先发送的，如果是，获取到的值总是@(YES)</span></div><div class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">NSKeyValueChangeNotificationIsPriorKey</span>;</div></pre></td></tr></table></figure>
<p>其中，<code>NSKeyValueChangeKindKey</code>的值取自于<code>NSKeyValueChange</code>，它的值是由以下枚举定义的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line"></div><div class="line">	<span class="comment">// 设置一个新值。被监听的属性可以是一个对象，也可以是一对一关系的属性或一对多关系的属性。</span></div><div class="line">   	<span class="built_in">NSKeyValueChangeSetting</span> = <span class="number">1</span>,</div><div class="line">   	</div><div class="line">   	<span class="comment">// 表示一个对象被插入到一对多关系的属性。</span></div><div class="line">   	<span class="built_in">NSKeyValueChangeInsertion</span> = <span class="number">2</span>,</div><div class="line">   	</div><div class="line">   	<span class="comment">// 表示一个对象被从一对多关系的属性中移除。</span></div><div class="line">   	<span class="built_in">NSKeyValueChangeRemoval</span> = <span class="number">3</span>,</div><div class="line">   	</div><div class="line">   	<span class="comment">// 表示一个对象在一对多的关系的属性中被替换</span></div><div class="line">   	<span class="built_in">NSKeyValueChangeReplacement</span> = <span class="number">4</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NSUInteger</span> <span class="built_in">NSKeyValueChange</span>;</div></pre></td></tr></table></figure>
<h2 id="通知观察者属性的变化"><a href="#通知观察者属性的变化" class="headerlink" title="通知观察者属性的变化"></a>通知观察者属性的变化</h2><p>通知观察者的方式有自动与手动两种方式。</p>
<p>默认情况下是自动发送通知，在这种模式下，当我们修改属性的值时，KVO会自动调用以下两个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)willChangeValueForKey:(<span class="built_in">NSString</span> *)key</div><div class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key</div></pre></td></tr></table></figure>
<p>这两个方法的任务是告诉接收者给定的属性将要或已经被修改。需要注意的是不应该在子类中去重写这两个方法。</p>
<p>但如果我们希望自己控制通知发送的一些细节，则可以启用手动控制模式。手动控制通知提供了对KVO更精确控制，它可以控制通知如何以及何时被发送给观察者。采用这种方式可以减少不必要的通知，或者可以将多个修改组合到一个修改中。</p>
<p>实现手动通知的类必须重写<code>NSObject</code>中对<code>automaticallyNotifiesObserversForKey:</code>方法的实现。这个方法是在<code>NSKeyValueObserving</code>协议中声明的，其声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class="built_in">NSString</span> *)key</div></pre></td></tr></table></figure>
<p>这个方法返回一个布尔值(默认是返回YES)，以标识参数key指定的属性是否支持自动KVO。如果我们希望手动去发送通知，则针对指定的属性返回NO。</p>
<p>假设我们希望<code>PersonObject</code>对象去监听<code>BankObject</code>对象的<code>bankCodeEn</code>属性，并希望执行手动通知，则可以如下处理：</p>
<p><strong>代码清单4：关闭属性的自动通知发送</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BankObject</span></span></div><div class="line"></div><div class="line">+ (<span class="built_in">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">BOOL</span> automatic = <span class="literal">YES</span>;</div><div class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"bankCodeEn"</span>]) &#123;</div><div class="line">        automatic = <span class="literal">NO</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        automatic = [<span class="keyword">super</span> automaticallyNotifiesObserversForKey:key];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> automatic;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这样我们便可以手动去发送属性修改通知了。需要注意的是，对于对象中其它没有处理的属性，我们需要调用<code>[super automaticallyNotifiesObserversForKey:key]</code>，以避免无意中修改了父类的属性的处理方式。</p>
<p>现在我们已经通过<code>+automaticallyNotifiesObserversForKey:</code>方法设置了对象中哪些属性需要手动处理。接下来就是实际操作了。为了实现手动发送通知，我们需要在修改属性值前调用<code>willChangeValueForKey:</code>，然后在修改属性值之后调用<code>didChangeValueForKey:</code>方法。继续上面的示例，我们需要对<code>bankCodeEn</code>属性做如下处理：</p>
<p><strong>代码清单5：手动控制通知发送</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BankObject</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setBankCodeEn:(<span class="built_in">NSString</span> *)bankCodeEn &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"bankCodeEn"</span>];</div><div class="line">    _bankCodeEn = bankCodeEn;</div><div class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"bankCodeEn"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>如果我们希望只有当<code>bankCodeEn</code>实际被修改时发送通知，以尽量减少不必要的通知，则可以如下实现：</p>
<p><strong>代码清单6：在发送通知前测试值是否修改</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setBankCodeEn:(<span class="built_in">NSString</span> *)bankCodeEn &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (bankCodeEn != _bankCodeEn) &#123;</div><div class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"bankCodeEn"</span>];</div><div class="line">        _bankCodeEn = bankCodeEn;</div><div class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"bankCodeEn"</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们来测试一下上面这段代码的实际效果：</p>
<p><strong>代码清单7：测试避免属性未实际修改下不发送通知</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">PersonObject    *personInstance = [[PersonObject alloc] init];</div><div class="line">BankObject      *bankInstance = [[BankObject alloc] init];</div><div class="line"></div><div class="line">[bankInstance addObserver:personInstance forKeyPath:<span class="string">@"bankCodeEn"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">NULL</span>];</div><div class="line"></div><div class="line"><span class="built_in">NSString</span> *bankCodeEn = <span class="string">@"CCB"</span>;</div><div class="line">bankInstance.bankCodeEn = bankCodeEn;</div><div class="line">bankInstance.bankCodeEn = bankCodeEn;</div></pre></td></tr></table></figure>
<p>这段代码的输出结果如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">keyPath = bankCodeEn, change = &#123;</div><div class="line">    kind = <span class="number">1</span>;</div><div class="line">    new = CCB;</div><div class="line">&#125;, context = (null)</div></pre></td></tr></table></figure>
<p>我们可以看到只输出了一次，而不是两次。</p>
<p>如果我们在<code>setter</code>方法之外改变了实例变量(如<code>_bankCodeEn</code>)，且希望这种修改被观察者监听到，则需要像在<code>setter</code>方法里面做一样的处理。这也涉及到我们通常会遇到的一个问题，在类的内部，对于一个属性值，何时用属性(<code>self.bankCodeEn</code>)访问而何时用实例变量(<code>_bankCodeEn</code>)访问。一般的建议是，在获取属性值时，可以用实例变量，在设置属性值时，尽量用<code>setter</code>方法，以保证属性的<code>KVO</code>特性。当然，性能也是一个考量，在设置值时，使用实例变量比使用属性设置值的性能高不少。</p>
<p>另外，对于一对多关系的属性，如果想手动处理通知，则可以使用以下几个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 有序的一对多关系</span></div><div class="line">- (<span class="keyword">void</span>)willChange:(<span class="built_in">NSKeyValueChange</span>)change valuesAtIndexes:(<span class="built_in">NSIndexSet</span> *)indexes forKey:(<span class="built_in">NSString</span> *)key</div><div class="line">- (<span class="keyword">void</span>)didChange:(<span class="built_in">NSKeyValueChange</span>)change valuesAtIndexes:(<span class="built_in">NSIndexSet</span> *)indexes forKey:(<span class="built_in">NSString</span> *)key</div><div class="line">  </div><div class="line"><span class="comment">// 无序的一对多关系</span></div><div class="line">- (<span class="keyword">void</span>)willChangeValueForKey:(<span class="built_in">NSString</span> *)key withSetMutation:(<span class="built_in">NSKeyValueSetMutationKind</span>)mutationKind usingObjects:(<span class="built_in">NSSet</span> *)objects</div><div class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key withSetMutation:(<span class="built_in">NSKeyValueSetMutationKind</span>)mutationKind usingObjects:(<span class="built_in">NSSet</span> *)objects</div></pre></td></tr></table></figure>
<p>同样，在子类中也不应该去重写这几个方法。</p>
<h2 id="计算属性-注册依赖键"><a href="#计算属性-注册依赖键" class="headerlink" title="计算属性(注册依赖键)"></a>计算属性(注册依赖键)</h2><p>有时候，我们的监听的某个属性可能会依赖于其它多个属性的变化(类似于<code>swift</code>，可以称之为计算属性)，不管所依赖的哪个属性发生了变化，都会导致计算属性的变化。对于这种一对一(<code>To-one</code>)的关系，我们需要做两步操作，首先是确定计算属性与所依赖属性的关系。如我们在<code>BankObject</code>类中定义一个<code>accountForBank</code>属性，其<code>get</code>方法定义如下：</p>
<p><strong>代码清单8：计算属性</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BankObject</span></span></div><div class="line"></div><div class="line">- (<span class="built_in">NSString</span> *)accountForBank &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"account for %@ is %d"</span>, <span class="keyword">self</span>.bankCodeEn, <span class="keyword">self</span>.accountBalance];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>定义了这种依赖关系后，我们就需要以某种方式告诉<code>KVO</code>，当我们的被依赖属性修改时，会发送<code>accountForBank</code>属性被修改的通知。此时，我们需要重写<code>NSKeyValueObserving</code>协议的<code>keyPathsForValuesAffectingValueForKey:</code>方法，该方法声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingValueForKey:(<span class="built_in">NSString</span> *)key</div></pre></td></tr></table></figure>
<p>这个方法返回的是一个集合对象，包含了那些影响key指定的属性依赖的属性所对应的字符串。所以对于<code>accountForBank</code>属性，该方法的实现如下：</p>
<p><strong>代码清单9：accountForBank属性的keyPathsForValuesAffectingValueForKey方法的实现</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BankObject</span></span></div><div class="line"></div><div class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingValueForKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSSet</span> *keyPaths = [<span class="keyword">super</span> keyPathsForValuesAffectingValueForKey:key];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"accountForBank"</span>]) &#123;</div><div class="line">        </div><div class="line">        keyPaths = [keyPaths setByAddingObjectsFromArray:@[<span class="string">@"accountBalance"</span>, <span class="string">@"bankCodeEn"</span>]];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> keyPaths;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>我们来再来看看监听<code>accountForBank</code>属性是什么效果：</p>
<p><strong>代码清单10：监听accountForBank属性</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">PersonObject    *personInstance = [[PersonObject alloc] init];</div><div class="line">BankObject      *bankInstance = [[BankObject alloc] init];</div><div class="line"></div><div class="line">[bankInstance addObserver:personInstance forKeyPath:<span class="string">@"accountForBank"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">NULL</span>];</div><div class="line"></div><div class="line">bankInstance.accountBalance = <span class="number">10</span>;</div><div class="line">bankInstance.bankCodeEn = <span class="string">@"CCB"</span>;</div></pre></td></tr></table></figure>
<p>其输出结果为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">keyPath = accountForBank, change = &#123;</div><div class="line">    kind = <span class="number">1</span>;</div><div class="line">    new = <span class="string">"account for (null) is 10"</span>;</div><div class="line">&#125;, context = (null)</div><div class="line">keyPath = accountForBank, change = &#123;</div><div class="line">    kind = <span class="number">1</span>;</div><div class="line">    new = <span class="string">"account for CCB is 10"</span>;</div><div class="line">&#125;, context = (null)</div></pre></td></tr></table></figure>
<p>可以看到，不管是<code>accountBalance</code>还是<code>bankCodeEn</code>被修改了，都会发送<code>accountForBank</code>属性被修改的通知。</p>
<p>需要注意的就是当我们重写<code>+keyPathsForValuesAffectingValueForKey:</code>时，需要去调用<code>super</code>的对应方法，并返回一个包含父类中可能会对<code>key</code>指定属性产生影响的属性集合。</p>
<p>另外，我们还可以实现一个命名为<code>keyPathsForValuesAffecting\&lt;Key\&gt;</code>的类方法来达到同样的目的，其中<code>&lt;Key&gt;</code>是我们计算属性的名称。所以对于<code>accountForBank</code>属性，还可以如下实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingAccountForBank &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"accountBalance"</span>, <span class="string">@"bankCodeEn"</span>, <span class="literal">nil</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>两种方法的实现效果是一样的。不过更建议使用后面一种方法，这种方法让依赖关系更加清晰明了。</p>
<h2 id="集合属性的监听"><a href="#集合属性的监听" class="headerlink" title="集合属性的监听"></a>集合属性的监听</h2><p><code>keyPathsForValuesAffectingValueForKey:</code>只支持一对一的关系，而不支持一对多的关系，即不支持对集合的处理。</p>
<p>对于集合的<code>KVO</code>，我们需要了解的一点是，<code>KVO</code>旨在观察关系(<code>relationship</code>)而不是集合。对于不可变集合属性，我们更多的是把它当成一个整体来监听，而无法去监听集合中的某个元素的变化；对于可变集合属性，实际上也是当成一个整体，去监听它整体的变化，如添加、删除和替换元素。</p>
<p>在KVC中，我们可以使用<strong>集合代理对象(collection proxy object)</strong>来处理集合相关的操作。我们以数组为例，在我们的<code>BankObject</code>类中有一个<code>departments</code>数组属性，如果我们希望通过集合代理对象来负责响应<code>departments</code>所有的方法，则需要实现以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">-countOf&lt;Key&gt;</div><div class="line"></div><div class="line"><span class="comment">// 以下两者二选一</span></div><div class="line">-objectIn&lt;Key&gt;AtIndex:</div><div class="line">-&lt;key&gt;AtIndexes:</div><div class="line"></div><div class="line"><span class="comment">// 可选（增强性能）</span></div><div class="line">-get&lt;Key&gt;:range:</div></pre></td></tr></table></figure>
<p>因此，我们的实现以下几个方法：</p>
<p><strong>代码清单11：集合代码对象的实现</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BankObject</span></span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - 集合代理对象</span></div><div class="line"></div><div class="line">- (<span class="built_in">NSUInteger</span>)countOfDepartments &#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [_departments count];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)objectInDepartmentsAtIndex:(<span class="built_in">NSUInteger</span>)index &#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [_departments objectAtIndex:index];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>实现以上方法之后，对于不可变数组，当我们调用<code>[bankInstance valueForKey:@&quot;departments&quot;]</code>的时候，便会返回一个由以上方法来代理所有调用方法的~对象。这个代理数组对象支持所有正常的<code>NSArray</code>调用。换句话说，调用者并不知道返回的是一个真正的<code>NSArray</code>，还是一个代理的数组。</p>
<p>另外，对于可变数组的代理对象，我们需要实现以下几个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 至少实现一个插入方法和一个删除方法</span></div><div class="line">-insertObject:<span class="keyword">in</span>&lt;Key&gt;AtIndex:</div><div class="line">-removeObjectFrom&lt;Key&gt;AtIndex:</div><div class="line">-insert&lt;Key&gt;:atIndexes:</div><div class="line">-remove&lt;Key&gt;AtIndexes:</div><div class="line"></div><div class="line"><span class="comment">// 可选（增强性能）以下方法二选一</span></div><div class="line">-replaceObjectIn&lt;Key&gt;AtIndex:withObject:</div><div class="line">-replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;:</div></pre></td></tr></table></figure>
<p>这些方法分别对应插入、删除和替换，有批量操作的，也有只改变一个对象的方法。可以根据实际需要来实现。</p>
<p>另外，对于可变集合，我们通常不使用<code>valueForKey:</code>来获取代理对象，而是使用以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSMutableArray</span> *)mutableArrayValueForKey:(<span class="built_in">NSString</span> *)key;</div></pre></td></tr></table></figure>
<p>通过这个方法，我们便可以将可变数组与强大的<code>KVO</code>结合在一起。<code>KVO</code>机制能在集合改变的时候把详细的变化放进<code>change</code>字典中。</p>
<p>我们先来看看下面的代码：</p>
<p><strong>代码清单12：使用真正的数组对象监听可变数组属性</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">BankObject *bankInstance = [[BankObject alloc] init];</div><div class="line"></div><div class="line">PersonObject    *personInstance = [[PersonObject alloc] init];</div><div class="line">[bankInstance addObserver:personInstance forKeyPath:<span class="string">@"departments"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span> context:<span class="literal">NULL</span>];</div><div class="line"></div><div class="line">bankInstance.departments = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line"></div><div class="line">[bankInstance.departments addObject:<span class="string">@"departments"</span>];</div></pre></td></tr></table></figure>
<p>其输出为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">keyPath = departments, change = &#123;</div><div class="line">    kind = <span class="number">1</span>;</div><div class="line">    new =     (</div><div class="line">    );</div><div class="line">    old =     (</div><div class="line">    );</div><div class="line">&#125;, context = (null)</div></pre></td></tr></table></figure>
<p>可以看到通过这种方法，我们获取的是真正的数组，只在<code>departments</code>属性整体被修改时，才会触发<code>KVO</code>，而在添加元素时，并没有触发<code>KVO</code>。</p>
<p>现在我们通过代理集合对象来看看：</p>
<p><strong>代码清单13：使用代理集合对象监听可变数组属性</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">BankObject *bankInstance = [[BankObject alloc] init];</div><div class="line"></div><div class="line">PersonObject    *personInstance = [[PersonObject alloc] init];</div><div class="line">[bankInstance addObserver:personInstance forKeyPath:<span class="string">@"departments"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span> context:<span class="literal">NULL</span>];</div><div class="line"></div><div class="line">bankInstance.departments = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line"></div><div class="line"><span class="built_in">NSMutableArray</span> *departments = [bankInstance mutableArrayValueForKey:<span class="string">@"departments"</span>];</div><div class="line">[departments insertObject:<span class="string">@"departments 0"</span> atIndex:<span class="number">0</span>];</div></pre></td></tr></table></figure>
<p>其输出是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">keyPath = departments, change = &#123;</div><div class="line">    kind = <span class="number">1</span>;</div><div class="line">    new =     (</div><div class="line">    );</div><div class="line">    old =     (</div><div class="line">    );</div><div class="line">&#125;, context = (null)</div><div class="line">keyPath = departments, change = &#123;</div><div class="line">    indexes = <span class="string">"&lt;NSIndexSet: 0x7fcd18673150&gt;[number of indexes: 1 (in 1 ranges), indexes: (0)]"</span>;</div><div class="line">    kind = <span class="number">2</span>;</div><div class="line">    new =     (</div><div class="line">        <span class="string">"departments 0"</span></div><div class="line">    );</div><div class="line">&#125;, context = (null)</div></pre></td></tr></table></figure>
<p>可以看到，在往数组中添加对象时，也触发了KVO，并将改变的详细信息也写进了<code>change</code>字典。在第二个消息中，<code>kind</code>的值为2，即表示这是一次插入操作。同样，可变数组的删除，替换操作也是一样的。</p>
<p>集合(<code>Set</code>)也有一套对应的方法来实现集合代理对象，包括无序集合与有序集合；而字典则没有，对于字典属性的监听，还是只能作为一个整理来处理。</p>
<p>如果我们想到手动控制集合属性消息的发送，则可以使用上面提到的几个方法，即：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-willChange:valuesAtIndexes:forKey:</div><div class="line">-didChange:valuesAtIndexes:forKey:</div><div class="line"></div><div class="line">或</div><div class="line"></div><div class="line">-willChangeValueForKey:withSetMutation:usingObjects:</div><div class="line">-didChangeValueForKey:withSetMutation:usingObjects:</div></pre></td></tr></table></figure>
<p>不过得先保证把自动通知关闭，否则每次改变<code>KVO</code>都会被发送两次。</p>
<h2 id="监听信息"><a href="#监听信息" class="headerlink" title="监听信息"></a>监听信息</h2><p>如果我们想获取一个对象上有哪些观察者正在监听其属性的修改，则可以查看对象的<code>observationInfo</code>属性，其声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> <span class="keyword">void</span> *observationInfo</div></pre></td></tr></table></figure>
<p>可以看到它是一个<code>void</code>指针，指向一个包含所有观察者的一个标识信息对象，这些信息包含了每个监听的观察者，注册时设定的选项等等。我们还是用示例来看看。</p>
<p><strong>代码清单14：observationInfo的使用</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">PersonObject    *personInstance = [[PersonObject alloc] init];</div><div class="line">BankObject      *bankInstance = [[BankObject alloc] init];</div><div class="line"></div><div class="line">[bankInstance addObserver:personInstance forKeyPath:<span class="string">@"bankCodeEn"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">NULL</span>];</div><div class="line">[bankInstance addObserver:personInstance forKeyPath:<span class="string">@"accountBalance"</span> options:<span class="built_in">NSKeyValueObservingOptionOld</span> context:<span class="literal">NULL</span>];</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p"</span>, personInstance);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p"</span>, bankInstance);</div><div class="line"></div><div class="line"><span class="keyword">id</span> info = bankInstance.observationInfo;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [info description]);</div></pre></td></tr></table></figure>
<p>其输出结果如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">personInstance = <span class="number">0x7fdc2369e5e0</span></div><div class="line">bankInstance = <span class="number">0x7fdc2369d8f0</span></div><div class="line">&lt;<span class="built_in">NSKeyValueObservationInfo</span> <span class="number">0x7fdc236a19d0</span>&gt; (</div><div class="line">&lt;<span class="built_in">NSKeyValueObservance</span> <span class="number">0x7fdc236a17a0</span>: Observer: <span class="number">0x7fdc2369e5e0</span>, Key path: bankCodeEn, Options: &lt;New: <span class="literal">YES</span>, Old: <span class="literal">NO</span>, Prior: <span class="literal">NO</span>&gt; Context: <span class="number">0x0</span>, Property: <span class="number">0x7fdc236a15c0</span>&gt;</div><div class="line">&lt;<span class="built_in">NSKeyValueObservance</span> <span class="number">0x7fdc236a1960</span>: Observer: <span class="number">0x7fdc2369e5e0</span>, Key path: accountBalance, Options: &lt;New: <span class="literal">NO</span>, Old: <span class="literal">YES</span>, Prior: <span class="literal">NO</span>&gt; Context: <span class="number">0x0</span>, Property: <span class="number">0x7fdc236a1880</span>&gt;</div><div class="line">)</div></pre></td></tr></table></figure>
<p>我们可以看到<code>observationInfo</code>指针实际上是指向一个<code>NSKeyValueObservationInfo</code>对象，它包含了指定对象上的所有的监听信息。而每条监听信息而是封装在一个<code>NSKeyValueObservance</code>对象中，从上面可以看到，这个对象中包含消息的观察者、被监听的属性、添加观察者时所设置的一些选项、上下文信息等。</p>
<p><code>NSKeyValueObservationInfo</code>类及<code>NSKeyValueObservance</code>类都是私有类，我们无法在官方文档中找到这两个类的实现。不过从一些对系统库<code>dump</code>出来的头文件，我们可以对这两个类有一些初步的了解。<a href="https://github.com/a1anyip/iOS-SDK-4.3-Framework-Header-Dump/tree/master/Frameworks/Foundation.framework" target="_blank" rel="external">这里</a>有一个对<code>iOS SKD 4.3</code>的<code>Foundation.framework</code>的<code>dump</code>头文件，可以找到这两个类的头文件，其中<code>NSKeyValueObservationInfo</code>的头文件信息如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;XXUnknownSuperclass.h&gt;</span> // Unknown library</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@class</span> <span class="title">NSArray</span>, <span class="title">NSHashTable</span>;</span></div><div class="line"></div><div class="line">__attribute__((visibility(<span class="string">"hidden"</span>)))</div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSKeyValueObservationInfo</span> : <span class="title">XXUnknownSuperclass</span> </span>&#123;</div><div class="line"><span class="keyword">@private</span></div><div class="line">	<span class="keyword">int</span> _retainCountMinusOne;</div><div class="line">	<span class="built_in">NSArray</span>* _observances;</div><div class="line">	<span class="keyword">unsigned</span> _cachedHash;</div><div class="line">	<span class="built_in">BOOL</span> _cachedIsShareable;</div><div class="line">	<span class="built_in">NSHashTable</span>* _observables;</div><div class="line">&#125;</div><div class="line">-(<span class="keyword">id</span>)_initWithObservances:(<span class="keyword">id</span>*)observances count:(<span class="keyword">unsigned</span>)count;</div><div class="line">-(<span class="keyword">id</span>)<span class="keyword">retain</span>;</div><div class="line">-(<span class="keyword">oneway</span> <span class="keyword">void</span>)release;</div><div class="line">-(<span class="keyword">unsigned</span>)retainCount;</div><div class="line">-(<span class="keyword">void</span>)dealloc;</div><div class="line">-(<span class="keyword">unsigned</span>)hash;</div><div class="line">-(<span class="built_in">BOOL</span>)isEqual:(<span class="keyword">id</span>)equal;</div><div class="line">-(<span class="keyword">id</span>)description;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>可以看到其中有一个数组来存储<code>NSKeyValueObservance</code>对象。</p>
<p><code>NSKeyValueObservance</code>类的头文件信息如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"Foundation-Structs.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;XXUnknownSuperclass.h&gt;</span> // Unknown library</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@class</span> <span class="title">NSPointerArray</span>, <span class="title">NSKeyValueProperty</span>, <span class="title">NSObject</span>;</span></div><div class="line"></div><div class="line">__attribute__((visibility(<span class="string">"hidden"</span>)))</div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSKeyValueObservance</span> : <span class="title">XXUnknownSuperclass</span> </span>&#123;</div><div class="line"><span class="keyword">@private</span></div><div class="line">	<span class="keyword">int</span> _retainCountMinusOne;</div><div class="line">	<span class="built_in">NSObject</span>* _observer;</div><div class="line">	<span class="built_in">NSKeyValueProperty</span>* _property;</div><div class="line">	<span class="keyword">unsigned</span> _options;</div><div class="line">	<span class="keyword">void</span>* _context;</div><div class="line">	<span class="built_in">NSObject</span>* _originalObservable;</div><div class="line">	<span class="keyword">unsigned</span> _cachedUnrotatedHashComponent;</div><div class="line">	<span class="built_in">BOOL</span> _cachedIsShareable;</div><div class="line">	<span class="built_in">NSPointerArray</span>* _observationInfos;</div><div class="line">	auto_weak_callback_block _observerWentAwayCallback;</div><div class="line">&#125;</div><div class="line">-(<span class="keyword">id</span>)_initWithObserver:(<span class="keyword">id</span>)observer property:(<span class="keyword">id</span>)property options:(<span class="keyword">unsigned</span>)options context:(<span class="keyword">void</span>*)context originalObservable:(<span class="keyword">id</span>)observable;</div><div class="line">-(<span class="keyword">id</span>)<span class="keyword">retain</span>;</div><div class="line">-(<span class="keyword">oneway</span> <span class="keyword">void</span>)release;</div><div class="line">-(<span class="keyword">unsigned</span>)retainCount;</div><div class="line">-(<span class="keyword">void</span>)dealloc;</div><div class="line">-(<span class="keyword">unsigned</span>)hash;</div><div class="line">-(<span class="built_in">BOOL</span>)isEqual:(<span class="keyword">id</span>)equal;</div><div class="line">-(<span class="keyword">id</span>)description;</div><div class="line">-(<span class="keyword">void</span>)observeValueForKeyPath:(<span class="keyword">id</span>)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="keyword">id</span>)change context:(<span class="keyword">void</span>*)context;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>可以看到其中包含了一个监听的基本要素。在此不再做深入分析(没有源代码，深入不下去了啊)。</p>
<p>我们再回到<code>observationInfo</code>属性本身来。在文档中，对这个属性的描述有这样一段话：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">The <span class="keyword">default</span> implementation of <span class="keyword">this</span> method retrieves the information from a global</div><div class="line">dictionary keyed by the receiver’s pointers.</div></pre></td></tr></table></figure>
<p>即这个方法的默认实现是以对象的指针作为key，从一个全局的字典中获取信息。由此，我们可以理解为，KVO的信息是存储在一个全局字典中，而不是存储在对象本身。这类似于<code>Notification</code>，所有关于通知的信息都是放在<code>NSNotificationCenter</code>中。</p>
<p>不过，为了提高效率，我们可以重写<code>observationInfo</code>属性的set和get方法，以将这个不透明的数据指针存储到一个实例变量中。但是，在重写时，我们不应该尝试去向这些数据发送一个<code>Objective-C</code>消息，包括<code>retain</code>和<code>release</code>。</p>
<h2 id="KVO的实现机制"><a href="#KVO的实现机制" class="headerlink" title="KVO的实现机制"></a>KVO的实现机制</h2><p>【本来这一小节是想放在另一篇总结中来写的，但后来觉得还是放在这里比较合适，所以就此添加上】</p>
<p>了解了<code>NSKeyValueObserving</code>所提供的功能后，我们再来看看KVO的实现机制，以便更深入地的理解KVO。</p>
<p>KVO据我所查还没有开源(若哪位大大有查到源代码，还烦请告知)，所以我们无法从源代码的层面来分析它的实现。不过<a href="https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html" target="_blank" rel="external">Mike Ash</a>的博文(译文见参考文献4)为我们解开了一些谜团。</p>
<p>基本的思路是：<code>Objective-C</code>依托于强大的<code>runtime</code>机制来实现KVO。当我们第一次观察某个对象的属性时，<code>runtime</code>会创建一个新的继承自这个对象的<code>class</code>的<code>subclass</code>。在这个新的<code>subclass</code>中，它会重写所有被观察的<code>key</code>的<code>setter</code>，然后将<code>object</code>的<code>isa</code>指针指向新创建的<code>class</code>(这个指针告诉<code>Objective-C</code>运行时某个<code>object</code>到底是什么类型的)。所以<code>object</code>神奇地变成了新的子类的实例。</p>
<p>嗯，让我们通过代码来看看实际的实现：</p>
<p><strong>代码清单15：探究KVO的实现机制</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 辅助方法</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> *ClassMethodNames(Class c) &#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> methodCount = <span class="number">0</span>;</div><div class="line">    Method *methodList = class_copyMethodList(c, &amp;methodCount);</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; methodCount; i++) &#123;</div><div class="line">        [array addObject:<span class="built_in">NSStringFromSelector</span>(method_getName(methodList[i]))];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    free(methodList);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> array;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> PrintDescription(<span class="built_in">NSString</span> *name, <span class="keyword">id</span> obj) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> objc_object *objcet = (__bridge <span class="keyword">struct</span> objc_object *)obj;</div><div class="line">    </div><div class="line">    Class cls = objcet-&gt;isa;</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@: %@\n\tNSObject class %s\n\tlibobjc class %s : super class %s\n\timplements methods &lt;%@&gt;"</span>,</div><div class="line">                     name,</div><div class="line">                     obj,</div><div class="line">                     class_getName([obj <span class="keyword">class</span>]),</div><div class="line">                     class_getName(cls),</div><div class="line">                     class_getName(class_getSuperclass(cls)),</div><div class="line">                     [ClassMethodNames(cls) componentsJoinedByString:<span class="string">@", "</span>]];</div><div class="line">    printf(<span class="string">"%s\n"</span>, [str UTF8String]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 测试代码</span></div><div class="line">BankObject *bankInstance1 = [[BankObject alloc] init];</div><div class="line">BankObject *bankInstance2 = [[BankObject alloc] init];</div><div class="line"></div><div class="line">PersonObject *personInstance = [[PersonObject alloc] init];</div><div class="line"></div><div class="line">[bankInstance2 addObserver:personInstance forKeyPath:<span class="string">@"accountBalance"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">NULL</span>];</div><div class="line"></div><div class="line">PrintDescription(<span class="string">@"bankInstance1"</span>, bankInstance1);</div><div class="line">PrintDescription(<span class="string">@"bankInstance2"</span>, bankInstance2);</div><div class="line"></div><div class="line">printf(<span class="string">"Using libobjc functions, normal setAccountBalance: is %p, overridden setAccountBalance: is %p"</span>, method_getImplementation(class_getInstanceMethod(object_getClass(bankInstance2), <span class="keyword">@selector</span>(setAccountBalance:))),</div><div class="line">       method_getImplementation(class_getInstanceMethod(object_getClass(bankInstance1), <span class="keyword">@selector</span>(setAccountBalance:))));</div></pre></td></tr></table></figure>
<p>这段代码的输出如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">bankInstance1: &lt;BankObject: <span class="number">0x7f9e8ae3cf60</span>&gt;</div><div class="line">	<span class="built_in">NSObject</span> <span class="keyword">class</span> BankObject</div><div class="line">	libobjc <span class="keyword">class</span> BankObject : <span class="keyword">super</span> <span class="keyword">class</span> <span class="built_in">NSObject</span></div><div class="line">	implements methods &lt;accountBalance, setAccountBalance:, bankCodeEn, setBankCodeEn:, departments, setDepartments:&gt;</div><div class="line">	</div><div class="line">bankInstance2: &lt;BankObject: <span class="number">0x7f9e8ae3cfc0</span>&gt;</div><div class="line">	<span class="built_in">NSObject</span> <span class="keyword">class</span> BankObject</div><div class="line">	libobjc <span class="keyword">class</span> <span class="built_in">NSKVONotifying_BankObject</span> : <span class="keyword">super</span> <span class="keyword">class</span> BankObject</div><div class="line">	implements methods &lt;setAccountBalance:, <span class="keyword">class</span>, dealloc, _isKVOA&gt;</div><div class="line">	</div><div class="line">Using libobjc functions, normal setAccountBalance: is <span class="number">0x1013cec17</span>, overridden setAccountBalance: is <span class="number">0x10129fe50</span></div></pre></td></tr></table></figure>
<p>从输出中可以看到，<code>bankInstance2</code>监听<code>accountBalance</code>属性后，其实际上所属的类已经不是<code>BankObject</code>了，而是继承自<code>BankObject</code>的<code>NSKVONotifying_BankObject</code>类。同时，<code>NSKVONotifying_BankObject</code>类重写了<code>setAccountBalance</code>方法，这个方法将实现如何通知观察者们的操作。当改变<code>accountBalance</code>属性时，就会调用被重写的<code>setAccountBalance</code>方法，并通过这个方法来发送通知。</p>
<p>另外我们也可以看到<code>bankInstance2</code>对象的打印<code>[bankInstance2 class]</code>时，返回的仍然是<code>BankObject</code>。这是苹果故意而为之，他们不希望这个机制暴露在外面。所以除了重写相应的<code>setter</code>，所以动态生成的<code>NSKVONotifying_BankObject</code>类还重写了<code>class</code>方法，让它返回原先的类。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>KVO作为<code>Objective-C</code>中两个对象间通信机制中的一种，提供了一种非常强大的机制。在经典的MVC架构中，控制器需要确保视图与模型的同步，当<code>model</code>对象改变时，视图应该随之改变以反映模型的变化；当用户和控制器交互的时候，模型也应该做出相应的改变。而KVO便为我们提供了这样一种同步机制：我们让控制器去监听一个<code>model</code>对象属性的改变，并根据这种改变来更新我们的视图。所有，有效地使用KVO，对我们应用的开发意义重大。</p>
<p>别话：对KVO的总结感觉还是意犹未尽，总感觉缺少点什么，特别是在对集合这一块的处理。还请大家多多提供指点。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Protocols/NSKeyValueObserving_Protocol/#//apple_ref/occ/instm/NSObject/observationInfo" target="_blank" rel="external">NSKeyValueObserving Protocol Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html" target="_blank" rel="external">Key-Value Observing Programming Guide</a></li>
<li><a href="https://github.com/a1anyip/iOS-SDK-4.3-Framework-Header-Dump" target="_blank" rel="external">iOS-SDK-4.3-Framework-Header-Dump</a></li>
<li><a href="http://objccn.io/issue-7-3/" target="_blank" rel="external">KVC 和 KVO</a></li>
<li><a href="http://www.appcoda.com/understanding-key-value-observing-coding/" target="_blank" rel="external">Understanding Key-Value Observing and Coding</a></li>
<li><a href="http://www.cocoachina.com/ios/20140107/7667.html" target="_blank" rel="external">KVO的内部实现</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/03/24/sourcecode-mbprogresshud/" itemprop="url">
                  MBProgressHUD实现分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-03-24T20:41:51+08:00" content="2015-03-24">
              2015-03-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/sourcecode/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>源码来源：<a href="https://github.com/jdg/MBProgressHUD" target="_blank" rel="external">https://github.com/jdg/MBProgressHUD</a></p>
<p>版本：0.9.1</p>
<p><code>MBProgressHUD</code>是一个显示<code>HUD</code>窗口的第三方类库，用于在执行一些后台任务时，在程序中显示一个表示进度的<code>loading</code>视图和两个可选的文本提示的<code>HUD</code>窗口。我想最多是应用在加载网络数据的时候。其实苹果官方自己有一个带有此功能的类<code>UIProgressHUD</code>，只不过它是私有的，现在不让用。至于实际的效果，可以看看<code>github</code>上工程给出的几张图例(貌似我这经常无法单独打开图片，所以就不在这贴图片了)，也可以运行一下<code>Demo</code>。</p>
<p>具体用法我们就不多说了，参考<code>github</code>上的说明就能用得很顺的。本文主要还是从源码的角度来分析一下它的具体实现。</p>
<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>在分析实现代码之前，我们先来看看<code>MBProgressHUD</code>中定义的<code>MBProgressHUDMode</code>枚举。它用来表示<code>HUD</code>窗口的模式，即我们从效果图中看到的几种显示样式。其具体定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</div><div class="line">    <span class="comment">// 使用UIActivityIndicatorView来显示进度，这是默认值</span></div><div class="line">    MBProgressHUDModeIndeterminate,</div><div class="line">    </div><div class="line">    <span class="comment">// 使用一个圆形饼图来作为进度视图</span></div><div class="line">    MBProgressHUDModeDeterminate,</div><div class="line">    </div><div class="line">    <span class="comment">// 使用一个水平进度条</span></div><div class="line">    MBProgressHUDModeDeterminateHorizontalBar,</div><div class="line">    </div><div class="line">    <span class="comment">// 使用圆环作为进度条</span></div><div class="line">    MBProgressHUDModeAnnularDeterminate,</div><div class="line">    </div><div class="line">    <span class="comment">// 显示一个自定义视图，通过这种方式，可以显示一个正确或错误的提示图</span></div><div class="line">    MBProgressHUDModeCustomView,</div><div class="line">    </div><div class="line">    <span class="comment">// 只显示文本</span></div><div class="line">    MBProgressHUDModeText</div><div class="line">    </div><div class="line">&#125; MBProgressHUDMode;</div></pre></td></tr></table></figure>
<p>通过设置<code>MBProgressHUD</code>的模式，我们可以使用<code>MBProgressHUD</code>自定义的表示进度的视图来满足我们的需求，也可以自定义这个进度视图，当然还可以只显示文本。在下面我们会讨论源码中是如何使用这几个值的。</p>
<h2 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h2><p>我们先来了解一下<code>MBProgressHUD</code>的基本组成。一个<code>MBProgressHUD</code>视图主要由四个部分组成：</p>
<ol>
<li><code>loading</code>动画视图(在此做个统称，当然这个区域可以是自定义的一个<code>UIImageView</code>视图)。这个视图由我们设定的模式值决定，可以是菊花、进度条，也可以是我们自定义的视图；</li>
<li>标题文本框(<code>label</code>)：主要用于显示提示的主题信息。这个文本框是可选的，通常位于<code>loading</code>动画视图的下面，且它是单行显示。它会根据<code>labelText</code>属性来自适应文本的大小(有一个长度上限)，如果过长，则超出的部分会显示为”…”；</li>
<li>详情文本框(<code>detailsLabel</code>)。如果觉得标题不够详细，或者有附属信息，就可以将详细信息放在这里面显示。该文本框对应的是显示<code>detailsLabelText</code>属性的值，它是可以多行显示的。另外，详情的显示还依赖于<code>labelText</code>属性的设置，只有<code>labelText</code>属性被设置了，且不为空串，才会显示<code>detailsLabel</code>；</li>
<li><code>HUD</code>背景框。主要是作为上面三个部分的一个背景，用来突出上面三部分。</li>
</ol>
<p>为了让我们更好地自定义这几个部分，<code>MBProgressHUD</code>还提供了一些属性，我们简单了解一下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 背景框的透明度，默认值是0.8</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="keyword">float</span> opacity;</div><div class="line"></div><div class="line"><span class="comment">// 背景框的颜色</span></div><div class="line"><span class="comment">// 需要注意的是如果设置了这个属性，则opacity属性会失效，即不会有半透明效果</span></div><div class="line"><span class="keyword">@property</span> (MB_STRONG) <span class="built_in">UIColor</span> *color;</div><div class="line"></div><div class="line"><span class="comment">// 背景框的圆角半径。默认值是10.0</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="keyword">float</span> cornerRadius;</div><div class="line"></div><div class="line"><span class="comment">// 标题文本的字体及颜色</span></div><div class="line"><span class="keyword">@property</span> (MB_STRONG) <span class="built_in">UIFont</span>* labelFont;</div><div class="line"><span class="keyword">@property</span> (MB_STRONG) <span class="built_in">UIColor</span>* labelColor;</div><div class="line"></div><div class="line"><span class="comment">// 详情文本的字体及颜色</span></div><div class="line"><span class="keyword">@property</span> (MB_STRONG) <span class="built_in">UIFont</span>* detailsLabelFont;</div><div class="line"><span class="keyword">@property</span> (MB_STRONG) <span class="built_in">UIColor</span>* detailsLabelColor;</div><div class="line"></div><div class="line"><span class="comment">// 菊花的颜色，默认是白色</span></div><div class="line"><span class="keyword">@property</span> (MB_STRONG) <span class="built_in">UIColor</span> *activityIndicatorColor;</div></pre></td></tr></table></figure>
<p>通过以上属性，我们可以根据自己的需要来设置这几个部分的外观。</p>
<p>另外还有一个比较有意思的属性是<code>dimBackground</code>，用于为<code>HUD</code>窗口的视图区域覆盖上一层径向渐变(<code>radial gradient</code>)层，其定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="built_in">BOOL</span> dimBackground;</div></pre></td></tr></table></figure>
<p>让我们来看看通过它，<code>MBProgressHUD</code>都做了些什么。代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</div><div class="line">	</div><div class="line">	...</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">self</span>.dimBackground) &#123;</div><div class="line">		<span class="comment">//Gradient colours</span></div><div class="line">		size_t gradLocationsNum = <span class="number">2</span>;</div><div class="line">		<span class="built_in">CGFloat</span> gradLocations[<span class="number">2</span>] = &#123;<span class="number">0.0</span>f, <span class="number">1.0</span>f&#125;;</div><div class="line">		<span class="built_in">CGFloat</span> gradColors[<span class="number">8</span>] = &#123;<span class="number">0.0</span>f,<span class="number">0.0</span>f,<span class="number">0.0</span>f,<span class="number">0.0</span>f,<span class="number">0.0</span>f,<span class="number">0.0</span>f,<span class="number">0.0</span>f,<span class="number">0.75</span>f&#125;; </div><div class="line">		<span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</div><div class="line">		<span class="built_in">CGGradientRef</span> gradient = <span class="built_in">CGGradientCreateWithColorComponents</span>(colorSpace, gradColors, gradLocations, gradLocationsNum);</div><div class="line">		<span class="built_in">CGColorSpaceRelease</span>(colorSpace);</div><div class="line">		</div><div class="line">		<span class="comment">//Gradient center</span></div><div class="line">		<span class="built_in">CGPoint</span> gradCenter= <span class="built_in">CGPointMake</span>(<span class="keyword">self</span>.bounds.size.width/<span class="number">2</span>, <span class="keyword">self</span>.bounds.size.height/<span class="number">2</span>);</div><div class="line">		<span class="comment">//Gradient radius</span></div><div class="line">		<span class="keyword">float</span> gradRadius = MIN(<span class="keyword">self</span>.bounds.size.width , <span class="keyword">self</span>.bounds.size.height) ;</div><div class="line">		</div><div class="line">		<span class="comment">// 由中心向四周绘制渐变</span></div><div class="line">		<span class="built_in">CGContextDrawRadialGradient</span> (context, gradient, gradCenter,</div><div class="line">									 <span class="number">0</span>, gradCenter, gradRadius,</div><div class="line">									 kCGGradientDrawsAfterEndLocation);</div><div class="line">		<span class="built_in">CGGradientRelease</span>(gradient);</div><div class="line">	&#125;</div><div class="line">	...	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码由中心向<code>MBProgressHUD</code>视图的四周绘制了一个渐变层。当然，这里的颜色值是写死的，我们无法自行定义。有兴趣的话，大家可以将这个属性设置为YES，看看实际的效果。</p>
<h2 id="创建、布局与绘制"><a href="#创建、布局与绘制" class="headerlink" title="创建、布局与绘制"></a>创建、布局与绘制</h2><p>除了继承自<code>UIView</code>的<code>-initWithFrame:</code>初始化方法，<code>MBProgressHUD</code>还为我们提供了两个初始化方法，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)initWithWindow:(<span class="built_in">UIWindow</span> *)window;</div><div class="line">- (<span class="keyword">id</span>)initWithView:(<span class="built_in">UIView</span> *)view;</div></pre></td></tr></table></figure>
<p>这两个方法分别传入一个<code>UIWindow</code>对象和一个<code>UIView</code>对象。传入的视图对象仅仅是做为<code>MBProgressHUD</code>视图定义其<code>frame</code>属性的参照，而不会直接将<code>MBProgressHUD</code>视图添加到传入的视图对象上。这个添加操作还得我们自行处理(当然，<code>MBProgressHUD</code>还提供了几个便捷的类方法，我们下面会说明)。</p>
<p><code>MBProgressHUD</code>提供了几个属性，可以让我们控制<code>HUD</code>的布局，这些属性主要有以下几个：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// HUD相对于父视图中心点的x轴偏移量和y轴偏移量</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="keyword">float</span> xOffset;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="keyword">float</span> yOffset;</div><div class="line"></div><div class="line"><span class="comment">// HUD各元素与HUD边缘的间距</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="keyword">float</span> margin;</div><div class="line"></div><div class="line"><span class="comment">// HUD背景框的最小大小</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="built_in">CGSize</span> minSize;</div><div class="line"></div><div class="line"><span class="comment">// HUD的实际大小</span></div><div class="line"><span class="keyword">@property</span> (atomic, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="built_in">CGSize</span> size;</div><div class="line"></div><div class="line"><span class="comment">// 是否强制HUD背景框宽高相等</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">getter</span> = isSquare) <span class="built_in">BOOL</span> square;</div></pre></td></tr></table></figure>
<p>需要注意的是，<code>MBProgressHUD</code>视图会充满其父视图的<code>frame</code>内，为此，在<code>MBProgressHUD</code>的<code>layoutSubviews</code>方法中，还专门做了处理，如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)layoutSubviews &#123;</div><div class="line">	[<span class="keyword">super</span> layoutSubviews];</div><div class="line">	</div><div class="line">	<span class="comment">// Entirely cover the parent view</span></div><div class="line">	<span class="built_in">UIView</span> *parent = <span class="keyword">self</span>.superview;</div><div class="line">	<span class="keyword">if</span> (parent) &#123;</div><div class="line">		<span class="keyword">self</span>.frame = parent.bounds;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也因此，当<code>MBProgressHUD</code>显示时，它也会屏蔽父视图的各种交互操作。</p>
<p>在布局的过程中，会先根据我们要显示的视图计算出容纳这些视图所需要的总的宽度和高度。当然，会设置一个最大值。我们截取其中一段来看看：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CGRect</span> bounds = <span class="keyword">self</span>.bounds;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="built_in">CGFloat</span> remainingHeight = bounds.size.height - totalSize.height - kPadding - <span class="number">4</span> * margin; </div><div class="line"><span class="built_in">CGSize</span> maxSize = <span class="built_in">CGSizeMake</span>(maxWidth, remainingHeight);</div><div class="line"><span class="built_in">CGSize</span> detailsLabelSize = MB_MULTILINE_TEXTSIZE(detailsLabel.text, detailsLabel.font, maxSize, detailsLabel.lineBreakMode);</div><div class="line">totalSize.width = MAX(totalSize.width, detailsLabelSize.width);</div><div class="line">totalSize.height += detailsLabelSize.height;</div><div class="line"><span class="keyword">if</span> (detailsLabelSize.height &gt; <span class="number">0.</span>f &amp;&amp; (indicatorF.size.height &gt; <span class="number">0.</span>f || labelSize.height &gt; <span class="number">0.</span>f)) &#123;</div><div class="line">	totalSize.height += kPadding;</div><div class="line">&#125;</div><div class="line"></div><div class="line">totalSize.width += <span class="number">2</span> * margin;</div><div class="line">totalSize.height += <span class="number">2</span> * margin;</div></pre></td></tr></table></figure>
<p>之后，就开始从上到下放置各个视图。在布局代码的最后，计算了一个<code>size</code>值，这是为后面绘制背景框做准备的。</p>
<p>在上面的布局代码中，主要是处理了<code>loading</code>动画视图、标题文本框和详情文本框，而<code>HUD</code>背景框主要是在<code>drawRect:</code>中来绘制的。背景框的绘制代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Center HUD</span></div><div class="line"><span class="built_in">CGRect</span> allRect = <span class="keyword">self</span>.bounds;</div><div class="line"><span class="comment">// Draw rounded HUD backgroud rect</span></div><div class="line"><span class="built_in">CGRect</span> boxRect = <span class="built_in">CGRectMake</span>(round((allRect.size.width - size.width) / <span class="number">2</span>) + <span class="keyword">self</span>.xOffset,</div><div class="line">							round((allRect.size.height - size.height) / <span class="number">2</span>) + <span class="keyword">self</span>.yOffset, size.width, size.height);</div><div class="line"><span class="keyword">float</span> radius = <span class="keyword">self</span>.cornerRadius;</div><div class="line"><span class="built_in">CGContextBeginPath</span>(context);</div><div class="line"><span class="built_in">CGContextMoveToPoint</span>(context, <span class="built_in">CGRectGetMinX</span>(boxRect) + radius, <span class="built_in">CGRectGetMinY</span>(boxRect));</div><div class="line"><span class="built_in">CGContextAddArc</span>(context, <span class="built_in">CGRectGetMaxX</span>(boxRect) - radius, <span class="built_in">CGRectGetMinY</span>(boxRect) + radius, radius, <span class="number">3</span> * (<span class="keyword">float</span>)M_PI / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line"><span class="built_in">CGContextAddArc</span>(context, <span class="built_in">CGRectGetMaxX</span>(boxRect) - radius, <span class="built_in">CGRectGetMaxY</span>(boxRect) - radius, radius, <span class="number">0</span>, (<span class="keyword">float</span>)M_PI / <span class="number">2</span>, <span class="number">0</span>);</div><div class="line"><span class="built_in">CGContextAddArc</span>(context, <span class="built_in">CGRectGetMinX</span>(boxRect) + radius, <span class="built_in">CGRectGetMaxY</span>(boxRect) - radius, radius, (<span class="keyword">float</span>)M_PI / <span class="number">2</span>, (<span class="keyword">float</span>)M_PI, <span class="number">0</span>);</div><div class="line"><span class="built_in">CGContextAddArc</span>(context, <span class="built_in">CGRectGetMinX</span>(boxRect) + radius, <span class="built_in">CGRectGetMinY</span>(boxRect) + radius, radius, (<span class="keyword">float</span>)M_PI, <span class="number">3</span> * (<span class="keyword">float</span>)M_PI / <span class="number">2</span>, <span class="number">0</span>);</div><div class="line"><span class="built_in">CGContextClosePath</span>(context);</div><div class="line"><span class="built_in">CGContextFillPath</span>(context);</div></pre></td></tr></table></figure>
<p>这是最平常的绘制操作，在此不多做解释。</p>
<p>我们上面讲过<code>MBProgressHUD</code>提供了几种窗口模式，这几种模式的主要区别在于<code>loading</code>动画视图的展示。默认情况下，使用的是菊花(<code>MBProgressHUDModeIndeterminate</code>)。我们可以通过设置以下属性，来改变<code>loading</code>动画视图：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) MBProgressHUDMode mode;</div></pre></td></tr></table></figure>
<p>对于其它几种模式，<code>MBProgressHUD</code>专门我们提供了几个视图类。如果是进度条模式(<code>MBProgressHUDModeDeterminateHorizontalBar</code>)，则使用的是<code>MBBarProgressView</code>类；如果是饼图模式(<code>MBProgressHUDModeDeterminate</code>)或环形模式(<code>MBProgressHUDModeAnnularDeterminate</code>)，则使用的是<code>MBRoundProgressView</code>类。上面这两个类的主要操作就是在<code>drawRect:</code>中根据一些进度参数来绘制形状，大家可以自己详细看一下。</p>
<p>当然，我们还可以自定义<code>loading</code>动画视图，此时选择的模式是<code>MBProgressHUDModeCustomView</code>。或者不显示<code>loading</code>动画视图，而只显示文本框(<code>MBProgressHUDModeText</code>)。</p>
<p>具体显示哪一种<code>loading</code>动画视图，是在<code>-updateIndicators</code>方法中来处理的，其实现如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)updateIndicators &#123;</div><div class="line">	</div><div class="line">	<span class="built_in">BOOL</span> isActivityIndicator = [indicator isKindOfClass:[<span class="built_in">UIActivityIndicatorView</span> <span class="keyword">class</span>]];</div><div class="line">	<span class="built_in">BOOL</span> isRoundIndicator = [indicator isKindOfClass:[MBRoundProgressView <span class="keyword">class</span>]];</div><div class="line">	</div><div class="line">	<span class="keyword">if</span> (mode == MBProgressHUDModeIndeterminate) &#123;</div><div class="line">		...</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (mode == MBProgressHUDModeDeterminateHorizontalBar) &#123;</div><div class="line">		<span class="comment">// Update to bar determinate indicator</span></div><div class="line">		[indicator removeFromSuperview];</div><div class="line">		<span class="keyword">self</span>.indicator = MB_AUTORELEASE([[MBBarProgressView alloc] init]);</div><div class="line">		[<span class="keyword">self</span> addSubview:indicator];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (mode == MBProgressHUDModeDeterminate || mode == MBProgressHUDModeAnnularDeterminate) &#123;</div><div class="line">		<span class="keyword">if</span> (!isRoundIndicator) &#123;</div><div class="line">			...</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (mode == MBProgressHUDModeAnnularDeterminate) &#123;</div><div class="line">			[(MBRoundProgressView *)indicator setAnnular:<span class="literal">YES</span>];</div><div class="line">		&#125;</div><div class="line">	&#125; </div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (mode == MBProgressHUDModeCustomView &amp;&amp; customView != indicator) &#123;</div><div class="line">		...</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode == MBProgressHUDModeText) &#123;</div><div class="line">		...</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="显示与隐藏"><a href="#显示与隐藏" class="headerlink" title="显示与隐藏"></a>显示与隐藏</h2><p><code>MBRoundProgressView</code>为我们提供了丰富的显示与隐藏<code>HUD</code>窗口的。在分析这些方法之前，我们先来看看<code>MBProgressHUD</code>为显示与隐藏提供的一些属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// HUD显示和隐藏的动画类型</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) MBProgressHUDAnimation animationType;</div><div class="line"></div><div class="line"><span class="comment">// HUD显示的最短时间。设置这个值是为了避免HUD显示后立即被隐藏。默认值为0</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="keyword">float</span> minShowTime;</div><div class="line"></div><div class="line"><span class="comment">// 这个属性设置了一个宽限期，它是在没有显示HUD窗口前被调用方法可能运行的时间。</span></div><div class="line"><span class="comment">// 如果被调用方法在宽限期内执行完，则HUD不会被显示。</span></div><div class="line"><span class="comment">// 这主要是为了避免在执行很短的任务时，去显示一个HUD窗口。</span></div><div class="line"><span class="comment">// 默认值是0。只有当任务状态是已知时，才支持宽限期。具体我们看实现代码。</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="keyword">float</span> graceTime;</div><div class="line"></div><div class="line"><span class="comment">// 这是一个标识位，标明执行的操作正在处理中。这个属性是配合graceTime使用的。</span></div><div class="line"><span class="comment">// 如果没有设置graceTime，则这个标识是没有太大意义的。在使用showWhileExecuting:onTarget:withObject:animated:方法时，</span></div><div class="line"><span class="comment">// 会自动去设置这个属性为YES，其它情况下都需要我们自己手动设置。</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="built_in">BOOL</span> taskInProgress;</div><div class="line"></div><div class="line"><span class="comment">// 隐藏时是否将HUD从父视图中移除，默认是NO。</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="built_in">BOOL</span> removeFromSuperViewOnHide;</div><div class="line"></div><div class="line"><span class="comment">// 进度指示器，从0.0到1.0，默认值为0.0</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="keyword">float</span> progress;</div><div class="line"></div><div class="line"><span class="comment">// 在HUD被隐藏后的回调</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>) MBProgressHUDCompletionBlock completionBlock;</div></pre></td></tr></table></figure>
<p>以上这些属性都还好理解，可能需要注意的就是<code>graceTime</code>和<code>taskInProgress</code>的配合使用。在下面我们将会看看这两个属性的用法。</p>
<p>对于显示操作，最基本的就是<code>-show:</code>方法(其它几个显示方法都会调用该方法来显示HUD窗口)，我们先来看看它的实现，</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)show:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">	useAnimation = animated;</div><div class="line">	<span class="comment">// If the grace time is set postpone the HUD display</span></div><div class="line">	<span class="keyword">if</span> (<span class="keyword">self</span>.graceTime &gt; <span class="number">0.0</span>) &#123;</div><div class="line">		<span class="keyword">self</span>.graceTimer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="keyword">self</span>.graceTime target:<span class="keyword">self</span> </div><div class="line">						   selector:<span class="keyword">@selector</span>(handleGraceTimer:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</div><div class="line">	&#125; </div><div class="line">	<span class="comment">// ... otherwise show the HUD imediately </span></div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		[<span class="keyword">self</span> showUsingAnimation:useAnimation];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，如果我们没有设置<code>graceTime</code>属性，则会立即显示<code>HUD</code>；而如果设置了<code>graceTime</code>，则会创建一个定时器，并让显示操作延迟到<code>graceTime</code>所设定的时间再执行，而<code>-handleGraceTimer:</code>实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)handleGraceTimer:(<span class="built_in">NSTimer</span> *)theTimer &#123;</div><div class="line">	<span class="comment">// Show the HUD only if the task is still running</span></div><div class="line">	<span class="keyword">if</span> (taskInProgress) &#123;</div><div class="line">		[<span class="keyword">self</span> showUsingAnimation:useAnimation];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，只有在设置了<code>taskInProgress</code>标识位为YES的情况下，才会去显示<code>HUD</code>窗口。所以，如果我们要自己调用<code>-show:</code>方法的话，需要酌情考虑设置<code>taskInProgress</code>标识位。</p>
<p>除了<code>-show:</code>方法以外，<code>MBProgressHUD</code>还为我们提供了一组显示方法，可以让我们在显示<code>HUD</code>的同时，执行一些后台任务，我们在此主要介绍两个。其中一个是<code>-showWhileExecuting:onTarget:withObject:animated:</code>，它是基于<code>target-action</code>方式的调用，在执行一个后台任务时显示<code>HUD</code>，等后台任务执行完成后再隐藏<code>HUD</code>，具体实现如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)showWhileExecuting:(SEL)method onTarget:(<span class="keyword">id</span>)target withObject:(<span class="keyword">id</span>)object animated:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">	methodForExecution = method;</div><div class="line">	targetForExecution = MB_RETAIN(target);</div><div class="line">	objectForExecution = MB_RETAIN(object);	</div><div class="line">	<span class="comment">// Launch execution in new thread</span></div><div class="line">	<span class="keyword">self</span>.taskInProgress = <span class="literal">YES</span>;</div><div class="line">	[<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(launchExecution) toTarget:<span class="keyword">self</span> withObject:<span class="literal">nil</span>];</div><div class="line">	<span class="comment">// Show HUD view</span></div><div class="line">	[<span class="keyword">self</span> show:animated];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)launchExecution &#123;</div><div class="line">	<span class="keyword">@autoreleasepool</span> &#123;</div><div class="line"><span class="meta">#pragma clang diagnostic push</span></div><div class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Warc-performSelector-leaks"</span></span></div><div class="line">		<span class="comment">// Start executing the requested task</span></div><div class="line">		[targetForExecution performSelector:methodForExecution withObject:objectForExecution];</div><div class="line"><span class="meta">#pragma clang diagnostic pop</span></div><div class="line">		<span class="comment">// Task completed, update view in main thread (note: view operations should</span></div><div class="line">		<span class="comment">// be done only in the main thread)</span></div><div class="line">		[<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(cleanUp) withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，<code>-showWhileExecuting:onTarget:withObject:animated:</code>首先将<code>taskInProgress</code>属性设置为YES，这样在调用<code>-show:</code>方法时，即使设置了<code>graceTime</code>，也确保能在任务完成之前显示<code>HUD</code>。然后开启一个新线程，来异步执行我们的后台任务，最后去显示<code>HUD</code>。</p>
<p>而在异步调用方法<code>-launchExecution</code>中，线程首先是维护了自己的一个<code>@autoreleasepool</code>，所以在我们自己的方法中，就不需要再去维护一个<code>@autoreleasepool</code>了。之后是去执行我们的任务，在任务完成之后，再回去主线程去执行清理操作，并隐藏<code>HUD</code>窗口。</p>
<p>另一个显示方法是<code>-showAnimated:whileExecutingBlock:onQueue:completionBlock:</code>，它是基于GCD的调用，当<code>block</code>中的任务在指定的队列中执行时，显示<code>HUD</code>窗口，任务完成之后执行<code>completionBlock</code>操作，最后隐藏<code>HUD</code>窗口。我们来看看它的具体实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)showAnimated:(<span class="built_in">BOOL</span>)animated whileExecutingBlock:(dispatch_block_t)block onQueue:(<span class="built_in">dispatch_queue_t</span>)queue</div><div class="line">	 completionBlock:(MBProgressHUDCompletionBlock)completion &#123;</div><div class="line">	<span class="keyword">self</span>.taskInProgress = <span class="literal">YES</span>;</div><div class="line">	<span class="keyword">self</span>.completionBlock = completion;</div><div class="line">	<span class="built_in">dispatch_async</span>(queue, ^(<span class="keyword">void</span>) &#123;</div><div class="line">		block();</div><div class="line">		<span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^(<span class="keyword">void</span>) &#123;</div><div class="line">			[<span class="keyword">self</span> cleanUp];</div><div class="line">		&#125;);</div><div class="line">	&#125;);</div><div class="line">	[<span class="keyword">self</span> show:animated];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法也是首先将<code>taskInProgress</code>属性设置为YES，然后开启一个线程去执行<code>block</code>任务，最后主线程去执行清理操作，并隐藏<code>HUD</code>窗口。</p>
<p>对于<code>HUD</code>的隐藏，<code>MBProgressHUD</code>提供了两个方法，一个是<code>-hide:</code>，另一个是<code>-hide:afterDelay:</code>，后者基于前者，所以我们主要来看看<code>-hide:</code>的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)hide:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">	useAnimation = animated;</div><div class="line">	<span class="comment">// If the minShow time is set, calculate how long the hud was shown,</span></div><div class="line">	<span class="comment">// and pospone the hiding operation if necessary</span></div><div class="line">	<span class="keyword">if</span> (<span class="keyword">self</span>.minShowTime &gt; <span class="number">0.0</span> &amp;&amp; showStarted) &#123;</div><div class="line">		<span class="built_in">NSTimeInterval</span> interv = [[<span class="built_in">NSDate</span> date] timeIntervalSinceDate:showStarted];</div><div class="line">		<span class="keyword">if</span> (interv &lt; <span class="keyword">self</span>.minShowTime) &#123;</div><div class="line">			<span class="keyword">self</span>.minShowTimer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:(<span class="keyword">self</span>.minShowTime - interv) target:<span class="keyword">self</span> </div><div class="line">								selector:<span class="keyword">@selector</span>(handleMinShowTimer:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125; </div><div class="line">	&#125;</div><div class="line">	<span class="comment">// ... otherwise hide the HUD immediately</span></div><div class="line">	[<span class="keyword">self</span> hideUsingAnimation:useAnimation];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，在设置了<code>minShowTime</code>属性并且已经显示了<code>HUD</code>窗口的情况下，会去判断显示的时间是否小于<code>minShowTime</code>指定的时间，如果是，则会开启一个定时器，等到显示的时间到了<code>minShowTime</code>所指定的时间，才会去隐藏<code>HUD</code>窗口；否则会直接去隐藏<code>HUD</code>窗口。</p>
<p>隐藏的实际操作主要是去做了些清理操作，包括根据设定的<code>removeFromSuperViewOnHide</code>值来执行是否从父视图移除<code>HUD</code>窗口，以及执行<code>completionBlock</code>操作，还有就是执行代理的<code>hudWasHidden:</code>方法。这些操作是在私有方法<code>-done</code>里面执行的，实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)done &#123;</div><div class="line">	[<span class="built_in">NSObject</span> cancelPreviousPerformRequestsWithTarget:<span class="keyword">self</span>];</div><div class="line">	isFinished = <span class="literal">YES</span>;</div><div class="line">	<span class="keyword">self</span>.alpha = <span class="number">0.0</span>f;</div><div class="line">	<span class="keyword">if</span> (removeFromSuperViewOnHide) &#123;</div><div class="line">		[<span class="keyword">self</span> removeFromSuperview];</div><div class="line">	&#125;</div><div class="line"><span class="meta">#if NS_BLOCKS_AVAILABLE</span></div><div class="line">	<span class="keyword">if</span> (<span class="keyword">self</span>.completionBlock) &#123;</div><div class="line">		<span class="keyword">self</span>.completionBlock();</div><div class="line">		<span class="keyword">self</span>.completionBlock = <span class="literal">NULL</span>;</div><div class="line">	&#125;</div><div class="line"><span class="meta">#endif</span></div><div class="line">	<span class="keyword">if</span> ([delegate respondsToSelector:<span class="keyword">@selector</span>(hudWasHidden:)]) &#123;</div><div class="line">		[delegate performSelector:<span class="keyword">@selector</span>(hudWasHidden:) withObject:<span class="keyword">self</span>];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p><code>MBProgressHUD</code>的一些主要的代码差不多已经分析完了，最后还有些边边角角的地方，一起来看看。</p>
<h3 id="显示和隐藏的便捷方法"><a href="#显示和隐藏的便捷方法" class="headerlink" title="显示和隐藏的便捷方法"></a>显示和隐藏的便捷方法</h3><p>除了上面描述的实例方法之外，<code>MBProgressHUD</code>还为我们提供了几个便捷显示和隐藏<code>HUD</code>窗口的方法，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (MB_INSTANCETYPE)showHUDAddedTo:(<span class="built_in">UIView</span> *)view animated:(<span class="built_in">BOOL</span>)animated</div><div class="line">+ (<span class="built_in">BOOL</span>)hideHUDForView:(<span class="built_in">UIView</span> *)view animated:(<span class="built_in">BOOL</span>)animated</div><div class="line">+ (<span class="built_in">NSUInteger</span>)hideAllHUDsForView:(<span class="built_in">UIView</span> *)view animated:(<span class="built_in">BOOL</span>)animated</div></pre></td></tr></table></figure>
<p>方法的签名已经很能说明问题了，在此不多描述。</p>
<h3 id="部分属性值的设置"><a href="#部分属性值的设置" class="headerlink" title="部分属性值的设置"></a>部分属性值的设置</h3><p>对于部分属性(主要是”外观”一节中针对菊花、标题文本框和详情文本框的几个属性值)，为了在设置将这些属性时修改对应视图的属性，并没有直接为每个属性生成一个<code>setter</code>，而是通过KVO来监听这些属性值的变化，再将这些值赋值给视图的对应属性，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 监听的属性数组</span></div><div class="line">- (<span class="built_in">NSArray</span> *)observableKeypaths &#123;</div><div class="line">	<span class="keyword">return</span> [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"mode"</span>, <span class="string">@"customView"</span>, <span class="string">@"labelText"</span>, <span class="string">@"labelFont"</span>, <span class="string">@"labelColor"</span>, ..., <span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 注册KVO</span></div><div class="line">- (<span class="keyword">void</span>)registerForKVO &#123;</div><div class="line">	<span class="keyword">for</span> (<span class="built_in">NSString</span> *keyPath <span class="keyword">in</span> [<span class="keyword">self</span> observableKeypaths]) &#123;</div><div class="line">		[<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:keyPath options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">NULL</span>];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context &#123;</div><div class="line">	<span class="keyword">if</span> (![<span class="built_in">NSThread</span> isMainThread]) &#123;</div><div class="line">		[<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(updateUIForKeypath:) withObject:keyPath waitUntilDone:<span class="literal">NO</span>];</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		[<span class="keyword">self</span> updateUIForKeypath:keyPath];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)updateUIForKeypath:(<span class="built_in">NSString</span> *)keyPath &#123;</div><div class="line">	<span class="keyword">if</span> ([keyPath isEqualToString:<span class="string">@"mode"</span>] || [keyPath isEqualToString:<span class="string">@"customView"</span>] ||</div><div class="line">		[keyPath isEqualToString:<span class="string">@"activityIndicatorColor"</span>]) &#123;</div><div class="line">		[<span class="keyword">self</span> updateIndicators];</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="string">@"labelText"</span>]) &#123;</div><div class="line">		label.text = <span class="keyword">self</span>.labelText;</div><div class="line">	&#125; </div><div class="line">	</div><div class="line">	...</div><div class="line">	</div><div class="line">	[<span class="keyword">self</span> setNeedsLayout];</div><div class="line">	[<span class="keyword">self</span> setNeedsDisplay];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p><code>MBProgressHUD</code>还为我们提供了一个代理<code>MBProgressHUDDelegate</code>，这个代理中只提供了一个方法，即：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)hudWasHidden:(MBProgressHUD *)hud;</div></pre></td></tr></table></figure>
<p>这个代理方法是在隐藏<code>HUD</code>窗口后调用，如果此时我们需要在我们自己的实现中执行某些操作，则可以实现这个方法。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><code>MBProgressHUD</code>为我们提供了一个<code>HUD</code>窗口的很好的实现，不过个人在使用过程中，觉得它给我们提供的交互功能太少。其代理只提供了一个<code>-hudWasHidden:</code>方法，而且我们也无法通过点击<code>HUD</code>来执行一些操作。在现实的需求中，可能存在这种情况：比如一个网络操作，在发送请求等待响应的过程中，我们会显示一个<code>HUD</code>窗口以显示一个<code>loading</code>框。但如果我们想在等待响应的过程中，在当前视图中取消这个网络请求，就没有相应的处理方式，<code>MBProgressHUD</code>没有为我们提供这样的交互操作。当然这时候，我们可以根据自己的需求来修改源码。</p>
<h2 id="与SVProgressHUD的对比"><a href="#与SVProgressHUD的对比" class="headerlink" title="与SVProgressHUD的对比"></a>与SVProgressHUD的对比</h2><p>与<code>MBProgressHUD</code>类似，<code>SVProgressHUD</code>类库也为我们提供了在视图中显示一个<code>HUD</code>窗口的功能。两者的基本思路是差不多的，差别更多的是在实现细节上。相对于<code>MBProgressHUD</code>来说，<code>SVProgressHUD</code>的实现有以下几点不同：</p>
<ol>
<li><code>SVProgressHUD</code>类对外提供的都是类方法，包括显示、隐藏、和视图属性设置都是使用类方法来操作。其内部实现为一个单例对象，类方法实际是针对这个单例对象来操作的。</li>
<li><code>SVProgressHUD</code>主要包含三部分：<code>loading</code>视图、提示文本框和背景框，没有详情文本框。</li>
<li><code>SVProgressHUD</code>默认提供了正确、错误和信息三种状态视图(与<code>loading</code>视图同一位置，根据需要来设置)。当然<code>MBProgressHUD</code>中，也可以自定义视图(<code>customView</code>)来显示相应的状态视图。</li>
<li><code>SVProgressHUD</code>为我们提供了更多的交互操作，包括点击事件、显示事件及隐藏事件。不过这些都是通过通知的形式向外发送，所以我们需要自己去监听这些事件。</li>
<li><code>SVProgressHUD</code>中一些<code>loading</code>动画是以<code>Layer</code>动画的形式来实现的。</li>
</ol>
<p><code>SVProgressHUD</code>的实现细节还未详细去看，有兴趣的读者可以去研究一下。这两个<code>HUD</code>类库各有优点，大家在使用时，可根据自己的需要和喜好来选择。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总体来说，<code>MBProgressHUD</code>的代码相对朴实，简单易懂，没有什么花哨难懂的东西。就技术点而言，也没有太多复杂的技术，都是我们常用的一些东西。就使用而言，也是挺方便的，参考一下<code>github</code>上的使用指南就能很快上手。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="南峰子" />
          <p class="site-author-name" itemprop="name">南峰子</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">83</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">南峰子</span>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1000523916'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1000523916%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
  </script>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  
  

  <div style="display: none;">
    <script src="http://s95.cnzz.com/z_stat.php?id=1000523916&web_id=1000523916" language="JavaScript"></script>
  </div>




</body>
</html>

<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="南峰子的技术博客">
<meta property="og:url" content="http://southpeak.github.io/index.html">
<meta property="og:site_name" content="南峰子的技术博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="南峰子的技术博客">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://southpeak.github.io/"/>

  <title> 南峰子的技术博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-68856508-1', 'auto');
  ga('send', 'pageview');
</script>







  <div style="display: none;">
    <script src="http://s95.cnzz.com/z_stat.php?id=1000523916&web_id=1000523916" language="JavaScript"></script>
  </div>





  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">南峰子的技术博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">攀登，一步一个脚印，方能知其乐</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-techset">
          <a href="/categories/techset" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-fighter-jet"></i> <br />
            
            知识小集
          </a>
        </li>
      
        
        <li class="menu-item menu-item-swift">
          <a href="/categories/swift" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-space-shuttle"></i> <br />
            
            Swift
          </a>
        </li>
      
        
        <li class="menu-item menu-item-objectivec">
          <a href="/categories/objectivec" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-taxi"></i> <br />
            
            Objective-C
          </a>
        </li>
      
        
        <li class="menu-item menu-item-cocoa">
          <a href="/categories/cocoa" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-subway"></i> <br />
            
            Cocoa
          </a>
        </li>
      
        
        <li class="menu-item menu-item-translate">
          <a href="/categories/translate" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-rocket"></i> <br />
            
            翻译
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sourcecode">
          <a href="/categories/sourcecode" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-train"></i> <br />
            
            源码分析
          </a>
        </li>
      
        
        <li class="menu-item menu-item-something">
          <a href="/categories/something" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-bicycle"></i> <br />
            
            杂项
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/01/javascriptcore-tutorial-for-ios-getting-started/" itemprop="url">
                  JavaScriptCore Tutorial for iOS: Getting Started
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-01T16:58:06+08:00" content="2016-08-01">
              2016-08-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文由József Vesza发表于raywenderlich，原文地址是<a href="https://www.raywenderlich.com/124075/javascriptcore-tutorial" target="_blank" rel="external">https://www.raywenderlich.com/124075/javascriptcore-tutorial</a></p>
</blockquote>
<p>自从2014年Swift发布以来，其受欢迎程度直线上升：从TIOBE的数据来看，在2016年二月份，它的排名已经上升到第16位。不过，同时我们可以看到排名第9位的是Javascript，这门语言与Swift有许多不同之处：Swift在编译时安全性上做了很多努力，而Javascript是弱类型且动态的。</p>
<p>Swift与Javascript有很多不一样的地方，不过有一件事却将他们紧紧绑在一起：你可以使用他们来创建一个轻量级的iOS应用。</p>
<p>在这篇JavaScriptCore的教程中，你将构建一个用于显示类似web页面的iOS应用，并重用web页面现存的Javascript代码。特别是你将了解以下几点：</p>
<ul>
<li>JavaScriptCore框架的组件</li>
<li>如何在iOS代码中调用Javascript方法</li>
<li>如何在Javascript代码中访问本地代码</li>
</ul>
<blockquote>
<p>注：你不需要有JavaScript的经验。如果这篇JavaScriptCore教程已经激起你学习这门语言的兴趣，那么<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" target="_blank" rel="external">Mozilla Developer Network</a>对于初学者来说是一个非常棒的资源 - 或者你也可以选择看<a href="http://blog.wix.engineering/wp-content/uploads/2015/04/mIuuwgx-1024x576.jpg" target="_blank" rel="external">这里</a>介绍的两本书。</p>
</blockquote>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>下载这篇教程的<a href="http://www.raywenderlich.com/wp-content/uploads/2016/02/Showtime-Starter.zip" target="_blank" rel="external">初始工程</a>并解压。你可以看到下面的目录结构：</p>
<ul>
<li>Web：包含将被转换为iOS应用的web页面的HTML和CSS文件。</li>
<li>Native：iOS工程。文章中所有的修改都是在这里。</li>
<li>js：包含用于工程的Javascript代码。</li>
</ul>
<p>App名叫Showtime，用于搜索iTunes上的付费电影。为了查看它的效果，可以用浏览器打开Web/index.html页面，输入你要的价格，然后按下<code>return</code>按钮。</p>
<p><img src="https://cdn2.raywenderlich.com/wp-content/uploads/2016/01/5.jpg" alt="image"></p>
<p>如果想在iOS上测试Showtime，则可以打开Native/Showtime中的工程。编译并运行App来看看效果：</p>
<p><img src="https://cdn2.raywenderlich.com/wp-content/uploads/2016/02/Simulator-Screen-Shot-20-Feb-2016-21.25.58-1.png" alt="image"></p>
<p>正如你所看到的，手机中的App还未准备就绪，不过我们慢慢来补充它。工程已经包含了一些代码；我们会一步一步来完善。这个App的目的是提供一个类似web页面的体验：它将把搜索结果显示在一个Collection View中。</p>
<h2 id="JavaScriptCore是什么？"><a href="#JavaScriptCore是什么？" class="headerlink" title="JavaScriptCore是什么？"></a>JavaScriptCore是什么？</h2><p>JavaScriptCore框架提供了访问WebKit的Javascript引擎的机制。最初这个框架只有一些支持Mac系统的C API，但到了iOS 7和OS X 10.9后，它提供了一个更加友好的Objective-C封装。这个框架为Swift/Objective-C和Javascript代码提供了更强大的互通性。</p>
<blockquote>
<p>注：React Native演示了JavaScriptCore强大功能。如果你想了解如何使用Javascript构建本地应用，你可以看看本站的<a href="http://www.raywenderlich.com/99473/introducing-react-native-building-apps-javascript" target="_blank" rel="external">Introducing React Native tutorial</a>一文。</p>
</blockquote>
<p>在这一节中，你将近距离于窥探一下JavaScriptCore的API。JavaScriptCore包含几个主要的组件：JSVirtualMachine、JSContext和JSValue。下面描述它们是如何整合在一起的。</p>
<h3 id="JSVirtualMachine"><a href="#JSVirtualMachine" class="headerlink" title="JSVirtualMachine"></a>JSVirtualMachine</h3><p>JavaScript代码是在由JSVirtualMachine类表示的一个虚拟机上执行的。通常情况下你不需要直接与这个类交互，但有一种情况例外：并发执行JavaScript代码。在一个独立的JSVirtualMachine中，是不可能同一时间执行多个线程的。为了支持并行，你必须使用多个虚拟机。</p>
<p>每一个JSVirtualMachine实例都有自己的堆和自己的垃圾回收器，这意味着你不能在虚拟机之间传递对象。一个虚拟机的垃圾收集器不知道如何去处理另一个堆上的值。</p>
<h3 id="JSContext"><a href="#JSContext" class="headerlink" title="JSContext"></a>JSContext</h3><p>一个JSContext对象表示JavaScript代码的执行环境。它对应于一个单一的全局对象；它的web开发环境等同于一个窗口对象。不同于一个虚拟机，你可以在多个上下文之间传递对象(因为它们位于同一虚拟机)。</p>
<h3 id="JSValue"><a href="#JSValue" class="headerlink" title="JSValue"></a>JSValue</h3><p>JSValue是我们需要处理的主要数据类型：它可以表示任何可能的Javascript值。一个JSValue被绑定到其存活的JSContext对象中。任何来源于上下文对象的值都是JSValue类型。</p>
<p>下图显示了这几个对象是如何一起工作的：</p>
<p><img src="https://cdn5.raywenderlich.com/wp-content/uploads/2016/02/javascriptcore.png" alt="image"></p>
<p>现在你对JavaScriptCore框架有了一个更好的了解了，就让我们来写一些代码吧。</p>
<h2 id="调用Javascript方法"><a href="#调用Javascript方法" class="headerlink" title="调用Javascript方法"></a>调用Javascript方法</h2><p>回到Xcode，在project navigator中展开Data group，并打开MovieService.swift。这个类将获取并处理来源于iTunes的电影结果。不过现在它几乎是空的；接下来就由你来提供这些方法的具体实现。</p>
<p>MovieService的工作流程如下：</p>
<ul>
<li><code>loadMoviesWithLimit(_:onComplete:)</code>将获取电影数据。</li>
<li><code>parseResponse(_:withLimit:)</code>将使用共享的JavaScript代码来处理响应数据。</li>
</ul>
<p>第一步是获取电影列表。如果你熟悉JavaScript开发，你会知道一般是使用XMLHttpRequest对象来访问网络。这个对象并不是语言本身的一部分，所以你不能将它用于一个iOS App的上下文中。相反，你应该使用本地网络代码。</p>
<p>在MovieService类中，找到<code>loadMoviesWithLimit(_:onComplete:)</code>方法并按以下代码来修改：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadMoviesWithLimit</span><span class="params">(limit: Double, onComplete complete: [Movie] -&gt; <span class="params">()</span></span></span>) &#123;</div><div class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: movieUrl) <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Invalid url format: \(movieUrl)"</span>)</div><div class="line">    <span class="keyword">return</span></div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="type">NSURLSession</span>.sharedSession().dataTaskWithURL(url) &#123; data, <span class="number">_</span>, <span class="number">_</span> <span class="keyword">in</span></div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> data = data,</div><div class="line">        jsonString = <span class="type">String</span>(data: data, encoding: <span class="type">NSUTF8StringEncoding</span>) <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">print</span>(<span class="string">"Error while parsing the response data."</span>)</div><div class="line">      <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">let</span> movies = <span class="keyword">self</span>.parseResponse(jsonString, withLimit:limit)</div><div class="line">    complete(movies)</div><div class="line"> </div><div class="line">  &#125;.resume()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码片断使用默认的NSURLSession单例来获取电影列表。在你将响应数据传递给JavaScript代码之前，你需要提供一个执行上下文给响应数据。首先，在MovieService.swift文件顶部，在<code>import UIKit</code>下方添加下面这行代码来导入JavaScriptCore：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> JavaScriptCore</div></pre></td></tr></table></figure>
<p>然后在MovieService中定义如下属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> context: <span class="type">JSContext</span>? = &#123;</div><div class="line">  <span class="keyword">let</span> context = <span class="type">JSContext</span>()</div><div class="line"> </div><div class="line">  <span class="comment">// 1</span></div><div class="line">  <span class="keyword">guard</span> <span class="keyword">let</span></div><div class="line">      commonJSPath = <span class="type">NSBundle</span>.mainBundle().pathForResource(<span class="string">"common"</span>, ofType: <span class="string">"js"</span>) <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Unable to read resource files."</span>)</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="comment">// 2</span></div><div class="line">  <span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">let</span> common = <span class="keyword">try</span> <span class="type">String</span>(contentsOfFile: commonJSPath, encoding: <span class="type">NSUTF8StringEncoding</span>)</div><div class="line">    context.evaluateScript(common)</div><div class="line">  &#125; <span class="keyword">catch</span> (<span class="keyword">let</span> error) &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Error while processing script file: \(error)"</span>)</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> context</div><div class="line">&#125;()</div></pre></td></tr></table></figure>
<p>这段代码将上下文定义为一个懒加载的JSContext属性：</p>
<ol>
<li>首先，你从应用的bundle中加载common.js文件，这个文件中包含你要访问的JavaScript代码。</li>
<li>在加载文件后，上下文对象将调用<code>context.evaluateScript()</code>，并将文件内容作为其参数，以此来执行js代码。</li>
</ol>
<p>现在可以调用Javascript方法了。仍然是在MovieService.swift文件中，找到<code>parseResponse(_:withLimit:)</code>方法，添加以下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseResponse</span><span class="params">(response: String, withLimit limit: Double)</span></span> -&gt; [<span class="type">Movie</span>] &#123;</div><div class="line">  <span class="comment">// 1</span></div><div class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> context = context <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"JSContext not found."</span>)</div><div class="line">    <span class="keyword">return</span> []</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="comment">// 2</span></div><div class="line">  <span class="keyword">let</span> parseFunction = context.objectForKeyedSubscript(<span class="string">"parseJson"</span>)</div><div class="line">  <span class="keyword">let</span> parsed = parseFunction.callWithArguments([response]).toArray()</div><div class="line"> </div><div class="line">  <span class="comment">// 3</span></div><div class="line">  <span class="keyword">let</span> filterFunction = context.objectForKeyedSubscript(<span class="string">"filterByLimit"</span>)</div><div class="line">  <span class="keyword">let</span> filtered = filterFunction.callWithArguments([parsed, limit]).toArray()</div><div class="line"> </div><div class="line">  <span class="comment">// 4</span></div><div class="line">  <span class="keyword">return</span> []</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一步一步来看看这个流程：</p>
<ol>
<li>首先，确保上下文对象被正确的初始化。如果在设置的时候有任何错误(如：common.js文件不在bundle中)，则返回空数组。</li>
<li>在上下文对象中查询<code>parseJSON()</code>方法。正如上面所提到的，查询的结果将被封装在一个JSValue对象中。接着，使用<code>callWithArguments(_:)</code>来调用方法，并将一个数组作为参数。最后，将返回的JavaScript值转换为一个数组。</li>
<li><code>filterByLimit()</code>返回匹配给定价格限制的电影列表。</li>
<li>现在你已经获取到了电影列表，但仍然忘了一点：<code>filtered</code>常量持有一个JSValue数组，你需要将其映射为本地Movie类型。</li>
</ol>
<blockquote>
<p>注：你可以发现<code>objectForKeyedSubscript()</code>方法的使用有点怪怪的。不幸的是，Swift只能用这种原始的下标方法，而不能将其转换成合适的下标方法。而Objective-C可以使用方括号的下标语法。</p>
</blockquote>
<h2 id="暴露本地代码"><a href="#暴露本地代码" class="headerlink" title="暴露本地代码"></a>暴露本地代码</h2><p>在JavaScript运行时运行本地代码的一种方式是使用block；它们会被自动桥接到JavaScript方法。这里有个小问题：这个方法只适用于Objective-C的block，而不适用于Swift的闭包。为了暴露一个闭包，你必须执行两个任务：</p>
<ul>
<li>使用<code>@convention(block)</code>特性来修饰一个闭包，以将它桥接到一个Objective-C block。</li>
<li>在你可以将一个block映射到JavaScript方法调用前，你需要将其转换为一个AnyObject对象。</li>
</ul>
<p>切换到Movie.swift文件，并添加以下方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">let</span> movieBuilder: <span class="meta">@convention</span>(block) [[<span class="type">String</span> : <span class="type">String</span>]] -&gt; [<span class="type">Movie</span>] = &#123; object <span class="keyword">in</span></div><div class="line">  <span class="keyword">return</span> object.<span class="built_in">map</span> &#123; dict <span class="keyword">in</span></div><div class="line"> </div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span></div><div class="line">        title = dict[<span class="string">"title"</span>],</div><div class="line">        price = dict[<span class="string">"price"</span>],</div><div class="line">        imageUrl = dict[<span class="string">"imageUrl"</span>] <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">print</span>(<span class="string">"unable to parse Movie objects."</span>)</div><div class="line">      <span class="built_in">fatalError</span>()</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> <span class="type">Movie</span>(title: title, price: price, imageUrl: imageUrl)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个闭包维护一个JavaScript对象数组(元素为字典类型)，然后用它们构造Movie实例。</p>
<p>切换回MovieService.swift文件。在<code>parseResponse(_:withLimit:)</code>方法中，使用以下代码来替换的返回语句：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="keyword">let</span> builderBlock = <span class="built_in">unsafeBitCast</span>(<span class="type">Movie</span>.movieBuilder, <span class="type">AnyObject</span>.<span class="keyword">self</span>)</div><div class="line"> </div><div class="line"><span class="comment">// 2</span></div><div class="line">context.setObject(builderBlock, forKeyedSubscript: <span class="string">"movieBuilder"</span>)</div><div class="line"><span class="keyword">let</span> builder = context.evaluateScript(<span class="string">"movieBuilder"</span>)</div><div class="line"> </div><div class="line"><span class="comment">// 3</span></div><div class="line"><span class="keyword">guard</span> <span class="keyword">let</span> unwrappedFiltered = filtered,</div><div class="line">  <span class="keyword">let</span> movies = builder.callWithArguments([unwrappedFiltered]).toArray() <span class="keyword">as</span>? [<span class="type">Movie</span>] <span class="keyword">else</span> &#123;</div><div class="line">  <span class="built_in">print</span>(<span class="string">"Error while processing movies."</span>)</div><div class="line">  <span class="keyword">return</span> []</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">return</span> movies</div></pre></td></tr></table></figure>
<ol>
<li>你使用Swift的<code>unsafeBitCast(_:_:)</code>方法来将block转换成AnyObject。</li>
<li>在上下文中调用<code>setObject(_:forKeyedSubscript:)</code>，将block加载到JavaScript运行时。然后使用<code>evaluateScript()</code>方法获取JavaScript中block的一个引用。</li>
<li>最后一步是使用<code>callWithArguments(_:)</code>从JavaScript中调用你的block，这个方法传入一个JSValue对象的数组作为参数。返回值可以被转换成Movie对象的数组。</li>
</ol>
<p>最后来看看效果！编译并运行。在搜索框中输入一个价格，然后你可以看到将显示一些结果：</p>
<p><img src="https://cdn5.raywenderlich.com/wp-content/uploads/2016/02/Simulator-Screen-Shot-19-Feb-2016-21.51.48-1-281x500.png" alt="image"></p>
<p>仅仅几行代码，你就构建了一个本地应用，并使用JavaScript来解析和过滤结果。</p>
<h2 id="使用JSExport协议"><a href="#使用JSExport协议" class="headerlink" title="使用JSExport协议"></a>使用JSExport协议</h2><p>在JavaScript使用自定义对象的另一种方式是JSExport协议。你必须创建一个继承自JSExport的协议，并声明想要暴露给Javascript的属性和方法。</p>
<p>对于你暴露的每一个本地类，JavaScriptCore都会在适当的JSContext实例中创建一个原型。JavaScriptCore框架这样做是基于这样一个选择基础：默认情况下，你的类的方法或属性自己并不会暴露给JavaScript。相反，你必须选择暴露谁。JSExport的规则如下：</p>
<ul>
<li>对于被暴露的实例方法，JavaScriptCore创建一个对应的JavaScript函数作为原型对象的属性。</li>
<li>类的属性将作为原型的访问器属性。</li>
<li>对于类方法，JavaScriptCore将在构造器对象中创建一个JavaScript方法。</li>
</ul>
<p>为了看看在实践中如何处理，我们切换到Movie.swift中，并在类声明前面定义如下一个新的协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> JavaScriptCore</div><div class="line"> </div><div class="line"><span class="meta">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">MovieJSExports</span>: <span class="title">JSExport</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> title: <span class="type">String</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">  <span class="keyword">var</span> price: <span class="type">String</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">  <span class="keyword">var</span> imageUrl: <span class="type">String</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">movieWithTitle</span><span class="params">(title: String, price: String, imageUrl: String)</span></span> -&gt; <span class="type">Movie</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，你指定所有想要暴露的属性并定义一个类方法来在Javascript中构造Movie对象。后者是必须的，因为JavaScriptCore不桥接初始化方法。</p>
<p>现在来修改Movie以实现JSExport协议。使用以下代码来替换整个类：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Movie</span>: <span class="title">NSObject</span>, <span class="title">MovieJSExports</span> </span>&#123;</div><div class="line"> </div><div class="line">  <span class="keyword">dynamic</span> <span class="keyword">var</span> title: <span class="type">String</span></div><div class="line">  <span class="keyword">dynamic</span> <span class="keyword">var</span> price: <span class="type">String</span></div><div class="line">  <span class="keyword">dynamic</span> <span class="keyword">var</span> imageUrl: <span class="type">String</span></div><div class="line"> </div><div class="line">  <span class="keyword">init</span>(title: <span class="type">String</span>, price: <span class="type">String</span>, imageUrl: <span class="type">String</span>) &#123;</div><div class="line">    <span class="keyword">self</span>.title = title</div><div class="line">    <span class="keyword">self</span>.price = price</div><div class="line">    <span class="keyword">self</span>.imageUrl = imageUrl</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">movieWithTitle</span>(<span class="title">title</span>: <span class="title">String</span>, <span class="title">price</span>: <span class="title">String</span>, <span class="title">imageUrl</span>: <span class="title">String</span>) -&gt; <span class="title">Movie</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Movie</span>(title: title, price: price, imageUrl: imageUrl)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类方法只是简单地调用适当的初始化方法。</p>
<p>现在你的类已准备好用于JavaScript了。为了了解你可以怎么转换当前的实现，从Resources group中打开additions.js。它已经包含了以下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mapToNative = function(movies) &#123;</div><div class="line">  <span class="keyword">return</span> movies.<span class="built_in">map</span>(function (movie) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Movie</span>.movieWithTitlePriceImageUrl(movie.title, movie.price, movie.imageUrl);</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面的方法从输入数组中获取每一个元素，并使用它来构造一个Movie实例。唯一值得指出的是方法签名是如何改变的：因为JavaScript没有命名参数，所以使用驼峰命名法将额外的参数附加到方法名后面。</p>
<p>打开MovieService.swift，使用以下代码替换懒加载上下文属性的闭包实现。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> context: <span class="type">JSContext</span>? = &#123;</div><div class="line"> </div><div class="line">  <span class="keyword">let</span> context = <span class="type">JSContext</span>()</div><div class="line"> </div><div class="line">  <span class="keyword">guard</span> <span class="keyword">let</span></div><div class="line">      commonJSPath = <span class="type">NSBundle</span>.mainBundle().pathForResource(<span class="string">"common"</span>, ofType: <span class="string">"js"</span>),</div><div class="line">      additionsJSPath = <span class="type">NSBundle</span>.mainBundle().pathForResource(<span class="string">"additions"</span>, ofType: <span class="string">"js"</span>) <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Unable to read resource files."</span>)</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">let</span> common = <span class="keyword">try</span> <span class="type">String</span>(contentsOfFile: commonJSPath, encoding: <span class="type">NSUTF8StringEncoding</span>)</div><div class="line">    <span class="keyword">let</span> additions = <span class="keyword">try</span> <span class="type">String</span>(contentsOfFile: additionsJSPath, encoding: <span class="type">NSUTF8StringEncoding</span>)</div><div class="line"> </div><div class="line">    context.setObject(<span class="type">Movie</span>.<span class="keyword">self</span>, forKeyedSubscript: <span class="string">"Movie"</span>)</div><div class="line">    context.evaluateScript(common)</div><div class="line">    context.evaluateScript(additions)</div><div class="line">  &#125; <span class="keyword">catch</span> (<span class="keyword">let</span> error) &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Error while processing script file: \(error)"</span>)</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> context</div><div class="line">&#125;()</div></pre></td></tr></table></figure>
<p>没有太大的改变。加载additions.js的内容到上下文。使用JSContext的<code>setObject(_:forKeyedSubscript:)</code>方法，你同样可以让Movie原型在上下文中可用。</p>
<p>还剩下最后一件事：在MovieService.swift中，使用以下代码来替换<code>parseResponse(_:withLimit:)</code>的实现。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseResponse</span><span class="params">(response: String, withLimit limit: Double)</span></span> -&gt; [<span class="type">Movie</span>] &#123;</div><div class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> context = context <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"JSContext not found."</span>)</div><div class="line">    <span class="keyword">return</span> []</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">let</span> parseFunction = context.objectForKeyedSubscript(<span class="string">"parseJson"</span>)</div><div class="line">  <span class="keyword">let</span> parsed = parseFunction.callWithArguments([response]).toArray()</div><div class="line"> </div><div class="line">  <span class="keyword">let</span> filterFunction = context.objectForKeyedSubscript(<span class="string">"filterByLimit"</span>)</div><div class="line">  <span class="keyword">let</span> filtered = filterFunction.callWithArguments([parsed, limit]).toArray()</div><div class="line"> </div><div class="line">  <span class="keyword">let</span> mapFunction = context.objectForKeyedSubscript(<span class="string">"mapToNative"</span>)</div><div class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> unwrappedFiltered = filtered,</div><div class="line">    movies = mapFunction.callWithArguments([unwrappedFiltered]).toArray() <span class="keyword">as</span>? [<span class="type">Movie</span>] <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> []</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> movies</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码现在使用Javascript运行时的<code>mapToNative()</code>来创建Movie数组。如果现在编译并运行，你可以看到app仍然按预期的来运行：</p>
<p><img src="https://cdn1.raywenderlich.com/wp-content/uploads/2016/01/4.jpg" alt="image"></p>
<p>恭喜你！不仅创建了一个浏览电影的很棒的App，同时也学会了通过重用完全由不同的语言实现的代码来创建它。</p>
<h2 id="下一步去哪里？"><a href="#下一步去哪里？" class="headerlink" title="下一步去哪里？"></a>下一步去哪里？</h2><p>你可以在<a href="https://developer.apple.com/videos/play/wwdc2013-615/" target="_blank" rel="external">这里</a>下载这篇教程完整的代码。</p>
<p>如果你想学习更多关于JavaScriptCore知识，可以看看WWDC 2013的<a href="https://developer.apple.com/videos/play/wwdc2013-615/" target="_blank" rel="external">Session 615</a></p>
<p>我希望你喜欢这篇JavaScriptCore教程。如果有任何问题或评论，可以参考到下面的讨论中来！</p>
<hr>
<p>欢迎关注我的微信公众号：iOS知识小集，扫扫左边<strong>站点概览</strong>里的二维码就OK了。对了，还有微博：<a href="http://weibo.com/touristdiary" target="_blank" rel="external">@南峰子_老驴</a>。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/20/perfect-smooth-scrolling-in-uitableviews/" itemprop="url">
                  Perfect smooth scrolling in UITableViews
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-12-20T21:42:15+08:00" content="2015-12-20">
              2015-12-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>原文由<a href="https://medium.com/@plasm" target="_blank" rel="external">Alexander Orlov</a>发表于medium，地址为<a href="https://medium.com/ios-os-x-development/perfect-smooth-scrolling-in-uitableviews-fd609d5275a5#.so9tpnlk1" target="_blank" rel="external">https://medium.com/ios-os-x-development/perfect-smooth-scrolling-in-uitableviews-fd609d5275a5#.so9tpnlk1</a></p>
<p>这篇文章是前两周<a href="http://weibo.com/u/1438670852?from=usercardnew&amp;is_all=1" target="_blank" rel="external">@叶孤城</a> 叶大在微信群里面的分享，一直到这两天才翻出来研究。很多实用的东西，不过由于水平有限，有些地方没能翻译好，还请大家指正。</p>
</blockquote>
<p>我已经在iOS这个最好的移动平台上有几年的开发经验了。在这期间，我已以接触过很多的iOS应用和iOS工程师。</p>
<p>我们的世界很多好的开发者，但有时我发现他们中的一些人并不是很清楚如何充分利用这个最受欢迎的移动设备的整体潜力，来开发真正平滑的应用。</p>
<p>现在，我将尝试从我的视角，来说明一下为了让<code>UITableView</code>更快更平滑，工程师应该做哪些优化。</p>
<hr>
<p>文章越往后，难度和深度也会不断增加，所以我将以一些你熟悉的东西来开始。文章后面将会讨论iOS绘画系统和UIKit更深层次的一些东西。</p>
<h2 id="内建方法"><a href="#内建方法" class="headerlink" title="内建方法"></a>内建方法</h2><p>我相信大多数阅读这篇文章的人都知道这些方法，但一些人，即便是使用过这些方法，也没有以正确的姿式来使用它们。</p>
<p>✻ ✻ ✻ ✻ ✻</p>
<p>首先是重用<code>cell/header/footer</code>的单个实例，即便是我们需要显示多个。这是优化<code>UIScrollView</code>(<code>UITableView</code>的父类)最明显的方式，<code>UIScrollView</code>是由苹果的工程师提供的。为了正确的使用它，你应该只有<code>cell/header/footer</code>类，一次性初始化它们，并返回给<code>UITableView</code>。</p>
<p>在苹果的开发文档里面已经描述了重用<code>cell</code>的流程，在这就没有必须再重复了。</p>
<p>但重要的事情是：在<code>UITableView</code>的<code>dataSource</code>中实现的<code>tableView:cellForRowAtIndexPath:</code>方法，需要为每个<code>cell</code>调用一次，它应该快速执行。所以你需要尽可能快地返回重用<code>cell</code>实例。</p>
<blockquote>
<p>不要在这里去执行数据绑定，因为目前在屏幕上还没有<code>cell</code>。为了执行数据绑定，可以在<code>UITableView</code>的<code>delegate</code>方法<code>tableView:willDisplayCell:forRowAtIndexPath:</code>中进行。这个方法在显示<code>cell</code>之前会被调用。</p>
</blockquote>
<p>✻ ✻ ✻ ✻ ✻</p>
<p>第二点也不难理解，但是有一件事需要解释一下。</p>
<p>这个方法对于<code>cell</code>定高的<code>UITableView</code>来说没有意义，但如果由于某些原因需要动态高度的<code>cell</code>的话，这个方法可以很容易地让滑动更流畅。</p>
<p>正如我们所知，<code>UITableView</code>是<code>UIScrollView</code>的子类，而<code>UIScrollView</code>的作用是让用户可以与比屏幕实际尺寸更大的区域交互。任何<code>UIScrollView</code>的实例都使用诸如<code>contentSize</code>、<code>contentOffset</code>和其它许多属性来将正确的区域显示给用户。</p>
<p>但是<code>UITableView</code>的问题在哪？正如所解释的一样，<code>UITableView</code>不会同时维护所有<code>cell</code>的实例。相反，它只需要维护显示给用户的那些<code>cell</code>。</p>
<p>那么，<code>UITableView</code>是如何知道它的<code>contentSize</code>呢？它是通过计算所以<code>cell</code>的高度之和来计算<code>contentSize</code>的值。</p>
<p><code>UITableView</code>的<code>delegate</code>方法<code>tableView:heightForRowAtIndexPath:</code>会为每个<code>cell</code>调用一次，所以你应该非常快地返回高度值。</p>
<p>很多人会犯一个错误，他们会在布局初始化<code>cell</code>实例并绑定数据后去获取它们的高度。如果你想优化滑动的性能，就不应该以这种方式来计算<code>cell</code>的高度，因为这事难以置信的低效，iOS设备标准的<code>60 FPS</code>将会降低到<code>15-20 FPS</code>，滑动会变得很慢。</p>
<p>如果我们没有一个<code>cell</code>的实例，那如何去计算它的高度呢？这里有一段示例代码，它使用类方法，并基于传入的宽度及显示的数据来计算高度值:</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Perfect%20smooth%20scrolling%20in%20UITableViews%201.jpg?raw=true" alt="image"></p>
<p>可以用以下方式来使用上面这个方法返回高度值给<code>UITableView</code>:</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Perfect%20smooth%20scrolling%20in%20UITableViews%202.jpg?raw=true" alt="image"></p>
<p>你在实现这一切的时候能获得了多少乐趣呢？大多数人会说没有。我没有保证过这事很容易。当然，我们可以构建我们自己的类来手动布局和计算高度，但有时候我们没有足够的时间来做这件事。你可以在<a href="https://telegram.org/apps" target="_blank" rel="external">Telegram</a>的iOS应用代码中找到这种实现的例子。</p>
<p>从iOS 8开始，我们可以在<code>UITableView</code>的<code>delegate</code>中使用自动高度计算，而不需要实现上面提到的方法。为了实现这一功能，你可能会使用<code>AutoLayout</code>，并将<code>rowHeight</code>变量设置为<code>UITableViewAutomaticDimension</code>。可以在<a href="http://stackoverflow.com/a/18746930" target="_blank" rel="external">StackOverflow</a>中找到更多详细的信息。</p>
<p>尽管可以使用这些方法，但我强烈建议不要使用它们。另外，我也不建议使用复杂的数学计算来获取<code>cell</code>的高度，如果可能，只使用加、减、乘、除就可以。</p>
<p>但如果是<code>AutoLayout</code>呢？它真的跟我所说的一样慢么？你可能会很惊讶，但这是事实。如果你想让你的App在所有设备上都能平滑的滚动，你就会发现这种方法难以置信的慢。你使用的子视图越多，<code>AutoLayout</code>的效率越低。</p>
<p><code>AutoLayout</code>相对低效的原因是隐藏在底层的命名为”<code>Cassowary</code>“的约束求解系统。如果布局中子视图越多，那么需要求解的约束也越多，进而返回<code>cell</code>给<code>UITableView</code>所花的时间也越多。</p>
<p>哪一个更快呢：使用少量的值来执行基本的数学计算，还是找一个求解大量线性等式或不等式的系统么？现在想像一下，用户想要快速地滑动，每个<code>cell</code>的自动布局也执行着疯狂的计算。</p>
<p>✻ ✻ ✻ ✻ ✻</p>
<p>使用内建方法优化<code>UITableView</code>的正确方法是：</p>
<ul>
<li>重用<code>cell</code>实例：对于特殊类型的<code>cell</code>，你应该只有一个实例，而没有更多。</li>
<li>不要在<code>cellForRowAtIndexPath:</code>方法中绑定数据，因为在此时<code>cell</code>还没有显示。可以使用<code>UITableView</code>的<code>delegate</code>中的<code>tableView:willDisplayCell:forRowAtIndexPath:</code>方法。</li>
<li>快速计算<code>cell</code>高度。对于工程师来说这是常规工作，但你将会为优化复杂<code>cell</code>的平滑滑动所付出的耐心而获取回报。</li>
</ul>
<h2 id="我们需要更深一步"><a href="#我们需要更深一步" class="headerlink" title="我们需要更深一步"></a>我们需要更深一步</h2><p>当然，上面提到的这些点不足以实现真正的平滑滚动，特别是当你需要实现一些复杂的<code>cell</code>(如有大量的渐变、视图、交互元素、一些修饰元素等等)时，这变得尤其明显。</p>
<p>这种情况下，<code>UITableView</code>很容易变得缓慢，即便是做了上面所有的事情。<code>UITableViewCell</code>中的视图越多，滑动时FPS越低。但在使用了手动布局和优化了高度计算后，问题就不在布局了，而在渲染了。</p>
<p>✻ ✻ ✻ ✻ ✻</p>
<p>让我们把关注点放在<code>UIView</code>的<code>opaque</code>属性上。文档中说它用于辅助绘图系统定义<code>UIView</code>是否透明。如果不透明，则绘图系统在渲染视图时可以做一些优化，以提高性能。</p>
<p>我们需要性能，或者不是？用户可能快速地滑动table，如使用<code>scrollsToTop</code>特性，但他们可能没有最新的<code>iPhone</code>，所以<code>cell</code>必须快速地被渲染。比通常的视图更快。</p>
<p>渲染最慢的操作之一是混合(<code>blending</code>)。混合操作由GPU来执行，因为这个硬件就是用来做混合操作的（当然不只是混合）。</p>
<p>你可能已经猜到，提高性能的方法是减少混合操作的次数。但在此之前，我们需要找到它。让我们来试试。</p>
<p>在iOS模拟器上运行App，在模拟器的菜单中选择’<code>Debug</code>‘，然后选中’<code>Color Blended Layers</code>‘。然后iOS模拟器就会将全部区域显示为两种颜色：绿色和红色。</p>
<p>绿色区域没有混合，但红色区域表示有混合操作。</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Perfect%20smooth%20scrolling%20in%20UITableViews%203.jpg?raw=true" alt="image"></p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Perfect%20smooth%20scrolling%20in%20UITableViews%204.jpg?raw=true" alt="image"></p>
<p>正如你所看到的一样，在<code>cell</code>中至少有两处执行了混合操作，但你可能看不出差别来（这个混合操作是不必要的）。</p>
<p>每种情况都应该仔细研究，不同的情况需要使用不同的方法来避免混合。在我这里，我需要做的只是设置<code>backgroundColor</code>来实现非透明。</p>
<p>但有时候可能更复杂。看看这个：我们有一个渐变，但是没有混合。</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Perfect%20smooth%20scrolling%20in%20UITableViews%205.jpg?raw=true" alt="image"></p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Perfect%20smooth%20scrolling%20in%20UITableViews%206.jpg?raw=true" alt="image"></p>
<p>如果想要使用<code>CAGradientLayer</code>来实现这个效果，你将会很失望：在iPhone 6中FPS将会降到<code>25-30</code>，快速滑动变得不可能。</p>
<p>这确实发生了，因为我们混合了两个不同层的内容：<code>UILabel</code>的<code>CATextLayer</code>和我们的<code>CAGradientLayer</code>。</p>
<p>如果能正确地利用了<code>CPU</code>和<code>GPU</code>资源，它们将会均匀地负载，FPS保持在<code>60</code>帧。看起来就像下面这样：</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Perfect%20smooth%20scrolling%20in%20UITableViews%207.jpg?raw=true" alt="image"></p>
<p>当设备需要执行很多混合操作时，问题就出现了：<code>GPU</code>是满载的，但<code>CPU</code>却保持低负载，而显得没有太大用处。</p>
<p>大多数工程师在2010年夏季末时都面临这个问题，当时发布了iPhone 4。Apple发布了革命性的<code>Retina</code>显示屏和…非常普通的<code>GPU</code>。然而，通常情况下它仍然有足够的能力，但上面描述的问题却变得越来越频繁。</p>
<p>你可以在当前运行iOS 7系统的iPhone 4上看到这一现象–所有的应用都变得很慢，即使是最简单的应用。不过，应用这篇文章中的介绍的方法，即使是在这种情况下，你的应用也能达到<code>60 FPS</code>，尽管会有些困难。</p>
<p>所以，需要怎么做呢？事实上，解决方案是：使用<code>CPU</code>来渲染！这将不会加载GPU，这样就无法执行混合操作。例如，在执行动画的<code>CALayer</code>上。</p>
<p>我们可以在<code>UIView</code>的<code>drawRect:</code>方法中使用<code>CoreGraphics</code>操作来执行<code>CPU</code>渲染，如下所示：</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Perfect%20smooth%20scrolling%20in%20UITableViews%208.jpg?raw=true" alt="image"></p>
<p>这段代码nice么？我会告诉你并非如此。甚至通过这种方式，你会撤销在一些<code>UIView</code>上(在任何情况下，它们都是不必要的)的所有缓存优化操作。但是，这种方法禁用了一些混合操作，卸载<code>GPU</code>，从而使<code>UITableView</code>的更顺畅。</p>
<p>但是记住：这提高了渲染性能，不是因为<code>CPU</code>比<code>GPU</code>更快！它可以让我们通过为让<code>CPU</code>来执行某些渲染任务，从而卸载<code>GPU</code>，因为在很多情况下，<code>CPU</code>可能不是100%负载的。</p>
<p>优化混合操作的关键点是在平衡<code>CPU</code>和<code>GPU</code>的负载。</p>
<p>✻ ✻ ✻ ✻ ✻</p>
<p>优化<code>UITableView</code>中绘制数据操作的小结：</p>
<ul>
<li>减少iOS执行无用混合的区域：不要使用透明背景，使用iOS模拟器或者<code>Instruments</code>来确认这一点；如果可以，尽量使用没有混合的渐变。</li>
<li>优化代码，以平衡<code>CPU</code>和<code>GPU</code>的负载。你需要清楚地知道哪部分渲染需要使用<code>GPU</code>，哪部分可以使用<code>CPU</code>，以此保持平衡。</li>
<li>为特殊的<code>cell</code>类型编写特殊的代码。</li>
</ul>
<h2 id="像素获取"><a href="#像素获取" class="headerlink" title="像素获取"></a>像素获取</h2><p>你知道像素看起来是什么样的么？我的意思是，屏幕上的物理像素是什么样的？我肯定你知道，但我还是想让你看一下：</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Perfect%20smooth%20scrolling%20in%20UITableViews%209.jpeg?raw=true" alt="image"></p>
<p>不同的屏幕有不同的制作工艺，但有一件事是一样的。事实上，每个物理像素由三个颜色的子像素组成：红、绿、蓝。</p>
<p>基于这一事实，像素不是原子单位，虽然对于应用来说它是。或者仍然不是？</p>
<p>直到带有<code>Retina</code>屏的iPhone 4发布前，物理像素都可以用整型点坐标来描述。自从有了<code>Retina</code>屏后，在<code>Cocoa Touch</code>环境下，我们就可以用屏幕点来取代像素了，同时屏幕点可以是浮点值。</p>
<p>在完美的世界中(我们尝试构建的)，屏幕点总是被处理成物理像素的整型坐标。但在现实生活中它可能是浮点值，例如，线段可能起始于<code>x</code>为<code>0.25</code>的地方。这时候，iOS将执行子像素渲染。</p>
<p>这一技术在应用于特定类型的内容(如文本)时很有意义。但当我们绘制平滑直线时则没有必要。</p>
<p>如果所有的平滑线段都使用子像素渲染技术来渲染，那你会让iOS执行一些不必要的任务，从而降低FPS。</p>
<p>✻ ✻ ✻ ✻ ✻</p>
<p>什么情况下会出现这种不必要的子像素抗锯齿操作呢？最常发生的情况是通过代码计算而变成浮点值的视图坐标，或者是一些不正确的图片资源，这些图片的大小不是对齐到屏幕的物理像素上的（例如，你有一张在<code>Retina</code>显示屏上的大小为<code>60*61</code>的图片，而不是<code>60*60</code>的）。</p>
<p>在前面我们讲到，要解决问题，首先需要找到问题在哪。在iOS模拟器上运行程序，在”<code>Debug</code>“菜单中选中”<code>Color Misaligned Image</code>“。</p>
<p>这一次有两种高亮区域：品红色区域会执行子像素渲染，而黄色区域是图片大小没有对齐的情况。</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Perfect%20smooth%20scrolling%20in%20UITableViews%2010.jpg?raw=true" alt="image"></p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Perfect%20smooth%20scrolling%20in%20UITableViews%2011.jpg?raw=true" alt="image"></p>
<p>那如何在代码中找到对应的位置呢？我总是使用手动布局，并且部分会自定义绘制，所以通常找到这些地方没有任何问题。如果你使用<code>Interface Builder</code>，那我对此深表同情。</p>
<p>通常，为了解决这个问题，你只要简单地使用<code>ceilf</code>, <code>floorf</code>和<code>CGRectIntegral</code>方法来对坐标做四舍五入处理。就是这样！</p>
<p>✻ ✻ ✻ ✻ ✻</p>
<p>通过上面的讨论，我想建议你以下几点：</p>
<ul>
<li>对所有像素相关的数据做四舍五入处理，包括点坐标，<code>UIView</code>的高度和宽度。</li>
<li>跟踪你的图像资源：图片必须是像素完美的，否则在<code>Retina</code>屏幕上渲染时，它会做不必要的抗锯齿处理。</li>
<li>定期复查你的代码，因为这种情况可以会经常出现。</li>
</ul>
<h2 id="异步UI"><a href="#异步UI" class="headerlink" title="异步UI"></a>异步UI</h2><p>可能这看起来有点奇怪，但这是一种非常有效的方法。如果你知道如何做，那么可以让<code>UITableView</code>滑动得更平滑。</p>
<p>现在我们来讨论一下你应该做什么，然后再讨论下你是否可能这么做。</p>
<p>✻ ✻ ✻ ✻ ✻</p>
<p>每个中等以上规模的应用都可能会使用带有媒体内容的<code>cell</code>：文本、图片、动画，甚至还有视频。</p>
<p>而所有这些都可能带有装饰元素：圆角头像、还’#’号的文本、用户名等。</p>
<p>我们已经多次提及尽可能快地返回<code>cell</code>的需求，而在这里有一些麻烦：<code>clipsToBounds</code>很慢，图片需要从网络加载，需要在字符串中定位#号，和许多其它的问题。</p>
<p>优化的目标是很明确的：如果在主线程中执行这些操作，则会让你不能很快地返回<code>cell</code>。</p>
<p>在后台加载图片，在相同的地方处理圆角，然后将处理后的图片指定给<code>UIImageView</code>。</p>
<p>立刻显示文本，但在后台定位<code>#</code>号，然后使用属性字符串来刷新显示。</p>
<p>在你的<code>cell</code>中，需要具体情况具体分析，但主要的思想是在后台执行大的操作。这可能不止是网络代码，你需要使用<code>Instruments</code>来找到它们。</p>
<p>记住：需要尽快返回<code>cell</code>。</p>
<p>✻ ✻ ✻ ✻ ✻</p>
<p>有时候，上面的所有技术可能都帮不上忙。如<code>GPU</code>仍然不能使用(iPhone4+iOS7)时，<code>cell</code>中有很多内容时，需要<code>CALayer</code>的支持以实现动画时(因为在<code>drawRect:</code>中实现起来真的很麻烦)。</p>
<p>在这种情况下，我们需要在后台渲染所有其它东西。此外它能在用户快速滑动<code>UITableView</code>时有效地提高<code>FPS</code>。</p>
<p>我们来看看<code>Facebook</code>的应用。为了检测这些，你可能需要往下滑足够的高度，然后点击状态栏。列表会往上滑动，因此你可以清楚地看到此时没有渲染<code>cell</code>。如果想要更精确，则不能及时获得。</p>
<p>这很简单，所以你可以自己试试。这时，你需要设置<code>CALayer</code>的<code>drawsAsynchronously</code>属性为YES。</p>
<p>但是我们可以检查这些行为的必要性。在iOS模拟器上运行程序，然后选择“<code>Debug</code>”菜单中的”<code>Color Offscreen-Rendered</code>“。现在所有在后台渲染的区域都被高亮为黄色。</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Perfect%20smooth%20scrolling%20in%20UITableViews%2012.jpg?raw=true" alt="image"></p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Perfect%20smooth%20scrolling%20in%20UITableViews%2013.jpg?raw=true" alt="image"></p>
<p>如果你为某些层开启了这一模式，但是它没有高亮显示，那么它就不够慢。</p>
<p>为了在<code>CALyaer</code>层找到瓶颈并进一步减少它，你可以使用<code>Instruments</code>里面的<code>Time Profiler</code>。</p>
<p>✻ ✻ ✻ ✻ ✻</p>
<p>这里是异步化UI的实现清单：</p>
<ul>
<li>找到让你的<code>cell</code>无法快速返回的瓶颈。</li>
<li>将操作移到后台线程，并在主线程刷新显示的内容。</li>
<li>最后一招是设置你的<code>CALayer</code>为异步显示模式(即使只是简单的文本或图片)–这将帮你提高FPS。</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我尝试解释了iOS绘图系统(没有使用<code>OpenGL</code>，因为它的情况更少)的主要思路。当然有些看起来很模糊，但事实上这只是一些方向，你应该朝着这些方向来检查你的代码以找出影响滚动性能的所有问题。</p>
<p>具体情况具体分析，但原则是不变的。</p>
<p>获取完美平滑滚动的关键是非常特殊的代码，它能让你竭尽iOS的能力来让你的应用更加平滑。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/13/cocoa-uikit-uicontrol/" itemprop="url">
                  UIKit: UIControl
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-12-13T11:16:26+08:00" content="2015-12-13">
              2015-12-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/cocoa/" itemprop="url" rel="index">
                    <span itemprop="name">Cocoa</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们在开发应用的时候，经常会用到各种各样的控件，诸如按钮(<code>UIButton</code>)、滑块(<code>UISlider</code>)、分页控件(<code>UIPageControl</code>)等。这些控件用来与用户进行交互，响应用户的操作。我们查看这些类的继承体系，可以看到它们都是继承于<code>UIControl</code>类。<code>UIControl</code>是控件类的基类，它是一个抽象基类，我们不能直接使用<code>UIControl</code>类来实例化控件，它只是为控件子类定义一些通用的接口，并提供一些基础实现，以在事件发生时，预处理这些消息并将它们发送到指定目标对象上。</p>
<p>本文将通过一个自定义的<code>UIControl</code>子类来看看<code>UIControl</code>的基本使用方法。不过在开始之前，让我们先来了解一下<code>Target-Action</code>机制。</p>
<h2 id="Target-Action机制"><a href="#Target-Action机制" class="headerlink" title="Target-Action机制"></a>Target-Action机制</h2><p><code>Target-action</code>是一种设计模式，直译过来就是”目标-行为”。当我们通过代码为一个按钮添加一个点击事件时，通常是如下处理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[button addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(tapButton:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</div></pre></td></tr></table></figure>
<p>也就是说，当按钮的点击事件发生时，会将消息发送到<code>target</code>(此处即为self对象)，并由<code>target</code>对象的<code>tapButton:</code>方法来处理相应的事件。其基本过程可以用下图来描述：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/Devpedia-CocoaApp/Art/target_action.jpg" alt="image"></p>
<blockquote>
<p>注：图片来源于官方文档<a href="https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/Devpedia-CocoaApp/TargetAction.html" target="_blank" rel="external">Cocoa Application Competencies for iOS - Target Action</a></p>
</blockquote>
<p>即当事件发生时，事件会被发送到控件对象中，然后再由这个控件对象去触发<code>target</code>对象上的<code>action</code>行为，来最终处理事件。因此，<code>Target-Action</code>机制由两部分组成：即目标对象和行为<code>Selector</code>。目标对象指定最终处理事件的对象，而行为<code>Selector</code>则是处理事件的方法。</p>
<p>有关<code>Target-Action</code>机制的具体描述，大家可以参考<a href="https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/Devpedia-CocoaApp/TargetAction.html" target="_blank" rel="external">Cocoa Application Competencies for iOS - Target Action</a>。我们将会在下面讨论一些<code>Target-action</code>更深入的东西。</p>
<h2 id="实例：一个带Label的图片控件"><a href="#实例：一个带Label的图片控件" class="headerlink" title="实例：一个带Label的图片控件"></a>实例：一个带Label的图片控件</h2><p>回到我们的正题来，我们将实现一个带Label的图片控件。通常情况下，我们会基于以下两个原因来实现一个自定义的控件：</p>
<ul>
<li>对于特定的事件，我们需要观察或修改分发到<code>target</code>对象的行为消息。</li>
<li>提供自定义的跟踪行为。</li>
</ul>
<p>本例将会简单地结合这两者。先来看看效果：</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/UIControl%20Example.png?raw=true" alt="image"></p>
<p>这个控件很简单，以图片为背景，然后在下方显示一个Label。</p>
<p>先创建<code>UIControl</code>的一个子类，我们需要传入一个字符串和一个UIImage对象：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ImageControl</span> : <span class="title">UIControl</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame title:(<span class="built_in">NSString</span> *)title image:(<span class="built_in">UIImage</span> *)image;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>基础的布局我们在此不讨论。我们先来看看<code>UIControl</code>为我们提供了哪些自定义跟踪行为的方法。</p>
<h3 id="跟踪触摸事件"><a href="#跟踪触摸事件" class="headerlink" title="跟踪触摸事件"></a>跟踪触摸事件</h3><p>如果是想提供自定义的跟踪行为，则可以重写以下几个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)beginTrackingWithTouch:(<span class="built_in">UITouch</span> *)touch withEvent:(<span class="built_in">UIEvent</span> *)event</div><div class="line">- (<span class="built_in">BOOL</span>)continueTrackingWithTouch:(<span class="built_in">UITouch</span> *)touch withEvent:(<span class="built_in">UIEvent</span> *)event</div><div class="line">- (<span class="keyword">void</span>)endTrackingWithTouch:(<span class="built_in">UITouch</span> *)touch withEvent:(<span class="built_in">UIEvent</span> *)event</div><div class="line">- (<span class="keyword">void</span>)cancelTrackingWithEvent:(<span class="built_in">UIEvent</span> *)event</div></pre></td></tr></table></figure>
<p>这四个方法分别对应的时跟踪开始、移动、结束、取消四种状态。看起来是不是很熟悉？这跟<code>UIResponse</code>提供的四个事件跟踪方法是不是挺像的？我们来看看<code>UIResponse</code>的四个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</div><div class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</div><div class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</div><div class="line">- (<span class="keyword">void</span>)touchesCancelled:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</div></pre></td></tr></table></figure>
<p>我们可以看到，上面两组方法的参数基本相同，只不过<code>UIControl</code>的是针对单点触摸，而<code>UIResponse</code>可能是多点触摸。另外，返回值也是大同小异。由于<code>UIControl</code>本身是视图，所以它实际上也继承了<code>UIResponse</code>的这四个方法。如果测试一下，我们会发现在针对控件的触摸事件发生时，这两组方法都会被调用，而且互不干涉。</p>
<p>为了判断当前对象是否正在追踪触摸操作，<code>UIControl</code>定义了一个<code>tracking</code>属性。该值如果为YES，则表明正在追踪。这对于我们是更加方便了，不需要自己再去额外定义一个变量来做处理。</p>
<p>在测试中，我们可以发现当我们的触摸点沿着屏幕移出控件区域名，还是会继续追踪触摸操作，<code>cancelTrackingWithEvent:</code>消息并未被发送。为了判断当前触摸点是否在控件区域类，可以使用<code>touchInside</code>属性，这是个只读属性。不过实测的结果是，在控件区域周边一定范围内，该值还是会被标记为YES，即用于判定<code>touchInside</code>为YES的区域会比控件区域要大。</p>
<h3 id="观察或修改分发到target对象的行为消息"><a href="#观察或修改分发到target对象的行为消息" class="headerlink" title="观察或修改分发到target对象的行为消息"></a>观察或修改分发到target对象的行为消息</h3><p>对于一个给定的事件，<code>UIControl</code>会调用<code>sendAction:to:forEvent:</code>来将行为消息转发到<code>UIApplication</code>对象，再由<code>UIApplication</code>对象调用其<code>sendAction:to:fromSender:forEvent:</code>方法来将消息分发到指定的<code>target</code>上，而如果我们没有指定<code>target</code>，则会将事件分发到响应链上第一个想处理消息的对象上。而如果子类想监控或修改这种行为的话，则可以重写这个方法。</p>
<p>在我们的实例中，做了个小小的处理，将外部添加的<code>Target-Action</code>放在控件内部来处理事件，因此，我们的代码实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ImageControl.m</span></div><div class="line">- (<span class="keyword">void</span>)sendAction:(SEL)action to:(<span class="keyword">id</span>)target forEvent:(<span class="built_in">UIEvent</span> *)event &#123;</div><div class="line">	<span class="comment">// 将事件传递到对象本身来处理</span></div><div class="line">    [<span class="keyword">super</span> sendAction:<span class="keyword">@selector</span>(handleAction:) to:<span class="keyword">self</span> forEvent:event];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)handleAction:(<span class="keyword">id</span>)sender &#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"handle Action"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ViewController.m</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line"></div><div class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</div><div class="line"></div><div class="line">    ImageControl *control = [[ImageControl alloc] initWithFrame:(<span class="built_in">CGRect</span>)&#123;<span class="number">50.0</span>f, <span class="number">100.0</span>f, <span class="number">200.0</span>f, <span class="number">300.0</span>f&#125; title:<span class="string">@"This is a demo"</span> image:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"demo"</span>]];</div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    [control addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(tapImageControl:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)tapImageControl:(<span class="keyword">id</span>)sender &#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"sender = %@"</span>, sender);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于我们重写了<code>sendAction:to:forEvent:</code>方法，所以最后处理事件的<code>Selector</code>是<code>ImageControl</code>的<code>handleAction:</code>方法，而不是ViewController的<code>tapImageControl:</code>方法。</p>
<p>另外，<code>sendAction:to:forEvent:</code>实际上也被<code>UIControl</code>的另一个方法所调用，即<code>sendActionsForControlEvents:</code>。这个方法的作用是发送与指定类型相关的所有行为消息。我们可以在任意位置(包括控件内部和外部)调用控件的这个方法来发送参数<code>controlEvents</code>指定的消息。在我们的示例中，在ViewController.m中作了如下测试：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    [control addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(tapImageControl:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</div><div class="line"></div><div class="line">    [control sendActionsForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到在未点击控件的情况下，触发了<code>UIControlEventTouchUpInside</code>事件，并打印了<code>handle Action</code>日志。</p>
<h2 id="Target-Action的管理"><a href="#Target-Action的管理" class="headerlink" title="Target-Action的管理"></a>Target-Action的管理</h2><p>为一个控件对象添加、删除<code>Target-Action</code>的操作我们都已经很熟悉了，主要使用的是以下两个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 添加</span></div><div class="line">- (<span class="keyword">void</span>)addTarget:(<span class="keyword">id</span>)target action:(SEL)action forControlEvents:(<span class="built_in">UIControlEvents</span>)controlEvents</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)removeTarget:(<span class="keyword">id</span>)target action:(SEL)action forControlEvents:(<span class="built_in">UIControlEvents</span>)controlEvents</div></pre></td></tr></table></figure>
<p>如果想获取控件对象所有相关的target对象，则可以调用<code>allTargets</code>方法，该方法返回一个集合。集合中可能包含<code>NSNull</code>对象，表示至少有一个nil目标对象。</p>
<p>而如果想获取某个target对象及事件相关的所有action，则可以调用<code>actionsForTarget:forControlEvent:</code>方法。</p>
<p>不过，这些都是<code>UIControl</code>开放出来的接口。我们还是想要探究一下，<code>UIControl</code>是如何去管理<code>Target-Action</code>的呢？</p>
<p>实际上，我们在程序某个合适的位置打个断点来观察<code>UIControl</code>的内部结构，可以看到这样的结果：</p>
<p><img src="https://raw.githubusercontent.com/southpeak/Blog-images/master/UIControl%20Example%202.png" alt="image"></p>
<p>因此，<code>UIControl</code>内部实际上是有一个可变数组(<code>_targetActions</code>)来保存<code>Target-Action</code>，数组中的每个元素是一个<code>UIControlTargetAction</code>对象。<code>UIControlTargetAction</code>类是一个私有类，我们可以在<a href="https://github.com/nst/iOS-Runtime-Headers/blob/master/Frameworks/UIKit.framework/UIControlTargetAction.h" target="_blank" rel="external">iOS-Runtime-Header</a>中找到它的头文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIControlTargetAction</span> : <span class="title">NSObject</span> </span>&#123;</div><div class="line">    SEL _action;</div><div class="line">    <span class="built_in">BOOL</span> _cancelled;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> _eventMask;</div><div class="line">    <span class="keyword">id</span> _target;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> cancelled;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>).cxx_destruct;</div><div class="line">- (<span class="built_in">BOOL</span>)cancelled;</div><div class="line">- (<span class="keyword">void</span>)setCancelled:(<span class="built_in">BOOL</span>)arg1;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>可以看到<code>UIControlTargetAction</code>对象维护了一个<code>Target-Action</code>所必须的三要素，即<code>target</code>，<code>action</code>及对应的事件<code>eventMask</code>。</p>
<p>如果仔细想想，会发现一个有意思的问题。我们来看看实例中ViewController(target)与ImageControl实例(control)的引用关系，如下图所示：</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/UIControl%20Example%203.png?raw=true" alt="image"></p>
<p>嗯，循环引用。</p>
<p>既然这样，就必须想办法打破这种循环引用。那么在这5个环节中，哪个地方最适合做这件事呢？仔细思考一样，1、2、4肯定是不行的，3也不太合适，那就只有5了。在上面的<code>UIControlTargetAction</code>头文件中，并没有办法看出<code>_target</code>是以<code>weak</code>方式声明的，那有证据么？</p>
<p>我们在工程中打个<code>Symbolic</code>断点，如下所示：</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/UIControl%20Example%205.png?raw=true" alt="image"></p>
<p>运行程序，程序会进入<code>[UIControl addTarget:action:forControlEvents:]</code>方法的汇编代码页，在这里，我们可以找到一些蛛丝马迹。如下图所示：</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/UIControl%20Example%204.png?raw=true" alt="image"></p>
<p>可以看到，对于<code>_target</code>成员变量，在<code>UIControlTargetAction</code>的初始化方法中调用了<code>objc_storeWeak</code>，即这个成员变量对外部传进来的<code>target</code>对象是以<code>weak</code>的方式引用的。</p>
<p>其实在<code>UIControl</code>的文档中，<code>addTarget:action:forControlEvents:</code>方法的说明还有这么一句：</p>
<blockquote>
<p>When you call this method, target is not retained.</p>
</blockquote>
<p>另外，如果我们以同一组target-action和event多次调用<code>addTarget:action:forControlEvents:</code>方法，在<code>_targetActions</code>中并不会重复添加<code>UIControlTargetAction</code>对象。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>控件是我们在开发中常用的视图工具，能很好的表达用户的意图。我们可以使用UIKit提供的控件，也可以自定义控件。当然，<code>UIControl</code>除了上述的一些方法，还有一些属性和方法，以及一些常量，大家可以参考文档。</p>
<p>示例工程的代码已上传到github，可以在<a href="https://github.com/southpeak/iOS-Dev-Examples/tree/master/UIKit/UIView/2.%20UIControlExample" target="_blank" rel="external">这里</a>下载。另外，推荐一下<a href="https://github.com/samvermette/SVSegmentedControl" target="_blank" rel="external">SVSegmentedControl</a>这个控件，大家可以研究下它的实现。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIControl_Class" target="_blank" rel="external">UIControl Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/UIKitUICatalog/UIControl.html#//apple_ref/doc/uid/TP40012857-UIControl" target="_blank" rel="external">UIKit User Interface Catalog - About Controls</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/Devpedia-CocoaApp/TargetAction.html" target="_blank" rel="external">Cocoa Application Competencies for iOS - Target Action</a></li>
<li><a href="https://github.com/nst/iOS-Runtime-Headers/blob/master/Frameworks/UIKit.framework/UIControlTargetAction.h" target="_blank" rel="external">iOS-Runtime-Header: UIControlTargetAction</a></li>
<li><a href="https://github.com/samvermette/SVSegmentedControl" target="_blank" rel="external">SVSegmentedControl</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/22/cocoa-uikit-uiimage/" itemprop="url">
                  UIKit: UIImage
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-11-22T09:20:56+08:00" content="2015-11-22">
              2015-11-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/cocoa/" itemprop="url" rel="index">
                    <span itemprop="name">Cocoa</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>UIImage</code>对象是iOS中用来显示图像数据的高级接口。我们可以从文件，<code>NSData</code>，<code>Quartz</code>图片对象中创建<code>UIImage</code>对象。可以说这个类是我们接触频率非常高的一个类。</p>
<h2 id="UIImage的不可变性"><a href="#UIImage的不可变性" class="headerlink" title="UIImage的不可变性"></a>UIImage的不可变性</h2><p><code>UIImage</code>对象是不可变的，所以一旦创建后，我们就不能再改变它的属性。这也就意味着，我们只能在初始化方法中提供属性值或依赖于图片自身的属性值。同样，由于其不可变，所以在任何线程中都可以安全地使用它。</p>
<p>如果我们想修改<code>UIImage</code>对象的一些属性，则可以使用便捷方法和自定义的参数值来创建图像的一份拷贝。</p>
<p>另外，由于<code>UIImage</code>对象是不可变的，所以它没有提供访问底层图片数据的方法。不过我们可以使用<code>UIImagePNGRepresentation</code>或<code>UIImageJPEGRepresentation</code>方法来获取包含PNG或JPG格式的数据的<code>NSData</code>对象。如下代码所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> image = <span class="type">UIImage</span>(named: <span class="string">"swift"</span>);</div><div class="line"></div><div class="line"><span class="keyword">let</span> imageData:<span class="type">NSData</span>? = <span class="type">UIImageJPEGRepresentation</span>(image!, <span class="number">1.0</span>)</div></pre></td></tr></table></figure>
<h2 id="创建UIImage对象"><a href="#创建UIImage对象" class="headerlink" title="创建UIImage对象"></a>创建UIImage对象</h2><p>对于一个UIImage对象来说，它的数据源主要有以下几种：</p>
<ol>
<li>文件：我们可以使用<code>init(contentsOfFile:)</code>方法来从指定文件中创建对象。</li>
<li>纯图片数据(<code>NSData</code>)：如果在内存中有图片的原始数据(表示为<code>NSData</code>对象)，则可以使用<code>init(data:)</code>来创建。需要注意的是这个方法会对象图片数据做缓存。</li>
<li><code>CGImage</code>对象：如果我们有一个<code>CGImage</code>对象，则可以使用<code>init(CGImage:)</code>或<code>init(CGImage:scale:orientation:)</code>创建<code>UIImage</code>对象。</li>
<li><code>CIImage</code>对象：如果我们有一个<code>CIImage</code>对象，则可以使用<code>init(CIImage:)</code>或<code>init(CIImage:scale:orientation:)</code>创建<code>UIImage</code>对象。</li>
</ol>
<p>需要注意的是，如果是从文件或者纯图片数据中创建<code>UIImage</code>对象，则要求对应的图片格式是系统支持的图片类型。</p>
<p>对于<code>Objective-C</code>来说，<code>UIImage</code>对象也提供了这些初始化方法对应的便捷类方法来创建对象。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>在实际的应用中，特别是图片类应用中，我们可能需要使用大量的图片。我们都知道，图片通常都是非常占内存的。如果同一时间加载大量的图片，就可能占用大量的系统内存。</p>
<p>为此，Apple采用了一种比较巧妙的策略。在低内存的情况下，系统会强制清除<code>UIImage</code>对象所指向的图片数据，以释放部分内存。注意，这种清除行为影响到的只是图片数据，而不会影响到<code>UIImage</code>对象本身。当我们需要绘制那些图片数据已经被清除的<code>UIImage</code>对象时，对象会自动从源文件中重新加载数据。当然，这是以时间换空间的一种策略，会导致一定的性能损耗。</p>
<p>说到这里，我们不得不提一下<code>init(named:)</code>方法了。可以说我们平时创建<code>UIImage</code>对象用得最多的应该就是这个方法。这个方法主要是使用<code>bundle</code>中的文件创建图片的快捷方式。关于这个方法，有几点需要注意：</p>
<ol>
<li><strong>缓存</strong>：这个方法会首先去系统缓存中查找是否有图片名对应的图片。如果有就返回缓存中的图片；如果没有，则该方法从磁盘或者<code>asset catalog</code>中加载图片并返回，同时将图片缓存到系统中。缓存的图片只有在收到内存警告时才会释放。因此，如果图片的使用频率比较低，则可以考虑使用<code>imageWithContentsOfFile:</code>方法来加载图片，这样可以减少内存资源的消耗。当然，这需要权衡考虑，毕竟读写磁盘也是有性能消耗的，而且现在的高端机内存已经不小了。</li>
<li><strong>多分辨率图片处理</strong>：在iOS 4.0后，该方法会根据屏幕的分辨率来查找对应尺寸的图片。即我们使用时，只需要写图片名，而不需要指定是1x, 2x还是3x图，该方法会自己判断。</li>
<li><strong>png图片后缀</strong>：在iOS 4.0以后，如果图片是png格式的，则图片文件名不需要附带扩展名。</li>
<li><strong>线程安全性</strong>：该方法在iOS 9.0之前并不是线程安全的，在二级线程中调用可能会导致崩溃。在iOS 9.0之后，Apple作了优化处理，将其改为线程安全的方法。为了避免不必要的麻烦，尽量在主线程中调用这个方法。</li>
</ol>
<h2 id="图片拉伸"><a href="#图片拉伸" class="headerlink" title="图片拉伸"></a>图片拉伸</h2><p>当我们的图片比所要填充的区域小时，会导致图片变形。如以下图片，原始大小为100*30，将其放到一个300*50的<code>UIImageView</code>中时，整个图片被拉伸。</p>
<p><strong>原始图片</strong></p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/UIKit_UIImage.png?raw=true" alt="image"></p>
<p><strong>拉伸后的图片</strong></p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/UIKit_UIImage_Deform.png?raw=true" alt="image"></p>
<p>这时我们就需要做特殊的处理。</p>
<p><code>Android</code>的同学应该都知道.9图，这种图片可以只拉伸中间的部分，而保持四个角不变形。在iOS中也支持这种操作。在早期的iOS版本中，<code>UIImage</code>提供了如下方法来执行此操作：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">stretchableImageWithLeftCapWidth</span><span class="params">(<span class="number">_</span> leftCapWidth: Int, topCapHeight topCapHeight: Int)</span></span> -&gt; <span class="type">UIImage</span></div></pre></td></tr></table></figure>
<p>这个方法通过<code>leftCapWidth</code>和<code>topCapHeight</code>两个参数来定义四个角的大小。不过这个方法在iOS 5中就被<code>Deprecated</code>了，对应的两个属性<code>leftCapWidth</code>和<code>topCapHeight</code>也是相同的命运。所以现在不建议使用它们。另外，对于如何解释<code>leftCapWidth</code>和<code>topCapHeight</code>，大家可以参考一下<a href="http://weibo.com/exceptions" target="_blank" rel="external">@M了个J</a>的<a href="http://blog.csdn.net/q199109106q/article/details/8615661" target="_blank" rel="external">iOS图片拉伸技巧</a>。</p>
<p>在iOS 5中，我们可以使用以下方法来执行相同的操作：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">resizableImageWithCapInsets</span><span class="params">(<span class="number">_</span> capInsets: UIEdgeInsets)</span></span> -&gt; <span class="type">UIImage</span></div></pre></td></tr></table></figure>
<p>这个方法通过一个<code>UIEdgeInsets</code>来指定上下左右不变形的宽度或高度。它会返回一个新的图像。而如果图像被拉伸，则会以平铺的方式来处理中间的拉伸区域。</p>
<p>我们对上面的图片做如下处理：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> resizedButtonImageView = <span class="type">UIImageView</span>(image: normalButtonImage?.resizableImageWithCapInsets(<span class="type">UIEdgeInsets</span>(top: <span class="number">15</span>, <span class="keyword">left</span>: <span class="number">15</span>, bottom: <span class="number">15</span>, <span class="keyword">right</span>: <span class="number">15</span>)))</div><div class="line">resizedButtonImageView.frame = <span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">60</span>, <span class="number">300</span>, <span class="number">50</span>)</div></pre></td></tr></table></figure>
<p>其得到的结果如下所示：</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/UIKit_UIImage_Resized.png?raw=true" alt="image"></p>
<p>在iOS 6，<code>Apple</code>又为我们提供了一个新的方法，相较于上面这个方法，只是多一个<code>resizingMode</code>参数，允许我们指定拉伸模式。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">resizableImageWithCapInsets</span><span class="params">(<span class="number">_</span> capInsets: UIEdgeInsets, resizingMode resizingMode: UIImageResizingMode)</span></span> -&gt; <span class="type">UIImage</span></div></pre></td></tr></table></figure>
<p>这个方法的拉伸模式分两种：平铺(<code>Tile</code>)和拉伸(<code>Stretch</code>)。如果是平铺模式，则跟前一个方法是一样的效果。</p>
<h2 id="动效图片对象"><a href="#动效图片对象" class="headerlink" title="动效图片对象"></a>动效图片对象</h2><p>如果我们有一组大小和缩放因子相同的图片，就可以将这些图片加载到同一个<code>UIImage</code>对象中，形成一个动态的<code>UIImage</code>对象。为此，<code>UIImage</code>提供了以下方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">animatedImageNamed</span>(<span class="title">_</span> <span class="title">name</span>: <span class="title">String</span>, <span class="title">duration</span> <span class="title">duration</span>: <span class="title">NSTimeInterval</span>) -&gt; <span class="title">UIImage</span>?</span></div></pre></td></tr></table></figure>
<p>这个方法会加载以name为基准文件名的一系列文件。如，假设我们的<code>name</code>参数值为”swift”，则这个方法会加载诸如”swift0”, “swift1”,…, “swift1024”这样的一系列的文件。</p>
<p>这里有两个问题需要注意：</p>
<ol>
<li>文件的序号必须是从0开始的连续数字，如果不从0开始，则在<code>Playground</code>中是会报错的。而如果中间序号有断，而中断后的图片是不会被加载的。</li>
<li>所有文件的大小和缩放因子应该是相同的，否则显示时会有不可预期的结果，这种结果主要表现为播放的顺序可能是杂乱的。</li>
</ol>
<p>如果我们有一组基准文件名不同的文件，但其大小和缩放因子相同，则可能使用以下方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">animatedImageWithImages</span>(<span class="title">_</span> <span class="title">images</span>: [<span class="title">UIImage</span>], <span class="title">duration</span> <span class="title">duration</span>: <span class="title">NSTimeInterval</span>) -&gt; <span class="title">UIImage</span>?</span></div></pre></td></tr></table></figure>
<p>传入一个<code>UIImage</code>数组来拼装一个动效<code>UIImage</code>对象。</p>
<p>另外，<code>UIImage</code>也提供了<code>resizable</code>版本的动效方法，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">animatedResizableImageNamed</span>(<span class="title">_</span> <span class="title">name</span>: <span class="title">String</span>, <span class="title">capInsets</span> <span class="title">capInsets</span>: <span class="title">UIEdgeInsets</span>, <span class="title">duration</span> <span class="title">duration</span>: <span class="title">NSTimeInterval</span>) -&gt; <span class="title">UIImage</span>?</span></div><div class="line"></div><div class="line"><span class="title">class</span> <span class="title">func</span> <span class="title">animatedResizableImageNamed</span>(<span class="title">_</span> <span class="title">name</span>: <span class="title">String</span>, <span class="title">capInsets</span> <span class="title">capInsets</span>: <span class="title">UIEdgeInsets</span>, <span class="title">resizingMode</span> <span class="title">resizingMode</span>: <span class="title">UIImageResizingMode</span>, <span class="title">duration</span> <span class="title">duration</span>: <span class="title">NSTimeInterval</span>) -&gt; <span class="title">UIImage</span>?</div></pre></td></tr></table></figure>
<p>第一个方法的<code>UIImageResizingMode</code>默认是<code>UIImageResizingModeTile</code>，所以如果想对图片做拉伸处理，可以使用第二个的方法，并传入<code>UIImageResizingModeStretch</code>。</p>
<h2 id="图片大小的限制"><a href="#图片大小的限制" class="headerlink" title="图片大小的限制"></a>图片大小的限制</h2><p><code>UIImage</code>对象使用的图片大小尽量小于1024*1024。因为这么大的图片消耗的内存过大，在将其作为<code>OpenGL</code>中的贴图或者是绘制到<code>view/layer</code>中时，可以会出现问题。如果仅仅是代码层面的操作的话，则没有这个限制。比如，将一个大于1024*1024的图片绘制到位图图形上下文中以重新设定其大小。事实上，我们需要通过这种操作来改变图片大小，以将其绘制到视图中。</p>
<h2 id="支持的图片格式"><a href="#支持的图片格式" class="headerlink" title="支持的图片格式"></a>支持的图片格式</h2><p><code>UIImage</code>支持的图片格式在<a href="https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIImage_Class" target="_blank" rel="external">UIImage Class Reference</a>中列出来了，大家可以直接参考。</p>
<p>需要注意的一点是<code>RGB-565</code>格式的BMP文件在加载时会被转换成<code>ARGB-1555</code>格式。</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>本文的示例代码已上传到github，可点击<a href="https://github.com/southpeak/Swift/tree/master/UIKit/UIImage.playground" target="_blank" rel="external">这里</a>查看。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIImage_Class" target="_blank" rel="external">UIImage Class Reference</a></li>
<li><a href="http://blog.csdn.net/q199109106q/article/details/8615661" target="_blank" rel="external">iOS图片拉伸技巧</a></li>
<li><a href="http://blog.ibireme.com/2015/11/02/ios_image_tips/" target="_blank" rel="external">iOS 处理图片的一些小 Tip</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/05/secret-of-swift-performance-part-2/" itemprop="url">
                  Secret of Swift Performance Part 2 - Look under the hood
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-11-05T22:56:20+08:00" content="2015-11-05">
              2015-11-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文由<code>Kostiantyn Koval</code>发表于<code>Medium</code>，地址为<a href="https://medium.com/swift-programming/secret-of-swift-performance-fcc5d2a437a8" target="_blank" rel="external">Secret of Swift Performance ：Part 2 - Look under the hood</a>。</p>
<p>当想要分析一个<code>App</code>的性能时，<code>Instruments</code>和<code>Measure</code>绝对是我们最好的朋友。我希望每个人都了解<code>Instruments</code>并至少使用过一次。<code>Instruments</code>提供了许多非常有用的工具，来告诉我们：“我们的<code>App</code>使用了多少内存”，“<code>App</code>有多快”，“有没有内存泄漏”等等。</p>
<p>但作为一个软件攻城狮，我们同样需要知道“为什么…？”，“为什么它发生了？”</p>
<p>在我使用<code>Swift</code>时，我曾经看到一些我当时无法理解但很有意思的东西。“为什么这段代码运行这么快？”为了回答这个问题，我必须查看编译出来的汇编代码。这其实并不难，而且非常有用。接下来就来看看是如何做的。</p>
<h2 id="编译Swift代码"><a href="#编译Swift代码" class="headerlink" title="编译Swift代码"></a>编译Swift代码</h2><p>我们只是想编译并分析部分代码，而不是整个工程。为此我们需要做几件事：</p>
<ul>
<li>创建一个新的<code>Swift</code>文件。</li>
<li>创建一个简单的测试函数<code>func test() { ... // 具体代码 }</code>。</li>
<li>将需要编译和分析的代码拷贝到函数体中。</li>
<li>调用函数。</li>
</ul>
<p>这里我们做的是定义一个测试函数，函数体是我们想要检查和分析的代码。当然，我们需要在顶层调用这个函数。</p>
<p>现在我们需要编译这个文件。可以借助于<code>xcrun</code>(Xcode工具)和<code>swiftc</code>(Swift编译器命令行工具)。</p>
<ul>
<li>打开终端并通过<code>cd</code>命令切换到<code>Swift</code>文件所在的目录。</li>
<li>运行命令”<code>xcrun swiftc -Onone inputFile.swift -o resultFileName</code>“。如<strong>xcrun swiftc -Onone Assembly.swift -o result</strong>。</li>
</ul>
<p>这个命令将会编译我们的<code>Swift</code>文件。</p>
<p>我们可以使用<code>xcrun swiftc -help</code>命令来查看<code>xcrun swiftc</code>命令的帮助文档。当前我们最感兴趣的是一些优化选项：</p>
<ul>
<li><strong>-O</strong>：编译时优化</li>
<li><strong>-Onone</strong>：编译时不做任何优化</li>
<li><strong>-Ounchecked</strong>：编译时优化并移除运行时安全检查</li>
</ul>
<p>使用<strong>-O</strong>选项很重要。它就跟编译<code>App</code>时使用<code>Release</code>模式一样。通常用来分析要上传到<code>AppStore</code>上的代码。</p>
<p>作为测试，我们使用<strong>-Onone</strong>模式，因为它生成的汇编代码非常类似于我们的源代码。也可以分别生成两种模式下的代码来做比较。这样我们可以学习下<code>Swift</code>编译器是如何做优化的。</p>
<p>运行：<strong>xcrun swiftc -Onone Assembly.swift -o none</strong></p>
<p>会生成一个可执行文件，可以双击运行它。</p>
<p><img src="https://cdn-images-1.medium.com/max/600/1*LLrYPKt2oVbzU5CcOrixdQ.png" alt="image"></p>
<p>当编译一个<code>Swift</code>文件时，<code>Swift</code>编译器做了以下几件事：</p>
<ul>
<li>创建一个带有<strong>int main(int arg0, int arg1)</strong>函数的控制台应用。这是应用的起点。</li>
<li>创建<strong>_top_level_code</strong>函数。该函数的函数体是<code>Swift</code>文件的顶层可执行代码。在我们的示例中就是调用了<code>test()</code>函数。</li>
</ul>
<h2 id="获取汇编代码"><a href="#获取汇编代码" class="headerlink" title="获取汇编代码"></a>获取汇编代码</h2><p>有许多办法来获取汇编代码。我建议使用<code>Hopper</code>。可以在<a href="http://www.hopperapp.com/download.html" target="_blank" rel="external">这里</a>下载并使用<code>Demo</code>模式。使用<code>Hopper</code>最棒的是它可以显示汇编的伪代码，使用起来比较方便。</p>
<p>让我们来获取汇编代码：</p>
<ul>
<li>打开<code>Hopper</code> &gt; <code>File</code> &gt; <code>Read Executable to Disassemble</code>，选择可执行文件，点击OK</li>
</ul>
<p><img src="https://cdn-images-1.medium.com/max/600/1*CcC_vQGU8CWz1qkshLNDWQ.png" alt="image"></p>
<p><img src="https://cdn-images-1.medium.com/max/600/1*oEF3HyJj3t0pKWUwMyft7w.png" alt="image"></p>
<p><img src="https://cdn-images-1.medium.com/max/600/1*Zv5uaktNpsTZ9f5KE7xqeg.png" alt="image"></p>
<h2 id="Hopper概述"><a href="#Hopper概述" class="headerlink" title="Hopper概述"></a>Hopper概述</h2><p><img src="https://cdn-images-1.medium.com/max/800/1*DiIcK4QP2UQ2glHxwgW4rQ.png" alt="image"></p>
<p><code>Hopper</code>的界面类似于<code>Xcode</code>，左侧是导航面板，中间是编辑面板，右侧是帮助和<code>Inspector</code>面板。</p>
<p><strong>左侧面板</strong>—在这里可以找到所有函数，串标记和字符串，可以点击它们导航到对应的汇编代码。</p>
<p><strong>编辑区</strong>— 显示汇编代码，它类似于<code>Xcode</code>的<code>Swift</code>或其它。我们可以使用箭头来导航。</p>
<h2 id="分析代码"><a href="#分析代码" class="headerlink" title="分析代码"></a>分析代码</h2><p>首先我们需要找到应用入口，在我们的示例中是<code>_main</code>函数。在左侧导航面板中选择它。下面是<code>_main</code>函数的汇编代码。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*uzIzPacXGRgXGa_tVi9wlw.png" alt="image"></p>
<p>汇编代码很难分析，不过<code>Hopper</code>可以生成伪代码。使用快捷键”<code>Alt+Enter</code>“或者”<code>Window</code> &gt; <code>Show Pseudo Code of Procedure</code>“。现在可以看到<code>_main</code>函数的伪代码了。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*Sm4MRfqUCjjf3DCB3udDLA.png" alt="image"></p>
<p>这样好多了!!</p>
<p>前4行是提取<code>_main</code>函数的参数，我们对此不感兴趣。然后调用了<strong>_top_level_code()</strong>，正如前面提到的，这应该就是我们的代码。让我们来看看。关闭伪代码视图，选择<strong>_top_level_code</strong>函数并显示其伪代码。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*ev3n_N8Ai6NCN6tJeFLCVg.png" alt="image"></p>
<p>它只调用了<strong>__TF4none4testFT_T_()_</strong>函数。</p>
<p><code>Swift</code>生成的函数有特定的命名规范。即模块名+函数名+字符数+参数类型+其它东西。<a href="https://mikeash.com/pyblog/friday-qa-2014-08-15-swift-name-mangling.html" target="_blank" rel="external">Mike Ash</a>详细介绍了这一规范。</p>
<p>这里可以看到的是<strong>none</strong>(文件名)， <strong>test</strong>(函数名)。基于这一点，我们可以说它就是<code>test()</code>函数。让我们来检查一下。查找<code>__TF4none4testFT_T_</code>并显示其伪代码。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*e5LfhINe2u_73NBzP8aNNQ.png" alt="image"></p>
<p>它有3个变量，是16进制格式的，转换一下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var_8 = <span class="number">10</span>,</div><div class="line">var_10 = <span class="number">10</span>,</div><div class="line">var_18 = <span class="number">20</span></div></pre></td></tr></table></figure>
<p>这和我们的源代码非常相似，但源代码有一个相加操作，<code>Swift</code>在编译期直接计算出结果了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">10</span></div><div class="line"><span class="keyword">var</span> y = <span class="number">10</span></div><div class="line"><span class="keyword">var</span> <span class="built_in">c</span> = x + y</div></pre></td></tr></table></figure>
<p>现在你已经知道了：编译<code>Swift</code>代码，反汇编及分析汇编代码。深入后，你可以学习并发现许多有趣的东西。作为比较，我们现在使用<strong>-O</strong>模式来编译下代码，以看看<code>Swift</code>编译器是如何优化代码的。</p>
<p>运行<strong>xcrun swiftc -O Assembly.swift -o optimized</strong>命令。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*zZTA8GKacYtlFL5QgPaHtg.png" alt="image"></p>
<p>正如你所见的，在主函数中没有调用任何函数。没有<strong>_top_level_code</strong>。没有调用<code>test()</code>函数。</p>
<p><code>Swift</code>编译器检测到<code>test</code>函数的结果没有被使用，所以将其忽略。而<strong>_top_level_code</strong>也只调用了一个<code>test()</code>函数，所以也被忽略了。结果是我们获得了一个空的主函数。</p>
<p>这篇文章描述了如何使用工具来分析代码。我发现了许多用这些工具优化<code>Swift</code>的方法，这些方法非常有意思。我将在第三部分中与你们分享，敬请期待……</p>
<p><em>注：强烈建议手动操作一下，看看自己得到的结果是什么。</em></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/05/secret-of-swift-performance-part-1/" itemprop="url">
                  Secret of Swift Performance Part 1 - Measure
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-11-05T22:54:01+08:00" content="2015-11-05">
              2015-11-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文由<code>Kostiantyn Koval</code>发表于<code>Medium</code>，地址为<a href="https://medium.com/swift-programming/secret-of-swift-performance-a8ee86060843" target="_blank" rel="external">Secret of Swift Performance ：Part 1 — Measure</a></p>
<p><code>Swift</code>性能方面的讨论已经很多了。如：它真的比<code>C</code>快么？它怎样才能更快？ 去<code>Google</code>一下吧。</p>
<p>但是作为一个<code>App</code>开发者，我们需要知道如何以更简单的方式让我们的<code>App</code>更快。那加速<code>App</code>的银弹又是什么呢？</p>
<h2 id="找出性能瓶颈"><a href="#找出性能瓶颈" class="headerlink" title="找出性能瓶颈"></a>找出性能瓶颈</h2><p>找出<code>App</code>的性能瓶颈是很重要的。按照<code>80/20</code>的原则来说，“大约<code>20%</code>的代码占用了<code>80%</code>的运行速度”，这意味着我们需要找出这<code>20%</code>的代码并优化它，而不用关心剩余的<code>80%</code>。</p>
<p>我写了个简单的带有一个闭包参数的测试函数，它的主要功能是测试闭包代码的运行速度。让我们来分析一下这段代码。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">measure</span><span class="params">(title: String!, call: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</div><div class="line">    <span class="keyword">let</span> startTime = <span class="type">CACurrentMediaTime</span>()</div><div class="line">    call()</div><div class="line">    <span class="keyword">let</span> endTime = <span class="type">CACurrentMediaTime</span>()</div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> title = title &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"\(title): "</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"Time - \(endTime - startTime)"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个测试函数的参数有两个：辅助分析的可选名称(<code>title</code>)和类型为<code>()-&gt;()</code>的闭包函数。相当简单吧。它在调用<code>call()</code>的前后分别获取了当前时间，并打印出<code>call()</code>执行所花费的时间。</p>
<p>让我们来试一下吧。我有一个函数，它的职责是迭代一个数组，并加载图片。我想看看它需要花费多少时间。我们简单地包装一下这个代码块以方便测试函数调用。在这里我们使用了尾随闭包语义，看上去非常棒。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomeWork</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">    measure(<span class="string">"Array"</span>) &#123;</div><div class="line">        <span class="keyword">var</span> ar = [<span class="type">String</span>]()</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>...<span class="number">10000</span> &#123;</div><div class="line">            ar.append(<span class="string">"New elem \(i)"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    measure(<span class="string">"Image"</span>) &#123;</div><div class="line">        <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: <span class="string">"http://lorempixel.com/1920/1920/"</span>)</div><div class="line">        <span class="keyword">let</span> image = <span class="type">UIImage</span>(data:<span class="type">NSData</span>(contentsOfURL:url!)!)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试结果是</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="type">Array</span>: <span class="type">Time</span> — <span class="number">0.0845723639995413</span></div><div class="line"><span class="type">Image</span>: <span class="type">Time</span> — <span class="number">1.77442857499955</span></div></pre></td></tr></table></figure>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/600/1*zCF2DX5VqNOmxgg8qs7z2w.png" alt="image"></p>
<p>现在你知道了哪块代码占用了更多时间，然后就需要去优化它或者将其移到二级线程中处理。</p>
<h2 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h2><p>应该总是在<code>Release</code>模式且<code>Optimization Level</code>设置为<code>[-Os]</code>或<code>[-Ofast]</code>的情况下去测试运行速度。</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*Ea6yWoxe99jG_-kSAVd8eA.png" alt="image"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/10/26/objectivecbridgeable-protocol-for-objectivec-class-and-swift-struct/" itemprop="url">
                  使用_ObjectiveCBridgeable协议实现Objective-C类与Swift结构体的无缝互转
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-10-26T10:33:22+08:00" content="2015-10-26">
              2015-10-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们知道在<code>Swift</code>中，可以在<code>NSArray</code>与<code>Array</code>之间做无缝的转换，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> mobile = [<span class="string">"iPhone"</span>, <span class="string">"Nokia"</span>, <span class="string">"小米Note"</span>]</div><div class="line"><span class="keyword">let</span> mobile1 = (mobile <span class="keyword">as</span> <span class="type">NSArray</span>).objectAtIndex(<span class="number">1</span>)</div><div class="line"><span class="built_in">print</span>(mobile1)</div><div class="line"></div><div class="line"><span class="keyword">let</span> animalArray = <span class="type">NSArray</span>(objects: <span class="string">"lion"</span>, <span class="string">"tiger"</span>, <span class="string">"monkey"</span>)</div><div class="line"><span class="keyword">var</span> animalCount = (animalArray <span class="keyword">as</span> <span class="type">Array</span>).<span class="built_in">count</span></div><div class="line"><span class="built_in">print</span>(animalCount)</div><div class="line"></div><div class="line"><span class="comment">// 输出</span></div><div class="line"><span class="comment">// "Nokia"</span></div><div class="line"><span class="comment">// ["lion", "tiger", "monkey"]</span></div></pre></td></tr></table></figure>
<p>编译器会为了我们完成所有转换，我们只需要拿来即用就行。当然，除了数组外，还有字典(<code>Dictionary</code>)、集合(<code>Set</code>)、字符串(<code>String</code>)也是一样。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>不过仔细一想，会发现，<code>NSArray</code>是类类型，而<code>Array</code>是结构体类型。一个是引用类型，一个是值类型，它们是怎样实现无缝转换的呢？这让我们想到了<code>Cocoa Foundation</code>与<code>Core Foundation</code>之间转换的<code>toll-free bridging</code>技术。那<code>NSArray</code>与<code>Array</code>之间是不是也应该有类似的桥接实现呢？</p>
<h2 id="Objective-C-Bridge"><a href="#Objective-C-Bridge" class="headerlink" title="Objective-C Bridge"></a>Objective-C Bridge</h2><p>我们将鼠标移动到<code>Array</code>上，然后<code>&quot;cmd+鼠标点击&quot;</code>，进入到<code>Swift</code>的声明文件中，在<code>Array</code>的注释中，可以看到下面这段：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// Objective-C Bridge</span></div><div class="line"><span class="comment">/// ==================</span></div><div class="line"><span class="comment">/// The main distinction between Array and the other array types is that it interoperates seamlessly and efficiently with Objective-C.</span></div><div class="line"><span class="comment">/// Array&lt;Element&gt; is considered bridged to Objective-C iff Element is bridged to Objective-C.</span></div><div class="line"></div><div class="line"><span class="comment">// ......</span></div></pre></td></tr></table></figure>
<p>可以看到<code>Array</code>与<code>Objective-C</code>的数组之间确实存在某种桥接技术，我们暂且称之为<code>&quot;Objective-C Bridge&quot;</code>桥接。那这又是如何实现的呢？</p>
<p>我们在当前文件中搜索<code>bridge</code>，会发现有这样一个协议：<code>_ObjectiveCBridgeable</code>。我们先来看看它的声明：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// A Swift Array or Dictionary of types conforming to `_ObjectiveCBridgeable` can be passed to Objective-C as an NSArray or NSDictionary, respectively. The elements of the resulting NSArray or NSDictionary will be the result of calling `_bridgeToObjectiveC` on each element of the source container.</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">_ObjectiveCBridgeable</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即一个<code>Swift</code>数组或字典，如果其元素类型实现了<code>_ObjectiveCBridgeable</code>协议，则该数组或字典可以被转换成<code>Objective-C</code>的数组或字典。对于<code>_ObjectiveCBridgeable</code>协议，我们目前所能得到的文档就只有这些，也看不到它里面声明了什么属性方法。不过，可以看到这个协议是访问控制权限是<code>public</code>，也就意味着可以定义类来实现这个接口。这就好办了，下面就来尝试实现这样一个转换。</p>
<h2 id="Objective-C类与Swift结构体的互转示例"><a href="#Objective-C类与Swift结构体的互转示例" class="headerlink" title="Objective-C类与Swift结构体的互转示例"></a>Objective-C类与Swift结构体的互转示例</h2><p>在此先定义一个<code>Objective-C</code>类，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Mobile.h</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Mobile</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *brand;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *system;</div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)initWithBrand:(<span class="built_in">NSString</span> *)brand system:(<span class="built_in">NSString</span> *)system;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">// Mobole.m</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Mobile</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)initWithBrand:(<span class="built_in">NSString</span> *)brand system:(<span class="built_in">NSString</span> *)system &#123;</div><div class="line"></div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        _brand = brand;</div><div class="line">        _system = system;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>同样，我定义一个<code>Swift</code>结构体，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SwiftMobile</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> brand: <span class="type">String</span></div><div class="line">    <span class="keyword">let</span> system: <span class="type">String</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要想实现<code>Mobile</code>类与<code>SwiftMobile</code>结构体之间的互转，则<code>SwiftMobile</code>结构体需要实现<code>_ObjectiveCBridgeable</code>协议，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SwiftMobile</span>: <span class="title">_ObjectiveCBridgeable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">typealias</span> _ObjectiveCType = <span class="type">Mobile</span></div><div class="line"></div><div class="line">    <span class="comment">// 判断是否能转换成Objective-C对象</span></div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">_isBridgedToObjectiveC</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 获取转换的目标类型</span></div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">_getObjectiveCType</span><span class="params">()</span></span> -&gt; <span class="type">Any</span>.<span class="type">Type</span> &#123;</div><div class="line">        <span class="keyword">return</span> _ObjectiveCType.<span class="keyword">self</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 转换成Objective-C对象</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">_bridgeToObjectiveC</span><span class="params">()</span></span> -&gt; _ObjectiveCType &#123;</div><div class="line">        <span class="keyword">return</span> <span class="type">Mobile</span>(brand: brand, system: system)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 强制将Objective-C对象转换成Swift结构体类型</span></div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">_forceBridgeFromObjectiveC</span><span class="params">(source: _ObjectiveCType, <span class="keyword">inout</span> result: SwiftMobile?)</span></span> &#123;</div><div class="line">        result = <span class="type">SwiftMobile</span>(brand: source.brand, system: source.system)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 有条件地将Objective-C对象转换成Swift结构体类型</span></div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">_conditionallyBridgeFromObjectiveC</span><span class="params">(source: _ObjectiveCType, <span class="keyword">inout</span> result: SwiftMobile?)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line"></div><div class="line">        _forceBridgeFromObjectiveC(source, result: &amp;result)</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到<code>SwiftMobile</code>结构体主要实现了<code>_ObjectiveCBridgeable</code>接口的<code>5</code>个方法，从方法名基本上就能知道每个方法的用途。这里需要注意的是在本例中的<code>_conditionallyBridgeFromObjectiveC</code>只是简单地调用了<code>_forceBridgeFromObjectiveC</code>，如果需要指定条件，则需要更详细的实现。</p>
<p>让我们来测试一下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> mobile = <span class="type">Mobile</span>(brand: <span class="string">"iPhone"</span>, system: <span class="string">"iOS 9.0"</span>)</div><div class="line"></div><div class="line"><span class="keyword">let</span> swiftMobile = mobile <span class="keyword">as</span> <span class="type">SwiftMobile</span></div><div class="line"><span class="built_in">print</span>(<span class="string">"\(swiftMobile.brand): \(swiftMobile.system)"</span>)</div><div class="line"></div><div class="line"><span class="keyword">let</span> swiftMobile2 = <span class="type">SwiftMobile</span>(brand: <span class="string">"Galaxy Note 3 Lite"</span>, system: <span class="string">"Android 5.0"</span>)</div><div class="line"><span class="keyword">let</span> mobile2 = swiftMobile2 <span class="keyword">as</span> <span class="type">Mobile</span></div><div class="line"><span class="built_in">print</span>(<span class="string">"\(mobile2.brand): \(mobile2.system)"</span>)</div><div class="line"></div><div class="line"><span class="comment">// 输出:</span></div><div class="line"><span class="comment">// iPhone: iOS 9.0</span></div><div class="line"><span class="comment">// Galaxy Note 3 Lite: Android 5.0</span></div></pre></td></tr></table></figure>
<p>可以看到只需要使用<code>as</code>，就能实现<code>Mobile</code>类与<code>SwiftMobile</code>结构体的无缝转换。是不是很简单？</p>
<h2 id="集合类型的无缝互换"><a href="#集合类型的无缝互换" class="headerlink" title="集合类型的无缝互换"></a>集合类型的无缝互换</h2><p>回到数组的议题上来。</p>
<p>我们知道<code>NSArray</code>的元素类型必须是类类型的，它不支持存储结构体、数值等类型。因此，<code>Array</code>转换成<code>NSArray</code>的前提是<code>Array</code>的元素类型能被<code>NSArray</code>所接受。如果存储在<code>Array</code>中的元素的类型是结构体，且该结构体实现了<code>_ObjectiveCBridgeable</code>接口，则转换成<code>NSArray</code>时，编译器会自动将所有的元素转换成对应的类类型对象。以上面的<code>SwiftMobile</code>为例，看如下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> sm1 = <span class="type">SwiftMobile</span>(brand: <span class="string">"iPhone"</span>, system: <span class="string">"iOS 9.0"</span>)</div><div class="line"><span class="keyword">let</span> sm2 = <span class="type">SwiftMobile</span>(brand: <span class="string">"Galaxy Note 3"</span>, system: <span class="string">"Android 5.0"</span>)</div><div class="line"><span class="keyword">let</span> sm3 = <span class="type">SwiftMobile</span>(brand: <span class="string">"小米"</span>, system: <span class="string">"Android 4.0"</span>)</div><div class="line"></div><div class="line"><span class="keyword">let</span> mobiles = [sm1, sm2, sm3]</div><div class="line"></div><div class="line"><span class="keyword">let</span> mobileArray = mobiles <span class="keyword">as</span> <span class="type">NSArray</span></div><div class="line"><span class="built_in">print</span>(mobileArray)</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;mobiles.<span class="built_in">count</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"\(mobileArray.objectAtIndex(i).brand): \(mobileArray.objectAtIndex(i).system)"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// (</span></div><div class="line"><span class="comment">//    "&lt;Mobile: 0x100c03f30&gt;",</span></div><div class="line"><span class="comment">//    "&lt;Mobile: 0x100c03940&gt;",</span></div><div class="line"><span class="comment">//    "&lt;Mobile: 0x100c039c0&gt;"</span></div><div class="line"><span class="comment">// )</span></div><div class="line"><span class="comment">// iPhone: iOS 9.0</span></div><div class="line"><span class="comment">// Galaxy Note 3: Android 5.0</span></div><div class="line"><span class="comment">// 小米: Android 4.0</span></div></pre></td></tr></table></figure>
<p>可以看到打印<code>mobileArray</code>数组时，其元素已经转换成了类<code>Mobile</code>的对象。一切都是那么的自然。而如果我们的<code>SwiftMobile</code>并没有实现<code>_ObjectiveCBridgeable</code>接口，则会报编译器错误：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">'[<span class="type">SwiftMobile</span>]' <span class="keyword">is</span> not convertible to '<span class="type">NSArray'</span></div></pre></td></tr></table></figure>
<p>实际上，像<code>Bool</code>，<code>Int</code>， <code>UInt</code>，<code>Float</code>，<code>Double</code>，<code>CGFloat</code>这些数值类型也实现了<code>_ObjectiveCBridgeable</code>接口。我们可以从文档<a href="https://developer.apple.com/library/prerelease/mac/releasenotes/General/APIDiffsMacOSX10_11/Swift/Swift.html" target="_blank" rel="external">OS X v10.11 API Diffs - Swift Changes for Swift</a>中找到一些线索：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Bool</span> : <span class="title">_ObjectiveCBridgeable</span> </span>&#123;</div><div class="line">    <span class="keyword">init</span>(<span class="number">_</span> number: <span class="type">NSNumber</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> : <span class="title">_ObjectiveCBridgeable</span> </span>&#123;</div><div class="line">    <span class="keyword">init</span>(<span class="number">_</span> number: <span class="type">NSNumber</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Float</span> : <span class="title">_ObjectiveCBridgeable</span> </span>&#123;</div><div class="line">    <span class="keyword">init</span>(<span class="number">_</span> number: <span class="type">NSNumber</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ... Double, UInt ...</span></div></pre></td></tr></table></figure>
<p><em>(注意：整型类型只有<code>Int</code>与<code>UInt</code>实现了接口，而其它诸如<code>Int16</code>，<code>Uint32</code>，<code>Int8</code>等则没有）</em></p>
<p>它们的目标类型都是<code>NSNumber</code>类型，如下代码所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">29</span>, <span class="number">40</span>]</div><div class="line"><span class="keyword">let</span> numberArray = (numbers <span class="keyword">as</span> <span class="type">NSArray</span>).objectAtIndex(<span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="built_in">print</span>(numberArray.<span class="keyword">dynamicType</span>)</div><div class="line"></div><div class="line"><span class="comment">// 输出:</span></div><div class="line"><span class="comment">// __NSCFNumber</span></div></pre></td></tr></table></figure>
<p>当然，要想实现<code>Array</code>与<code>NSArray</code>无缝切换，除了元素类型需要支持这种操作外，<code>Array</code>本身也需要能支持<code>Objective-C Bridge</code>，即它也需要实现<code>_ObjectiveCBridgeable</code>接口。在<code>Swift</code>文件的<code>Array</code>声明中并没有找到相关的线索：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Array</span>&lt;<span class="title">Element</span>&gt; : <span class="title">CollectionType</span>, <span class="title">Indexable</span>, <span class="title">SequenceType</span>, <span class="title">MutableCollectionType</span>, <span class="title">MutableIndexable</span>, <span class="title">_DestructorSafeContainer</span></span></div></pre></td></tr></table></figure>
<p>线索依然在<a href="https://developer.apple.com/library/prerelease/mac/releasenotes/General/APIDiffsMacOSX10_11/Swift/Swift.html" target="_blank" rel="external">OS X v10.11 API Diffs - Swift Changes for Swift</a>中，有如下声明：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> : <span class="title">_ObjectiveCBridgeable</span> </span>&#123;</div><div class="line">    <span class="keyword">init</span>(_fromNSArray source: <span class="type">NSArray</span>, noCopy noCopy: <span class="type">Bool</span> = <span class="keyword">default</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此，<code>Array</code>与<code>NSArray</code>相互转换需要两个条件：</p>
<ol>
<li><code>Array</code>自身实现<code>Objective-C Bridge</code>桥接，这个<code>Swift</code>已经帮我们实现了。</li>
<li><code>Array</code>中的元素如果是数值类型或结构类型，必须实现<code>Objective-C Bridge</code>桥接。而如果是类类型或者是<code>@objc protocol</code>类型，则不管这个类型是<code>Objective-C</code>体系中的，还是纯<code>Swift</code>类型(不继承自<code>NSObject</code>)，都可以直接转换。</li>
</ol>
<p>另外，<code>Array</code>只能转换成<code>NSArray</code>，而不能转换成<code>NSArray</code>的子类，如<code>NSMutableArray</code>或<code>NSOrderedArray</code>。如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> objects = [<span class="type">NSObject</span>(), <span class="type">NSObject</span>(), <span class="type">NSObject</span>()]</div><div class="line"><span class="keyword">var</span> objectArray = objects <span class="keyword">as</span> <span class="type">NSMutableArray</span></div><div class="line"></div><div class="line"><span class="comment">// 编译器错误：</span></div><div class="line"><span class="comment">// '[NSObject]' is not convertible to 'NSMutableArray'</span></div></pre></td></tr></table></figure>
<p>当然，反过来却是可以的。这个应该不需要太多的讨论。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在<code>Swift</code>中，我们更多的会使用<code>Array</code>，<code>Dictionary</code>，<code>Set</code>这几个集合类型来存储数据，当然也会遇到需要将它们与<code>Objective-C</code>中对应的集合类型做转换的情况，特别是在混合编程的时候。另外，<code>String</code>也是可能经常切换的一个地方。不过，<code>Apple</code>已经帮我们完成了大部分的工作。如果需要实现自定义的结构体类型与<code>Objective-C</code>类的切换，则可以让结构体实现<code>_ObjectiveCBridgeable</code>接口。</p>
<p>这里还有个小问题，在<code>Objective-C</code>中实际上是有两个类可以用来包装数值类型的值：<code>NSNumber</code>与<code>NSValue</code>。<code>NSNumber</code>我们就不说了，<code>NSValue</code>用于包装诸如<code>CGPoint</code>，<code>CGSize</code>等，不过<code>Swift</code>并没有实现<code>CGPoint</code>类的值到<code>NSValue</code>的转换，所以这个需要我们自己去处理。</p>
<p>在<code>Swift</code>与<code>Objective-C</code>的集合类型相互转换过程中，还涉及到一些性能问题，大家可以看看对应的注释说明。在后续的文章中，会涉及到这一主题。</p>
<p>本文的部分实例代码已上传至<code>github</code>，可以在<a href="https://github.com/southpeak/Swift/tree/master/Basic/ObjectiveCBridgeable" target="_blank" rel="external">这里</a>下载。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://nshint.io/blog/2015/10/07/easy-cast-with-_ObjectiveCBridgeable/?utm_campaign=Swift%2BSandbox&amp;utm_medium=web&amp;utm_source=Swift_Sandbox_11" target="_blank" rel="external">Easy Cast With _ObjectiveCBridgeable</a></li>
<li><a href="https://developer.apple.com/library/prerelease/mac/releasenotes/General/APIDiffsMacOSX10_11/Swift/Swift.html" target="_blank" rel="external">OS X v10.11 API Diffs - Swift Changes for Swift</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/10/20/ios-techset-6/" itemprop="url">
                  iOS知识小集 第六期(2015.10.20)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-10-20T17:45:14+08:00" content="2015-10-20">
              2015-10-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/techset/" itemprop="url" rel="index">
                    <span itemprop="name">知识小集</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>天气有点冷啊，冬天快来了～～然后貌似互联网的冬天也来了啊。阿里缩减校招名额，美团融资失败，大众点评与美团报团，百度腾讯调整招聘，一丝丝的凉意啊～～再然后就是网易邮箱密码泄漏，这又是要搞哪样？不过话说我都不记得自己是不是有网易邮箱啊。额，不知道这个冬天的第一场雪什么时候会来。不管怎样，这个冬天还是窝一窝，等来年春暖花开之时再出去浪了。</p>
<p>这一期的主要内容还是三点：</p>
<ol>
<li><code>Xcode 7</code>中<code>Playground</code>中导入并使用图片</li>
<li><code>Playground</code>中的字面量(<code>Xcode 7.1</code>)</li>
<li><code>CAEmitterLayer</code>实现粒子动画</li>
</ol>
<p>内容不是很多，都是些小东西，主要还是一些知识碎片，这也是知识小集的出发点。所以大家就当是饭后的小点心吧。以后争取勤快一点，至少每个月出个两篇吧（what?不是说过好多次了么？）。</p>
<h2 id="Xcode-7中Playground中导入并使用图片"><a href="#Xcode-7中Playground中导入并使用图片" class="headerlink" title="Xcode 7中Playground中导入并使用图片"></a>Xcode 7中Playground中导入并使用图片</h2><p>在<code>Playground</code>中做测试时，可能需要显示图片，这时我们就需要导入一些图片资源。在<code>Playground</code>中，没有像普通工程那样有个单独的<code>Images.xcassets</code>文件夹来存储图片，不过添加图片也是件非常简单的事情。</p>
<p>如果没有显示<code>project navigator</code>，则可以使用快捷键<code>cmd + 0</code>打开。默认情况下，我们可以在<code>project navigator</code>看到两个<code>group</code>。一个是<code>Source</code>，另一个是<code>Resources</code>。其中<code>Resources</code>这个<code>group</code>就是用来放置资源的(包括图片资源)，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/southpeak/Blog-images/master/playground%20resource%201.png" alt="image"></p>
<p>选中这个<code>group</code>，然后点击左下角的<code>+</code>按钮，在弹出的菜单中选择<code>Add Files to &#39;Resource&#39;</code>，然后选择要添加的文件，点确定。这样就把资源文件添加到我们的<code>Playground</code>了。</p>
<p>添加完成后，我们就可以使用这些资源了。如要显示图片，则可以使用以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let image: UIImage = UIImage(named: &quot;test.png&quot;)!</div></pre></td></tr></table></figure>
<p>在<code>Playground</code>中显示如下：</p>
<p><img src="https://raw.githubusercontent.com/southpeak/Blog-images/master/playground%20resource%203.png" alt="image"></p>
<p>另外，初始情况下，<code>Playground</code>的包里面并没有<code>Resources</code>文件夹，在我们添加资源后，会自动创建这个文件夹。然后我们可以在<code>File Inspector</code>中查看文件夹的具体位置，如下所示：</p>
<p><img src="https://raw.githubusercontent.com/southpeak/Blog-images/master/playground%20resource%202.png" alt="image"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://developer.apple.com/library/ios/recipes/Playground_Help/Chapters/AddResource.html#//apple_ref/doc/uid/TP40015166-CH29-SW1" target="_blank" rel="external">Playground Help - Adding Resources to a Playground</a></li>
<li><a href="http://stackoverflow.com/questions/24069479/swift-playgrounds-with-uiimage" target="_blank" rel="external">Swift playgrounds with UIImage</a></li>
<li><a href="http://natashatherobot.com/xcode-6-add-image-assets-to-playground/" target="_blank" rel="external">XCode 6: How To Add Image Assets To Your Playground</a></li>
</ol>
<h2 id="Playground中的字面量-Xcode-7-1"><a href="#Playground中的字面量-Xcode-7-1" class="headerlink" title="Playground中的字面量(Xcode 7.1)"></a>Playground中的字面量(Xcode 7.1)</h2><p><code>Xcode 7.1</code>新增了一项特性，让我们可以在<code>playground</code>代码中嵌入文件、图片和颜色的字面量。</p>
<p>以图片字面量为例，以往如果需要在<code>playground</code>使用图片资源，我们总是需要通过文件名来指定图片，如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let image = UIImage(named: &quot;swift.png&quot;)</div></pre></td></tr></table></figure>
<p>其效果如下：</p>
<p><img src="https://raw.githubusercontent.com/southpeak/Blog-images/master/Literals%20in%20playerground%20-%20image%20literal%201.png" alt="image"></p>
<p>而在<code>Xcode 7.1</code>中，我们无需在编辑器中键入<code>&quot;swift.png&quot;</code>，而只需将图片从<code>Finder</code>或是资源中拖到我们的代码里面，就可以直接生成一个<code>UIImage</code>对象，如下所示：</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Literals%20in%20playerground%20-%20image%20literal%202.png?raw=true" alt="image"></p>
<p>可以看到，代码中<code>=</code>右侧的那个类似于小图标的东东就是一个图片字面量。是不是很酷来着？</p>
<p>与图片字面量类似，我们同样可以添加颜色字面量和文件字面量，添加方法可以参考<a href="https://developer.apple.com/library/prerelease/ios/recipes/Playground_Help/Chapters/AddColorLiteral.html#//apple_ref/doc/uid/TP40015166-CH50-SW1" target="_blank" rel="external">Adding Color Literals</a>和<a href="https://developer.apple.com/library/prerelease/ios/recipes/Playground_Help/Chapters/AddFileLiteral.html#//apple_ref/doc/uid/TP40015166-CH51-SW1" target="_blank" rel="external">Adding File Literals</a>。</p>
<p>当然，除了看上去很酷之外，这也让我们在<code>playground</code>中写代码时能够更快地去编辑这些资源。我们可以通过颜色选择器来插入我们想要的颜色，可以直接从<code>Finder</code>中将文件或图片拖到我们的代码中，而不再需要手动输入颜色值或文件名等。而如果我们想替换资源，只需要双击这些字面量就可以轻松地选择其它的资源。</p>
<h3 id="字面量的表示"><a href="#字面量的表示" class="headerlink" title="字面量的表示"></a>字面量的表示</h3><p>这里有一个问题，在代码中，这些字面量是如何表示的呢？</p>
<p>我们还是以图片字面量为例。选中一个图片字面量，<code>cmd+C</code>一下，然后找个文本编辑器，再<code>cmd+V</code>一下，发现拷贝出来的是如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[#Image(imageLiteral: &quot;swift.png&quot;)#]</div></pre></td></tr></table></figure>
<p>类似于一个构造器。我们再到<code>UIImage</code>中找找，可以看到<code>UIImage</code>有一个扩展，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">extension UIImage : _ImageLiteralConvertible &#123;</div><div class="line">    required public convenience init(imageLiteral name: String)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个扩展让<code>UIImage</code>类实现了<code>_ImageLiteralConvertible</code>协议，看这命名，貌似是一个私有的协议。我们来看看它的字义，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/// Conforming types can be initialized with image literals (e.g.</div><div class="line">/// `[#Image(imageLiteral: &quot;hi.png&quot;)#]`).</div><div class="line">public protocol _ImageLiteralConvertible &#123;</div><div class="line">    public init(imageLiteral: String)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，实现这个协议的类型就可以使用图片字面量来初始化，即我们上面所看到。当然，我们没办法看到源码是怎么实现的，只能到此为止。</p>
<p>实际上，这些字面量会被转换成平台指定的类型，在官方的<code>swift blog</code>中列出了一个清单，如下所示：</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Literals%20in%20playerground%20-%20image%20literal%203.png?raw=true" alt="image"></p>
<p>还有件看起来很酷但似乎并不太实用的事是：这些字面量不但可以用在<code>playground</code>中，而且还有可用在工程代码中。不过之所有不太实用，是因为在工程代码中只能以纯文本的形式来展现，而不是像在<code>playground</code>中那样能直观的显示。这种纯文本形式即我们上面拷贝出来的信息，我们再贴一次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[#Image(imageLiteral: &quot;swift.png&quot;)#]</div></pre></td></tr></table></figure>
<p>我们码段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let image = [#Image(imageLiteral: &quot;swift.png&quot;)#]</div><div class="line"></div><div class="line">let imageView = UIImageView(image: image)</div><div class="line">imageView.frame = CGRect(x: 100, y: 100, width: 100, height: 100)</div><div class="line"></div><div class="line">self.view.addSubview(imageView)</div></pre></td></tr></table></figure>
<p>其效果如下所示：</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Literals%20in%20playerground%20-%20image%20literal%204.png?raw=true" alt="image"></p>
<p>从代码实践的角度来看，这种写法看上去并不是那么美啊。不过由于这种写法是与平台相关的，所以如果工程需要同时支持<code>OSX</code>、<code>iOS</code>和<code>tvOS</code>，还是可以考虑用一下的。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>总之，在<code>playground</code>中使用图片、颜色、文件字面量还是一件很酷的事，它大大提高了我们使用资源的效率，同时也更加直观，用起来还是满爽的。</p>
<p>这里附上官方的实例:<a href="https://developer.apple.com/swift/blog/downloads/Literals.zip" target="_blank" rel="external">Literals.playground</a></p>
<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://developer.apple.com/swift/blog/" target="_blank" rel="external">Literals in Playgrounds</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/recipes/Playground_Help/Chapters/AddImageLiteral.html#//apple_ref/doc/uid/TP40015166-CH49-SW1" target="_blank" rel="external">Adding Image Literals</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/recipes/Playground_Help/Chapters/AddColorLiteral.html#//apple_ref/doc/uid/TP40015166-CH50-SW1" target="_blank" rel="external">Adding Color Literals</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/recipes/Playground_Help/Chapters/AddFileLiteral.html#//apple_ref/doc/uid/TP40015166-CH51-SW1" target="_blank" rel="external">Adding File Literals</a></li>
</ol>
<h2 id="CAEmitterLayer实现粒子动画"><a href="#CAEmitterLayer实现粒子动画" class="headerlink" title="CAEmitterLayer实现粒子动画"></a>CAEmitterLayer实现粒子动画</h2><p>前段时间<a href="http://weibo.com/u/1956547962" target="_blank" rel="external">@MartinRGB</a>做了个带粒子效果的删除单元格动画，今天问他具体的实现方式，然后他把参考的原始工程发我看了一下。于是就找到了这个：<a href="https://github.com/icanzilb/UIEffectDesignerView" target="_blank" rel="external">UIEffectDesignerView</a>。是<code>github</code>上的一个粒子动画的开源代码。其效果如下图所示：</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/CAEmitterLayer%201.jpg?raw=true" alt="image"></p>
<p>这个动画的实现基于<code>CAEmitterLayer</code>类，它继承自<code>CALayer</code>。这个类是<code>Core Animation</code>提供的用于实现一个粒子发射器系统的类。这个类主要提供了一些属性来设置粒子系统的几何特性。我们可以如下处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let emitter = CAEmitterLayer()</div><div class="line"></div><div class="line">// setup the emitter metrics</div><div class="line">emitter.emitterPosition = CGPoint(x: self.bounds.size.width / 2, y: self.bounds.height / 2)</div><div class="line">emitter.emitterSize = self.bounds.size</div><div class="line"></div><div class="line">// setup the emitter type and mode</div><div class="line">let kEmitterModes = [ kCAEmitterLayerUnordered, kCAEmitterLayerAdditive, kCAEmitterLayerOldestLast, kCAEmitterLayerOldestFirst ]</div><div class="line">emitter.emitterMode = kEmitterModes[ Int(valueFromEffect(&quot;emitterMode&quot;)) ]</div></pre></td></tr></table></figure>
<p><em>需要注意的就是粒子系统会被绘制到层的背影颜色及边框之上。</em></p>
<p>当然，要想发射粒子，就需要有粒子源。一个粒子源定义了发射的粒子的方向及其它属性。在<code>Core Animation</code>中，使用<code>CAEmitterCell</code>对象来表示一个粒子源。<code>CAEmitterCell</code>定义了大量的属性来设置一个粒子源的特性，如粒子的显示特性(<code>color</code>, <code>scale</code>, <code>style</code>)、运动特性(如<code>spin</code>, <code>emissionLatitude</code>)、时间特性(如<code>lifetime</code>, <code>birthRate</code>, <code>velocity</code>)等。我们可以手动来设置这些值，也可以从文件中获取。在<code>UIEffectDesignerView</code>工程中，粒子发射器的信息是放在一个<code>ped</code>文件中，这个文件以<code>JSON</code>格式存储了粒子信息，如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    "latitude": 0, </div><div class="line">    "alphaSpeed": 0, </div><div class="line">    "scaleSpeed": 0, </div><div class="line">    "blueRange": 0.33, </div><div class="line">    "width": 120, </div><div class="line">    "texture": "....", </div><div class="line">    "spinRange": 0, </div><div class="line">    "lifetime": 5, </div><div class="line">    "greenSpeed": 0, </div><div class="line">    "aux3": null, </div><div class="line">    "emitterType": 0, </div><div class="line">    "version": 0.1, </div><div class="line">    "zAcceleration": 0, </div><div class="line">    "velocity": 100, </div><div class="line">    "velocityRange": 150, </div><div class="line">    ...</div><div class="line">    "y": 390, </div><div class="line">    "aux2": null</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们从文件中把粒子信息读取出来放到一个字典中，然后再将值赋给一个<code>CAEmitterCell</code>对象，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// create new emitter cell</div><div class="line">let emitterCell: CAEmitterCell = CAEmitterCell()</div><div class="line"></div><div class="line">let effect: [String: AnyObject] = loadFile(filename)</div><div class="line"></div><div class="line">...</div><div class="line">emitterCell.birthRate           = effect(&quot;birthRate&quot;)</div><div class="line">emitterCell.lifetime            = effect(&quot;lifetime&quot;)</div><div class="line">emitterCell.lifetimeRange       = effect(&quot;lifetimeRange&quot;)</div><div class="line">emitterCell.velocity            = effect(&quot;velocity&quot;)</div><div class="line">emitterCell.velocityRange       = effect(&quot;velocityRange&quot;)</div><div class="line">...</div></pre></td></tr></table></figure>
<p>之后，我们便可以把这个粒子源添加到粒子系统中，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">emitter.emitterCells = [ emitterCell ]</div></pre></td></tr></table></figure>
<p>这样就可以发射粒子了。</p>
<p>当然对于一个粒子的特性，除了受粒子源设置的属性影响外，同样也还受粒子系统的一些属性的影响，如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">emitter.scale = 0.5</div></pre></td></tr></table></figure>
<p>其效果如下图所示：</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/CAEmitterLayer%202.jpg?raw=true" alt="image"></p>
<p>另外，一个粒子源也可以包含一个子粒子源的数组，每个子源都可以作为一个独立的发射源。</p>
<h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://github.com/icanzilb/UIEffectDesignerView" target="_blank" rel="external">UIEffectDesignerView</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/GraphicsImaging/Reference/CAEmitterLayer_class/" target="_blank" rel="external">CAEmitterLayer Class Reference</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/GraphicsImaging/Reference/CAEmitterCell_class/index.html" target="_blank" rel="external">CAEmitterCell Class Reference</a></li>
</ol>
<h2 id="零碎"><a href="#零碎" class="headerlink" title="零碎"></a>零碎</h2><h3 id="C语言的int类型在Swift中的对应类型"><a href="#C语言的int类型在Swift中的对应类型" class="headerlink" title="C语言的int类型在Swift中的对应类型"></a>C语言的int类型在Swift中的对应类型</h3><p>一言以蔽之，<code>C</code>语言的<code>int</code>类型在<code>Swift</code>中的对应类型是<code>CInt</code>，它是<code>Int32</code>的一个别名。今天一哥们用<code>Swift</code>写了一段测试代码来调用<code>C</code>方法，方法中有个参数是<code>int</code>类型，类似于如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let str = &quot;Hello, World!&quot;</div><div class="line">let a = str.characters.count</div><div class="line">Test.test(a)		// test方法接受一个int类型的参数</div><div class="line"></div><div class="line">// 编译器错误：Cannot convert value of type &apos;Distance&apos;(aka &apos;Int&apos;) to expected argument type Int32</div></pre></td></tr></table></figure>
<p>可以看到我们需要传入一个<code>Int32</code>类型的参数。</p>
<p>之所以使用<code>Int32</code>，是因为在<code>C</code>语言中，<code>int</code>是<code>4</code>个字节，而<code>Swift</code>中的<code>Int</code>则依赖于平台，可能是<code>4</code>个字节，也可能是<code>8</code>个字节。嗯，这个问题是凑数的，点到为止吧。</p>
<h3 id="Swift中获取类型的大小"><a href="#Swift中获取类型的大小" class="headerlink" title="Swift中获取类型的大小"></a>Swift中获取类型的大小</h3><p>在<code>C</code>语言中，如果我们想获取一个变量或数据类型的大小，则可以使用<code>sizeof</code>函数。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int a = 10;</div><div class="line">printf(&quot;%lu, %lu&quot;, sizeof(int), sizeof(a));</div><div class="line"></div><div class="line">// 输出：4,4</div></pre></td></tr></table></figure>
<p>在<code>Swift</code>中，也提供了相应的函数。我们可以使用<code>sizeof</code>来获取给定类型的大小，使用<code>sizeofValue</code>来获取给定值的类型的大小。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sizeof(Int)				// 8</div><div class="line"></div><div class="line">let c: Int = 10</div><div class="line">sizeofValue(c)			// 8</div></pre></td></tr></table></figure>
<p>不过，与<code>C</code>语言中的<code>sizeof</code>不同的是，<code>Siwft</code>中的<code>sizeof</code>与<code>sizeofValue</code>不包含任何内存对齐的填充部分。如<code>timeval</code>结构体，在<code>C</code>语言中的大小是<code>16</code>，而在<code>Swift</code>中，则是<code>12</code>，并未包含<code>4</code>个填充字节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sizeof(timeval)			// 12</div></pre></td></tr></table></figure>
<p>不过，<code>Swift</code>提供了两个对应的函数，来计算经过内存对齐的类型的大小，即<code>strideof</code>秘<code>strideofValue</code>，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let time = timeval(tv_sec: 10, tv_usec: 10)</div><div class="line"></div><div class="line">strideof(timeval)		// 16</div><div class="line">strideofValue(time)		// 16</div></pre></td></tr></table></figure>
<h4 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html" target="_blank" rel="external">Using Swift with Cocoa and Objective-C (Swift 2)</a></li>
</ol>
<h3 id="问题：纯Playground中使用Objective-C-C代码"><a href="#问题：纯Playground中使用Objective-C-C代码" class="headerlink" title="问题：纯Playground中使用Objective-C/C代码"></a>问题：纯Playground中使用Objective-C/C代码</h3><p>今天想在纯<code>Playground</code>中测试一下<code>CC_MD5</code>方法，发现没招。因为<code>CC_MD5</code>实际上是一个<code>C</code>方法，需要导入<code>&lt;CommonCrypto/CommonCrypto.h&gt;</code>头文件。这就涉及到<code>Swift</code>与<code>Objective-C</code>混编，需要创建一个桥接文件。但是纯<code>Playground</code>貌似并不支持这么做（搜了一下没搜着解决方法）。于是只能采取曲线救国策略，建立一个基于<code>Swift</code>的工程，在这里面创建桥接文件，导入头文件。然后在工程中创建一个<code>Playground</code>来做测试了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/09/26/ios-techset-5/" itemprop="url">
                  iOS知识小集 第五期(2015.09.26)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-09-26T23:42:33+08:00" content="2015-09-26">
              2015-09-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/techset/" itemprop="url" rel="index">
                    <span itemprop="name">知识小集</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>忽悠一个月又过去了，今年的9月还是挺精彩的。苹果发布<code>iPhone 6s</code>，<code>iPad Pro</code>，<code>iOS 9</code>，让我们又有很多活可做了；然后是<code>XCodeGoast</code>搅得圈内沸沸扬扬的，居然还惊动了<code>CCAV</code>；再然后苏宁的小伙伴们给大家送上了一份中秋礼物，虽然是老代码，但这是要搞哪样啊？不过，正是这些事情为我等屌丝的生活平添了许多的乐趣，还是挺酸爽的嘛。</p>
<p>嗯，回到正题上来。这期的知识小集主要是<code>Swift</code>开发的一些内容，主要的内容有三点：</p>
<ol>
<li><code>Swift</code>中随机数的使用</li>
<li><code>Swift</code>中<code>String</code>与<code>CChar</code>数组的转换</li>
<li><code>Swift</code>中<code>Selector</code>方法的访问权限控制问题</li>
</ol>
<p>相对<code>Objective-C</code>来说，个人觉得<code>Swift</code>写起来大多数时候还是挺爽的，简洁多了，以后有事没事还是多撸撸<code>Swift</code>。</p>
<h2 id="Swift中随机数的使用"><a href="#Swift中随机数的使用" class="headerlink" title="Swift中随机数的使用"></a>Swift中随机数的使用</h2><p>在我们开发的过程中，时不时地需要产生一些随机数。这里我们总结一下<code>Swift</code>中常用的一些随机数生成函数。这里我们将在<code>Playground</code>中来做些示例演示。</p>
<h3 id="整型随机数"><a href="#整型随机数" class="headerlink" title="整型随机数"></a>整型随机数</h3><p>如果我们想要一个整型的随机数，则可以考虑用<code>arc4random</code>系列函数。我们可以通过<code>man arc4random</code>命令来看一下这个函数的定义：</p>
<blockquote>
<p>The arc4random() function uses the key stream generator employed by the arc4 cipher, which uses 8*8 8 bit S-Boxes.  The S-Boxes can be inabout (2^1700) states.  The arc4random() function returns pseudo-random numbers in the range of 0 to (2^32)-1, and therefore has twice the range of rand(3) and random(3).</p>
</blockquote>
<p><code>arc4random</code>使用了<code>arc4密码</code>加密的<code>key stream</code>生成器(请脑补)，产生一个<code>[0, 2^32)</code>区间的随机数(注意是左闭右开区间)。这个函数的返回类型是<code>UInt32</code>。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arc4random()				// 2,919,646,954</div></pre></td></tr></table></figure>
<p>如果我们想生成一个指定范围内的整型随机数，则可以使用<code>arc4random() % upper_bound</code>的方式，其中<code>upper_bound</code>指定的是上边界，如下处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arc4random() % 10			// 8</div></pre></td></tr></table></figure>
<p>不过使用这种方法，在<code>upper_bound</code>不是2的幂次方时，会产生一个所谓<a href="http://eternallyconfuzzled.com/arts/jsw_art_rand.aspx" target="_blank" rel="external">Modulo bias(模偏差)</a>的问题。</p>
<p>我们在控制台中通过<code>man arc4random</code>命令，可以查看<code>arc4random</code>的文档，有这么一条：</p>
<blockquote>
<p>arc4random_uniform() will return a uniformly distributed random number less than upper_bound.  arc4random_uniform() is recommended over constructions like ‘’arc4random() % upper_bound’’ as it avoids “modulo bias” when the upper bound is not a power of two.</p>
</blockquote>
<p>因此可以使用<code>arc4random_uniform</code>，它接受一个<code>UInt32</code>类型的参数，指定随机数区间的上边界<code>upper_bound</code>，该函数生成的随机数范围是<code>[0, upper_bound)</code>，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arc4random_uniform(10)		// 6</div></pre></td></tr></table></figure>
<p>而如果想指定区间的最小值（如随机数区间在<code>[5, 100)</code>），则可以如下处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let max: UInt32 = 100</div><div class="line">let min: UInt32 = 5</div><div class="line">arc4random_uniform(max - min) + min			// 82</div></pre></td></tr></table></figure>
<p>当然，在<code>Swift</code>中也可以使用传统的<code>C</code>函数<code>rand</code>与<code>random</code>。不过这两个函数有如下几个缺点：</p>
<ol>
<li>这两个函数都需要初始种子，通常是以当前时间来确定。</li>
<li>这两个函数的上限在<code>RAND_MAX=0X7fffffff(2147483647)</code>，是<code>arc4random</code>的一半。</li>
<li><code>rand</code>函数以有规律的低位循环方式实现，更容易预测</li>
</ol>
<p>我们以<code>rand</code>为例，看看其使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">srand(UInt32(time(nil)))            // 种子,random对应的是srandom</div><div class="line">rand()								// 1,314,695,483</div><div class="line">rand() % 10							// 8</div></pre></td></tr></table></figure>
<h3 id="64位整型随机数"><a href="#64位整型随机数" class="headerlink" title="64位整型随机数"></a>64位整型随机数</h3><p>在大部分应用中，上面讲到的几个函数已经足够满足我们获取整型随机数的需求了。不过我们看看它们的函数声明，可以发现这些函数主要是针对<code>32</code>位整型来操作的。如果我们需要生成一个<code>64</code>位的整型随机数呢？毕竟现在的新机器都是支持<code>64</code>位的了。</p>
<p>目前貌似没有现成的函数来生成<code>64</code>位的随机数，不过<code>jstn</code>在<code>stackoverflow</code>上为我们分享了他的方法。我们一起来看看。</p>
<p>他首先定义了一个泛型函数，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func arc4random &lt;T: IntegerLiteralConvertible&gt; (type: T.Type) -&gt; T &#123;</div><div class="line">    var r: T = 0</div><div class="line">    arc4random_buf(&amp;r, UInt(sizeof(T)))</div><div class="line">    return r</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数中使用了<code>arc4random_buf</code>来生成随机数。让我们通过<code>man arc4random_buf</code>来看看这个函数的定义：</p>
<blockquote>
<p>arc4random_buf() function fills the region buf of length nbytes with ARC4-derived random data.</p>
</blockquote>
<p>这个函数使用<code>ARC4</code>加密的随机数来填充该函数第二个参数指定的长度的缓存区域。因此，如果我们传入的是<code>sizeof(UInt64)</code>，该函数便会生成一个随机数来填充<code>8</code>个字节的区域，并返回给<code>r</code>。那么<code>64</code>位的随机数生成方法便可以如下实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">extension UInt64 &#123;</div><div class="line">    static func random(lower: UInt64 = min, upper: UInt64 = max) -&gt; UInt64 &#123;</div><div class="line">        var m: UInt64</div><div class="line">        let u = upper - lower</div><div class="line">        var r = arc4random(UInt64)</div><div class="line"></div><div class="line">        if u &gt; UInt64(Int64.max) &#123;</div><div class="line">            m = 1 + ~u</div><div class="line">        &#125; else &#123;</div><div class="line">            m = ((max - (u * 2)) + 1) % u</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        while r &lt; m &#123;</div><div class="line">            r = arc4random(UInt64)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return (r % u) + lower</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们来试用一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UInt64.random()					// 4758246381445086013</div></pre></td></tr></table></figure>
<p>当然<code>jstn</code>还提供了<code>Int64</code>，<code>UInt32</code>，<code>Int32</code>的实现，大家可以脑补一下。</p>
<h3 id="浮点型随机数"><a href="#浮点型随机数" class="headerlink" title="浮点型随机数"></a>浮点型随机数</h3><p>如果需要一个浮点值的随机数，则可以使用<code>drand48</code>函数，这个函数产生一个<code>[0.0, 1.0]</code>区间中的浮点数。这个函数的返回值是<code>Double</code>类型。其使用如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">srand48(Int(time(nil)))</div><div class="line">drand48()						// 0.396464773760275</div></pre></td></tr></table></figure>
<p>记住这个函数是需要先调用<code>srand48</code>生成一个种子的初始值。</p>
<h3 id="一个小示例"><a href="#一个小示例" class="headerlink" title="一个小示例"></a>一个小示例</h3><p>最近写了一个随机键盘，需要对<code>0-9</code>这几个数字做个随机排序，正好用上了上面的<code>arc4random</code>函数，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let arr = [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;]</div><div class="line"></div><div class="line">let numbers = arr.sort &#123; (_, _) -&gt; Bool in</div><div class="line">    arc4random() &lt; arc4random()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在闭包中，随机生成两个数，比较它们之间的大小，来确定数组的排序规则。还是挺简单的。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>其实如果翻看一下<code>Swift</code>中关于<code>C</code>函数的<code>API</code>，发现还有许多跟随机数相关的函数，如<code>arc4random_addrandom</code>，<code>erand48</code>等。上面的只是我们经常用到的一些函数，这几个函数基本上够用了。当然，不同场景有不同的需求，我们需要根据实际的需求来选择合适的函数。</p>
<p>以上的代码已上传到<code>github</code>，地址是<a href="https://github.com/southpeak/Swift/tree/master/Basic/Random.playground" target="_blank" rel="external">Random.playground</a>有需要的可以参考一下。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://nshipster.com/random/" target="_blank" rel="external">rand(3) / random(3) / arc4random(3) / et al.</a></li>
<li><a href="https://medium.com/@skreutzb/random-swift-102c23cd1755" target="_blank" rel="external">Random Swift</a></li>
<li><a href="http://stackoverflow.com/questions/24007129/how-does-one-generate-a-random-number-in-apples-swift-language" target="_blank" rel="external">How does one generate a random number in Apple’s Swift language?</a></li>
</ol>
<h2 id="Swift中String与CChar数组的转换"><a href="#Swift中String与CChar数组的转换" class="headerlink" title="Swift中String与CChar数组的转换"></a>Swift中String与CChar数组的转换</h2><p>在现阶段<code>Swift</code>的编码中，我们还是有很多场景需要调用一些<code>C</code>函数。在<code>Swift</code>与<code>C</code>的混编中，经常遇到的一个问题就是需要在两者中互相转换字符串。在<code>C</code>语言中，字符串通常是用一个<code>char数组</code>来表示，在<code>Swift</code>中，是用<code>CChar数组</code>来表示。从<code>CChar</code>的定义可以看到，其实际上是一个<code>Int8</code>类型，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/// The C &apos;char&apos; type.</div><div class="line">///</div><div class="line">/// This will be the same as either `CSignedChar` (in the common</div><div class="line">/// case) or `CUnsignedChar`, depending on the platform.</div><div class="line">public typealias CChar = Int8</div></pre></td></tr></table></figure>
<p>如果我们想将一个<code>String</code>转换成一个<code>CChar数组</code>，则可以使用<code>String</code>的<code>cStringUsingEncoding</code>方法，它是<code>String</code>扩展中的一个方法，其声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/// Returns a representation of the `String` as a C string</div><div class="line">/// using a given encoding.</div><div class="line">@warn_unused_result</div><div class="line">public func cStringUsingEncoding(encoding: NSStringEncoding) -&gt; [CChar]?</div></pre></td></tr></table></figure>
<p>参数指定的是编码格式，我们一般指定为<code>NSUTF8StringEncoding</code>，因此下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let str: String = &quot;abc1个&quot;</div><div class="line"></div><div class="line">// String转换为CChar数组</div><div class="line">let charArray: [CChar] = str.cStringUsingEncoding(NSUTF8StringEncoding)!</div></pre></td></tr></table></figure>
<p>其输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[97, 98, 99, 49, -28, -72, -86, 0]</div></pre></td></tr></table></figure>
<p>可以看到<code>&quot;个&quot;</code>字由三个字节表示，这是因为<code>Swift</code>的字符串是<code>Unicode</code>编码格式，一个字符可能由1个或多个字节组成。另外需要注意的是<code>CChar</code>数组的最后一个元素是<code>0</code>，它表示的是一个字符串结束标志符<code>\n</code>。</p>
<p>我们知道，在<code>C</code>语言中，一个数组还可以使用指针来表示，所以字符串也可以用<code>char *</code>来表示。在<code>Swift中</code>，指针是使用<code>UnsafePointer</code>或<code>UnsafeMutablePointer</code>来包装的，因此，<code>char指针</code>可以表示为<code>UnsafePointer&lt;CChar&gt;</code>，不过它与<code>[CChar]</code>是两个不同的类型，所以以下代码会报编译器错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// Error: Cannot convert value of type &apos;[CChar]&apos; to specified type &apos;UnsafePointer&lt;CChar&gt;&apos;</div><div class="line">let charArray2: UnsafePointer&lt;CChar&gt; = str.cStringUsingEncoding(NSUTF8StringEncoding)!</div></pre></td></tr></table></figure>
<p>不过有意思的是我们可以直接将<code>String</code>字符串传递给带有<code>UnsafePointer&lt;CChar&gt;</code>参数的函数或方法，如以下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func length(s: UnsafePointer&lt;CChar&gt;) &#123;</div><div class="line">    print(strlen(s))</div><div class="line">&#125;</div><div class="line"></div><div class="line">length(str)</div><div class="line"></div><div class="line">// 输出：7\n</div></pre></td></tr></table></figure>
<p>而<code>String</code>字符串却不能传递给带有<code>[CChar]</code>参数的函数或方法，如以下代码会报错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">func length2(s: [CChar]) &#123;</div><div class="line">    print(strlen(s))</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Error: Cannot convert value of type &apos;String&apos; to expected argument type &apos;[CChar]&apos;</div><div class="line">length2(str)</div></pre></td></tr></table></figure>
<p>实际上，在<code>C</code>语言中，我们在使用数组参数时，很少以数组的形式来定义参数，则大多是通过指针方式来定义数组参数。</p>
<p>如果想从<code>[CChar]</code>数组中获取一上<code>String</code>字符串，则可以使用<code>String</code>的<code>fromCString</code>方法，其声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/// Creates a new `String` by copying the nul-terminated UTF-8 data</div><div class="line">/// referenced by a `CString`.</div><div class="line">///</div><div class="line">/// Returns `nil` if the `CString` is `NULL` or if it contains ill-formed</div><div class="line">/// UTF-8 code unit sequences.</div><div class="line">@warn_unused_result</div><div class="line">public static func fromCString(cs: UnsafePointer&lt;CChar&gt;) -&gt; String?</div></pre></td></tr></table></figure>
<p>从注释可以看到，它会将<code>UTF-8</code>数据拷贝以新字符串中。如下示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let chars: [CChar] = [99, 100, 101, 0]</div><div class="line">let str2: String = String.fromCString(chars)!</div><div class="line"></div><div class="line">// 输出：cde</div></pre></td></tr></table></figure>
<p>这里需要注意的一个问题是，<code>CChar</code>数组必须以<code>0</code>结束，否则会有不可预料的结果。在我的<code>Playground</code>示例代码中，如果没有<code>0</code>，报了以下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Execution was interrupted. reason: EXC_BAD_INSTRUCTION</div></pre></td></tr></table></figure>
<p>还有可能出现的情况是<code>CChar</code>数组的存储区域正好覆盖了之前某一对象的区域，这一对象有一个可以表示字符串结尾的标识位，则这时候，<code>str2</code>输出的可能是<code>&quot;cde1一&quot;</code>。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>在<code>Swift</code>中，<code>String</code>是由独立编码的<code>Unicode</code>字符组成的，即<code>Character</code>。一个<code>Character</code>可能包括一个或多个字节。所以将<code>String</code>字符串转换成<code>C</code>语言的<code>char *</code>时，数组元素的个数与<code>String</code>字符的个数不一定相同(即在<code>Swift</code>中，与<code>str.characters.count</code>计算出来的值不一定相等)。这一点需要注意。另外还需要注意的就是将<code>CChar</code>数组转换为<code>String</code>时，数组最后一个元素应当为字符串结束标志符，即<code>0</code>。</p>
<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://forums.developer.apple.com/thread/9386" target="_blank" rel="external">UTF8String</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Reference/Swift_String_Structure/#//apple_ref/swift/structcm/String/s:ZFSS11fromCStringFMSSFGVSs13UnsafePointerVSs4Int8_GSqSS_" target="_blank" rel="external">String Structure Reference</a></li>
<li><a href="http://wiki.jikexueyuan.com/project/swift/chapter2/03_Strings_and_Characters.html#counting_characters" target="_blank" rel="external">The Swift Programming Language中文版</a></li>
</ol>
<h2 id="Swift中Selector方法的访问权限控制问题"><a href="#Swift中Selector方法的访问权限控制问题" class="headerlink" title="Swift中Selector方法的访问权限控制问题"></a>Swift中Selector方法的访问权限控制问题</h2><p>今天用<code>Swift</code>写了个视图，在视图上加个手势，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">panGestureRecognizer = UIPanGestureRecognizer(target: self, action: &quot;beginDragged:&quot;)</div><div class="line">addGestureRecognizer(panGestureRecognizer)</div></pre></td></tr></table></figure>
<p>运行了下程序，然后崩溃了。崩溃日志如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[**.SwipeCardView beginDragged:]: unrecognized selector sent to instance 0x125e5bc10</div></pre></td></tr></table></figure>
<p>而我已经在<code>SwipeCardView</code>类中定义了<code>beginDragged:</code>方法，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">private func beginDragged(gestureRecognizer: UIPanGestureRecognizer) &#123;</div><div class="line">	// ....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于我并不想将<code>beginDragged:</code>方法暴露出去，所以将其定义为一个<code>private</code>方法。方法的定义一切正常，手势的<code>Selector</code>方法也设置正常，却报了未找到方法的异常。那问题可能就应该在访问权限问题上了。</p>
<p>我们知道<code>Selector</code>是<code>Objective-C</code>的产物，它用于在运行时作为一个键值去找到对应方法的实现。一个<code>Objective-C</code>的方法是由<code>objc_method</code>结束体定义的，其声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct objc_method &#123;</div><div class="line"></div><div class="line">    SEL method_name                 	OBJC2_UNAVAILABLE;  // 方法名</div><div class="line">    char *method_types                  OBJC2_UNAVAILABLE;</div><div class="line">    IMP method_imp                      OBJC2_UNAVAILABLE;  // 方法实现</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就要求<code>selector</code>引用的方法必须对<code>ObjC</code>运行时是可见的。而<code>Swift</code>是静态语言，虽然继承自<code>NSObject</code>的类默认对<code>ObjC</code>运行时是可见的，但如果方法是由<code>private</code>关键字修饰的，则方法默认情况下对<code>ObjC</code>运行时并不是可见的，所以就导致了以上的异常：运行时并没找到<code>SwipeCardView</code>类的<code>beginDragged:</code>方法。</p>
<p>所以，我们必须将<code>private</code>修饰的方法暴露给运行时。正确的做法是在 <code>private</code> 前面加上 <code>@objc</code> 关键字，这样就OK了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@objc private func beginDragged(gestureRecognizer: UIPanGestureRecognizer) &#123;</div><div class="line">	// ....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外需要注意的是，如果我们的类是纯<code>Swift</code>类，而不是继承自<code>NSObject</code>，则不管方法是<code>private</code>还是<code>internal</code>或<code>public</code>，如果要用在<code>Selector</code>中，都需要加上<code>@objc</code>修饰符。</p>
<h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://swifter.tips/selector/" target="_blank" rel="external">SELECTOR</a></li>
<li><a href="http://stackoverflow.com/questions/24007650/selector-in-swift" target="_blank" rel="external">@selector() in Swift?</a></li>
</ol>
<h2 id="零碎"><a href="#零碎" class="headerlink" title="零碎"></a>零碎</h2><h3 id="Swift中枚举项设置相同的值"><a href="#Swift中枚举项设置相同的值" class="headerlink" title="Swift中枚举项设置相同的值"></a>Swift中枚举项设置相同的值</h3><p>在<code>Objective-C</code>及<code>C</code>语言中，在枚举中我们可以设置两个枚举项的值相等，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, Type) &#123;</div><div class="line">    TypeIn      = 0,</div><div class="line">    TypeOut     = 1,</div><div class="line">    TypeInOut   = 2,</div><div class="line">    TypeDefault = TypeIn</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在上例中，我们让枚举项<code>TypeDefault</code>的值等于<code>TypeIn</code>。</p>
<p>而在<code>Swift</code>中，要求枚举项的<code>rawValue</code>是唯一的，如果像下面这样写，则编译器会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">enum Type: UInt &#123;</div><div class="line">    case In         = 0</div><div class="line">    case Out        = 1</div><div class="line">    case InOut      = 2</div><div class="line">    case Default    = 0		// Error: Raw value for enum case is not unique</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那如果我们希望上面枚举中<code>Default</code>的值与<code>In</code>的值一样，那应该怎么做呢？这时候就需要充分利用<code>Swift</code>中<code>enum</code>的特性了。我们知道，<code>Swift</code>中的<code>enum</code>与结构体、类一样，可以为其定义属性和方法，所以我们可以如下处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">enum Type: UInt &#123;</div><div class="line">    case In         = 0</div><div class="line">    case Out        = 1</div><div class="line">    case InOut      = 2</div><div class="line"></div><div class="line">    static var Default: Type &#123;</div><div class="line">        get &#123;</div><div class="line">            return .In</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们将<code>Default</code>定义为<code>Type</code>的一个静态只读属性，这个属性与枚举的其它枚举项的调用方式是一样的，可以如下调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let type: Type = .Default</div></pre></td></tr></table></figure>
<h4 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a href="http://stackoverflow.com/questions/28037772/swift-enum-multiple-cases-with-the-same-value" target="_blank" rel="external">Swift enum multiple cases with the same value</a></li>
</ol>
<h3 id="Swift中如何实现IBOutletCollection"><a href="#Swift中如何实现IBOutletCollection" class="headerlink" title="Swift中如何实现IBOutletCollection"></a>Swift中如何实现IBOutletCollection</h3><p>在使用IB做界面开发时，我们经常需要将界面上的元素连接到我们的代码中。<code>IBOutlet</code>和<code>IBAction</code>就是专门用来做这事的两个关键字。另外在<code>Objective-C</code>还提供了一个伪关键字<code>IBOutletCollection</code>，它的实际作用是将界面上的一组相同的控件连接到一个数组中。具体可以参考<a href="http://southpeak.github.io/blog/2015/05/10/ioszhi-shi-xiao-ji-di-%5B%3F%5D-qi-2015-dot-05-dot-10/">iOS知识小集 第一期(2015.05.10)</a>中的<code>IBOutletCollection</code>一节。</p>
<p>在<code>Swift</code>中，同样提供了<code>@IBOutlet</code>和<code>@IBAction</code>实现<code>Objective-C</code>中对应的功能，不过却没提供<code>@IBOutletCollection</code>来将一组相同控件连接到一个数组中。那如果我们想实现类似的功能，需要怎么处理呢？</p>
<p>实际上，我们在IB中选中一组相同的控件，然后将其连到到代码中时，会生成一个<code>IBOutlet</code>修饰的控件数组，类似于如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@IBOutlet var numberButtons: [UIButton]!</div></pre></td></tr></table></figure>
<p>这就是<code>Swift</code>中类<code>IBOutletCollection</code>的处理。如果需要往数组中添加新建的对应的控件，则只需要在代码前面的小圆点与UI上的控件做个连线就OK了。而如果要想将控件从数组中移除，则只需要将对应的连接关系移除就可以了。</p>
<h4 id="参考-4"><a href="#参考-4" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a href="http://southpeak.github.io/blog/2015/05/10/ioszhi-shi-xiao-ji-di-%5B%3F%5D-qi-2015-dot-05-dot-10/">iOS知识小集 第一期(2015.05.10)</a></li>
<li><a href="http://stackoverflow.com/questions/24052459/swift-iboutletcollection-equivalent" target="_blank" rel="external">Swift - IBOutletCollection equivalent</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/09/23/sourcecode-mmtweenanimation/" itemprop="url">
                  MMTweenAnimation实现分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-09-23T20:18:24+08:00" content="2015-09-23">
              2015-09-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/sourcecode/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先来个效果图吧：</p>
<p><img src="https://raw.githubusercontent.com/adad184/MMTweenAnimation/master/Images/2.gif" alt="image"></p>
<p>这是<code>MMTweenAnimation</code>库实现的一个弹跳动画。<code>MMTweenAnimation</code>基于Facebook的<code>pop</code>动画库，它提供了10套自定义的动画曲线，分别是：<code>Back</code>、<code>Bounce</code>、<code>Circ</code>、<code>Cubic</code>、<code>Elastic</code>、<code>Expo</code>、<code>Quad</code>、<code>Quart</code>、<code>Quint</code>、<code>Sine</code>。具体的效果可以参考<a href="https://github.com/adad184/MMTweenAnimation" target="_blank" rel="external">MMTweenAnimation</a>。</p>
<p>在这里，我们主要来<code>MMTweenAnimation</code>的具体实现及使用。</p>
<p>我们知道，动画实际上是许多帧静止的画面，以一定的速度连续播放，由于肉眼视觉残象产生的错觉，因此我们感觉画面是活动的。这就是动画的基本原理。所以，我们要做的就是按一定的速率去播放帧，在每一帧中计算曲线的路径，并将其绘制到界面上。这主要涉及到曲线的插值算法。</p>
<h3 id="主要部件"><a href="#主要部件" class="headerlink" title="主要部件"></a>主要部件</h3><p><code>MMTweenAnimation</code>的主体类主要有两个：<code>MMTweenAnimation</code>和<code>MMTweenFunction</code>。<code>MMTweenFunction</code>类主要定义各种插值算法，<code>MMTweenAnimation</code>主要是实现动画操作。</p>
<h4 id="MMTweenFunction类"><a href="#MMTweenFunction类" class="headerlink" title="MMTweenFunction类"></a>MMTweenFunction类</h4><p><code>MMTweenFunction</code>类主要是实现各种插值算法。这些插值算法分别10类，即上面列出的10套动画。而每套根据不同的缓动方式，又分为<code>EaseIn</code>、<code>EaseOut</code>、<code>EaseInOut</code>三种，因此<code>MMTweenAnimation</code>库实际上是实现了30种动画。每个插值算法都实现为一个闭包函数，其定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typealias MMTweenFunctionBlock = (t: <span class="built_in">CFTimeInterval</span>,            <span class="comment">// 当前时间与起始时间的差值</span></div><div class="line">                                  b: Double,                    <span class="comment">// 起点</span></div><div class="line">                                  c: Double,                    <span class="comment">// 起点与终点的差值</span></div><div class="line">                                  d: <span class="built_in">CFTimeInterval</span>) -&gt; Double  <span class="comment">// 动画持续时间</span></div></pre></td></tr></table></figure>
<p>而每个动画的插值都是根据数学公式算法出来的，我们以图例中的<code>Bounce-EaseOut</code>动画为例，其实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">let bounceOut: MMTweenFunctionBlock = &#123; (t, b, c, d) -&gt; Double <span class="keyword">in</span></div><div class="line">    let k: Double = <span class="number">2.75</span></div><div class="line">    var t1 = t / d</div><div class="line">    <span class="keyword">if</span> t1 &lt; (<span class="number">1</span> / k) &#123;</div><div class="line">        <span class="keyword">return</span> c * (<span class="number">7.5625</span> * t1 * t1) + b</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> t1 &lt; (<span class="number">2</span> / k) &#123;</div><div class="line">        t1 -= <span class="number">1.5</span> / k</div><div class="line">        <span class="keyword">return</span> c * (<span class="number">7.5625</span> * t1 * t1 + <span class="number">0.75</span>) + b</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> t1 &lt; (<span class="number">2.5</span> / k) &#123;</div><div class="line">        t1 -= <span class="number">2.25</span> / k</div><div class="line">        <span class="keyword">return</span> c * (<span class="number">7.5625</span> * t1 * t1 + <span class="number">0.9375</span>) + b</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        t1 -= <span class="number">2.625</span> / k</div><div class="line">        <span class="keyword">return</span> c * (<span class="number">7.5625</span> * t1 * t1 + <span class="number">0.984375</span>) + b</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>计算出来的插值将会用于计算当前帧的终点值。</p>
<h4 id="MMTweenAnimation类"><a href="#MMTweenAnimation类" class="headerlink" title="MMTweenAnimation类"></a>MMTweenAnimation类</h4><p><code>MMTweenAnimation</code>是实现动画的主体类。这个类继承自<code>pop</code>的<code>POPCustomAnimation</code>，<code>POPCustomAnimation</code> 直接继承自<code>PopAnimation</code>类，用于创建自定义动画的基类，它基本上是一个 <code>display link</code>的方便的转换，来在动画的每一个<code>tick</code>的回调<code>block</code>中驱动自定义的动画。</p>
<p><code>MMTweenAnimation</code>定义了几个基本属性，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> MMTweenAnimation: POPCustomAnimation &#123;</div><div class="line">    var animationBlock: MMTweenAnimationBlock?          <span class="comment">// 动画回调</span></div><div class="line">    var fromValue: [<span class="built_in">CGFloat</span>]?                           <span class="comment">// 起点数组</span></div><div class="line">    var toValue: [<span class="built_in">CGFloat</span>]?                             <span class="comment">// 终点数组</span></div><div class="line">    var duration: Double = <span class="number">0.3</span>                          <span class="comment">// 动画时长</span></div><div class="line"></div><div class="line">    <span class="comment">// ......</span></div><div class="line">    var functionBlock: MMTweenFunctionBlock?			<span class="comment">// 动画插值Block</span></div><div class="line">    <span class="comment">// ......</span></div><div class="line"></div><div class="line">    <span class="comment">// ......</span></div><div class="line">    var functionType: MMTweenFunctionType				<span class="comment">// 动画插值类型</span></div><div class="line">    <span class="comment">// ......</span></div><div class="line"></div><div class="line">    <span class="comment">// ......</span></div><div class="line">    var easingType: MMTweenEasingType					<span class="comment">// 动画缓动类型</span></div><div class="line">    <span class="comment">// ......</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而<code>MMTweenAnimation</code>类最关键的是定义它的回调<code>block</code>。<code>MMTweenAnimation</code>类定义了一个类方法<code>animation()</code>，在这个方法中，通过调用从父类继承来的便捷初始化方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public convenience init!(block: POPCustomAnimationBlock!)</div></pre></td></tr></table></figure>
<p>来创建一个<code>MMTweenAnimation</code>对象。其实现如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> func animation() -&gt; MMTweenAnimation? &#123;</div><div class="line"></div><div class="line">        let tweaner: MMTweenAnimation = MMTweenAnimation &#123; (target, animation) -&gt; Bool <span class="keyword">in</span></div><div class="line"></div><div class="line">            let anim: MMTweenAnimation = animation as! MMTweenAnimation</div><div class="line"></div><div class="line">            let t = animation.currentTime - animation.beginTime <span class="comment">// 当前时间与起始时间的差值</span></div><div class="line">            let d = anim.duration</div><div class="line"></div><div class="line">            assert(anim.fromValue!.count == anim.toValue!.count, <span class="string">"fromValue.count != toValue.count"</span>)</div><div class="line"></div><div class="line">            <span class="keyword">if</span> t &lt; d &#123;      <span class="comment">// 确保在动画持续时间类才处理</span></div><div class="line">                var values: [<span class="built_in">CGFloat</span>] = [<span class="built_in">CGFloat</span>]()</div><div class="line"></div><div class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0.</span>.&lt;anim.fromValue!.count &#123;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> let functionBlock = anim.functionBlock &#123;     <span class="comment">// 计算插值</span></div><div class="line">                        values.append(<span class="built_in">CGFloat</span>(functionBlock(t: t, b: Double(anim.fromValue![i]), c: Double(anim.toValue![i]) - Double(anim.fromValue![i]), d: d)))</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> let animationBlock = anim.animationBlock &#123;   <span class="comment">// 动画回调，以实现绘制操作</span></div><div class="line">                    animationBlock(time: t, duration: d, values: values, target: target, animation: anim)</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> tweaner</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>其中动画回调的定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typealias MMTweenAnimationBlock = (time: <span class="built_in">CFTimeInterval</span>, duration: <span class="built_in">CFTimeInterval</span>, values: [<span class="built_in">CGFloat</span>], target: AnyObject, animation: MMTweenAnimation) -&gt; Void</div></pre></td></tr></table></figure>
<p>以上两个类便是<code>MMTweenAnimation</code>的主要部件。</p>
<h3 id="动画示例"><a href="#动画示例" class="headerlink" title="动画示例"></a>动画示例</h3><p>有了主要部件，我们就来看看怎么去使用它。<code>MMTweenAnimation</code>给了一个示例，其效果就是开头的图例。为此，<code>MMTweenAnimation</code>定义了类<code>MMPaintView</code>，这个类的主要目的就是绘制上面的曲线，其主要操作如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">func addDot(point: <span class="built_in">CGPoint</span>) &#123;</div><div class="line">    __dots.append(point)</div><div class="line">    <span class="comment">// __path = __interpolateCGPointsWithHermite(__dots)</span></div><div class="line">    __path = __interpolateCGPointsWithCatmullRom(__dots)</div><div class="line">    setNeedsDisplay()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法首先是将参数中的点(即每一帧计算出来的终点值)添加到对象的<code>__dots</code>数组中，然后再通过<code>__interpolateCGPointsWithCatmullRom</code>方法创建一条<code>Bezier</code>曲线，最后调用<code>setNeedsDisplay()</code>来重新绘制曲线。</p>
<p>我们先来看看这个点是如何获取到的。在<code>MMAnimationController</code>类，我们定义动画对象时，设置了其动画回调，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">__anim!.animationBlock = &#123; [unowned <span class="keyword">self</span>] (diff: <span class="built_in">CFTimeInterval</span>, duration: <span class="built_in">CFTimeInterval</span>, values: [<span class="built_in">CGFloat</span>], target: AnyObject, animation: MMTweenAnimation) -&gt; Void <span class="keyword">in</span></div><div class="line">    let value: <span class="built_in">CGFloat</span> = values[<span class="number">0</span>]          <span class="comment">// 获取当前时间结束点的值</span></div><div class="line"></div><div class="line">    <span class="keyword">self</span>.__dummy!.center = <span class="built_in">CGPoint</span>(x: <span class="keyword">self</span>.__dummy!.center.x, y: value)     <span class="comment">// 计算小红点的中心位置</span></div><div class="line">    <span class="keyword">self</span>.__ball!.center = <span class="built_in">CGPoint</span>(x: <span class="number">50.0</span> + (<span class="built_in">CGRectGetWidth</span>(<span class="built_in">UIScreen</span>.mainScreen().bounds) - <span class="number">150.0</span>) * <span class="built_in">CGFloat</span>(diff / duration), y: value)</div><div class="line"></div><div class="line">    <span class="keyword">self</span>.__paintView!.addDot(<span class="keyword">self</span>.__ball!.center)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个动画回调获取当前时间结束点的值，用于设置小红点的中心位置，同时将这个中心位置的值丢给<code>MMPaintView</code>对象去生成<code>Bezier</code>曲线。</p>
<h3 id="动画渲染操作执行的时间点"><a href="#动画渲染操作执行的时间点" class="headerlink" title="动画渲染操作执行的时间点"></a>动画渲染操作执行的时间点</h3><p>知道了<code>MMTweenAnimation</code>库的主要部件，我们现在来看看动画是如何被驱动的。我们在<code>MMTweenAnimation</code>类的<code>animation()</code>方法中，在动画回调的起始位置打个断点，运行一下程序，看看调用栈，如下所示：</p>
<p><img src="https://raw.githubusercontent.com/southpeak/Blog-images/master/MMTweenAnimation-stack.png" alt="image"></p>
<p>可以看到在<code>Run Loop</code>中执行了一个观察者回调，在这个回调中调用了<code>POPAnimator</code>对象的<code>_scheduleProcessPendingList</code>方法的一个<code>block</code>回调，一直追溯到我们的动画操作。也就是说，是在<code>Run Loop</code>的某个时刻执行了一次动画的渲染。</p>
<p>我们再从代码入手，来看看动画执行代码是什么时候添加到Run Loop中的。在<code>MMAnimationController</code>的<code>viewDidAppear</code>方法中，有如下调用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__dummy!.pop_addAnimation(__anim, forKey: <span class="string">"center"</span>)</div></pre></td></tr></table></figure>
<p>其中<code>pop_addAnimation</code>方法是<code>POPAnimator</code>类中定义的。顺着代码，我们最终可以找到<code>_scheduleProcessPendingList</code>的定义，其实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)_scheduleProcessPendingList</div><div class="line">&#123;</div><div class="line">  <span class="comment">// ......</span></div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!_pendingListObserver) &#123;</div><div class="line">    __<span class="keyword">weak</span> POPAnimator *weakSelf = <span class="keyword">self</span>;</div><div class="line">	</div><div class="line">    <span class="comment">// 添加Run Loop监听器</span></div><div class="line">    _pendingListObserver = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(kCFAllocatorDefault, kCFRunLoopBeforeWaiting | kCFRunLoopExit, <span class="literal">false</span>, POPAnimationApplyRunLoopOrder, ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</div><div class="line">      [weakSelf _processPendingList];</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (_pendingListObserver) &#123;</div><div class="line">      <span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetMain</span>(), _pendingListObserver,  kCFRunLoopCommonModes);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// ......</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到在这个方法中创建了一个<code>Run Loop</code>的观察者，这个观察者在<code>Run Loop</code>的<code>kCFRunLoopBeforeWaiting</code>或<code>kCFRunLoopExit</code>阶段时会执行监听回调处理函数。回调函数中调用了<code>_processPendingList</code>方法，然后从调用栈里面可以看到，一直会执行到<code>MMTweenAnimation</code>的动画闭包中，即我们打断点的地方。</p>
<p>OK，动画渲染时间点找着了，那整个流程就可以完整拼接起来了。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><code>MMTweenAnimation</code>的实现并不复杂，只要了解了动画的基本原理和其中的插值算法，再加上一些<code>pop</code>动画的基础知识，基本上就OK了。要想做出很牛B的动画，还是需要大量的数学知识。其实在<code>MMTweenAnimation</code>库中，除了那10套插值算法外，在<code>MMPaintView</code>类中，计算<code>Bezier</code>的控制点时，还用到了Catmull-Rom样条与Hermite样条，大家有兴趣可以研究一下。</p>
<p><code>MMTweenAnimation</code>初始源码是<code>Objective-C</code>实现的，我将它用<code>Swift</code>重写了一遍，并放在github上，地址是<a href="https://github.com/southpeak/Swift/tree/master/Animation/MMTweenAnimation-Swift" target="_blank" rel="external">MMTweenAnimation-Swift</a>，有兴趣可以看一下。</p>
<p>本想放在知识小集中，但由于篇幅稍长，所以独立成篇。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://github.com/adad184/MMTweenAnimation" target="_blank" rel="external">MMTweenAnimation</a></li>
<li><a href="http://objccn.io/issue-12-6/" target="_blank" rel="external">交互式动画</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="南峰子" />
          <p class="site-author-name" itemprop="name">南峰子</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">82</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">南峰子</span>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1000523916'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1000523916%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
  </script>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  
  

  <div style="display: none;">
    <script src="http://s95.cnzz.com/z_stat.php?id=1000523916&web_id=1000523916" language="JavaScript"></script>
  </div>




</body>
</html>
